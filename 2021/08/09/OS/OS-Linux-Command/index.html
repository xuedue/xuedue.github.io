<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 介绍和命令 | xuedue</title><meta name="author" content="xuedue"><meta name="copyright" content="xuedue"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="查看PID所在的文件夹12cd &#x2F;proc&#x2F;23333  ls -al  1. Ubuntu Linux 系统的介绍1.1. Linux 操作系统的概述Linux 是一种自由和开源的 UNIX 类操作系统，其源代码可以被公开研究、更改和分发。Linux 由芬兰的 Linus Benedict Torvalds 于 1991 年首次发布，其设计遵循了 POSIX 和 Unix 的标准。 Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 介绍和命令">
<meta property="og:url" content="http://example.com/2021/08/09/OS/OS-Linux-Command/index.html">
<meta property="og:site_name" content="xuedue">
<meta property="og:description" content="查看PID所在的文件夹12cd &#x2F;proc&#x2F;23333  ls -al  1. Ubuntu Linux 系统的介绍1.1. Linux 操作系统的概述Linux 是一种自由和开源的 UNIX 类操作系统，其源代码可以被公开研究、更改和分发。Linux 由芬兰的 Linus Benedict Torvalds 于 1991 年首次发布，其设计遵循了 POSIX 和 Unix 的标准。 Linux">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/default.jpg">
<meta property="article:published_time" content="2021-08-09T15:23:47.000Z">
<meta property="article:modified_time" content="2026-02-04T16:38:43.931Z">
<meta property="article:author" content="xuedue">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/default.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 介绍和命令",
  "url": "http://example.com/2021/08/09/OS/OS-Linux-Command/",
  "image": "http://example.com/img/default.jpg",
  "datePublished": "2021-08-09T15:23:47.000Z",
  "dateModified": "2026-02-04T16:38:43.931Z",
  "author": [
    {
      "@type": "Person",
      "name": "xuedue",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/08/09/OS/OS-Linux-Command/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 介绍和命令',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(/img/bg_img.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 文章</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-face-grin-beam-sweat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">xuedue</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux 介绍和命令</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 文章</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-face-grin-beam-sweat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Linux 介绍和命令</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-09T15:23:47.000Z" title="发表于 2021-08-09 15:23:47">2021-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-04T16:38:43.931Z" title="更新于 2026-02-04 16:38:43">2026-02-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Operating-System/">Operating System</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Operating-System/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2026-02-04 16:38:43&quot;}" hidden></div><h1 id="查看PID所在的文件夹"><a href="#查看PID所在的文件夹" class="headerlink" title="查看PID所在的文件夹"></a>查看PID所在的文件夹</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /proc/23333  </span><br><span class="line"><span class="built_in">ls</span> -al</span><br></pre></td></tr></table></figure>

<h1 id="1-Ubuntu-Linux-系统的介绍"><a href="#1-Ubuntu-Linux-系统的介绍" class="headerlink" title="1. Ubuntu Linux 系统的介绍"></a>1. Ubuntu Linux 系统的介绍</h1><h2 id="1-1-Linux-操作系统的概述"><a href="#1-1-Linux-操作系统的概述" class="headerlink" title="1.1. Linux 操作系统的概述"></a>1.1. Linux 操作系统的概述</h2><p>Linux 是一种自由和开源的 UNIX 类操作系统，其源代码可以被公开研究、更改和分发。Linux 由芬兰的 Linus Benedict Torvalds 于 1991 年首次发布，其设计遵循了 POSIX 和 Unix 的标准。</p>
<p>Linux 是一个多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 UNIX 工具软件、应用程序和网络协议，也支持 32 位和 64 位硬件。</p>
<p>Linux 的内核原始代码由 Linus Benedict Torvalds 撰写，但现在世界各地的程序员都参与了 Linux 的开发。根据开放源代码的特性，任何人都可以修改和改进 Linux，并且这种改动可以被广泛传播，让其他人也能从中受益。</p>
<h2 id="1-2-Linux-和-Windows-的主要区别"><a href="#1-2-Linux-和-Windows-的主要区别" class="headerlink" title="1.2. Linux 和 Windows 的主要区别"></a>1.2. Linux 和 Windows 的主要区别</h2><p>对于 C 开发者来说，Linux 和 Windows 的主要区别体现在以下几个方面：</p>
<p><strong>开发环境</strong>：Linux 提供了强大的终端和命令行工具，如 Bash Shell、sed、awk、grep 等，这些工具可以极大提高 C 程序员的生产力。另外，Linux 还支持了许多开源的编程工具，如 GCC、GDB、Valgrind 等。而在 Windows，这些工具可能需要额外安装，且可能不提供与 Linux 完全相同的功能。</p>
<p><strong>系统调用和库</strong>：Linux 遵循 POSIX 标准，其系统调用和库与 Unix 和其他 Unix-like 系统（如 macOS）高度兼容。这意味着，基于 POSIX 的 C 程序可以在这些系统之间轻松迁移。而 Windows 的系统调用和库则有很大不同，需要使用 Windows API，这可能导致移植性问题。</p>
<p><strong>文件系统</strong>：Linux 使用区分大小写的文件系统，而 Windows 默认不区分大小写。这可能在处理文件名时造成一些差异。此外，Linux 中所有内容都组织在一个单一的目录树下，包括文件、目录、设备等，这与 Windows 的驱动器字母（如 <code>C:</code>、<code>D:</code>）有很大不同。</p>
<h2 id="1-3-Linux-常见目录结构和作用"><a href="#1-3-Linux-常见目录结构和作用" class="headerlink" title="1.3. Linux 常见目录结构和作用"></a>1.3. Linux 常见目录结构和作用</h2><p>在 Linux 系统中，文件和目录的组织方式遵循了一种标准，称为文件系统层次结构标准（Filesystem Hierarchy Standard，FHS）。理解这些目录结构以及其各自的作用对于有效地使用和管理 Linux 系统是非常重要的。以下是 Linux 中一些最常见的目录及其作用：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>/</code></td>
<td>根目录，所有的目录都从这里开始。</td>
</tr>
<tr>
<td><code>/bin</code></td>
<td>包含了用户级别的基本命令，如 <code>ls</code>、<code>cp</code>、<code>rm</code> 等。</td>
</tr>
<tr>
<td><code>/sbin</code></td>
<td>包含了系统级别的命令，只有 root 用户可以执行。</td>
</tr>
<tr>
<td><code>/etc</code></td>
<td>包含所有系统管理所需要的配置文件和子目录。</td>
</tr>
<tr>
<td><code>/home</code></td>
<td>普通用户的主目录，例如 <code>/home/john</code> 是用户 john 的主目录。</td>
</tr>
<tr>
<td><code>/root</code></td>
<td>root 用户（系统管理员）的主目录。</td>
</tr>
<tr>
<td><code>/var</code></td>
<td>存储着在正常运行中的系统不断增加的文件。</td>
</tr>
<tr>
<td><code>/usr</code></td>
<td>存放和共享只读的数据，包括很多用户级别的应用程序、库等。</td>
</tr>
<tr>
<td><code>/tmp</code></td>
<td>用于存放临时文件，这些文件在系统重启后会被删除。</td>
</tr>
<tr>
<td><code>/lib</code></td>
<td>包含系统最基本的动态链接共享库。</td>
</tr>
<tr>
<td><code>/opt</code></td>
<td>用于存放所有的可选应用软件包。</td>
</tr>
<tr>
<td><code>/dev</code></td>
<td>包含所有的设备文件，硬件设备被视为文件，可以像操作文件一样操作这些设备。</td>
</tr>
</tbody></table>
<h2 id="1-4-Ubuntu-的特点和优势"><a href="#1-4-Ubuntu-的特点和优势" class="headerlink" title="1.4. Ubuntu 的特点和优势"></a>1.4. Ubuntu 的特点和优势</h2><p>Ubuntu 以其易用性、稳定性、丰富的软件和社区支持，以及强大的商业支持赢得了用户的喜爱。不少供应商的 SDK 需要在特定版本的 Ubuntu 下构建，这也是许多公司选择 Ubuntu 的原因之一。公司可以通过维护内部的镜像源，用户可以将 apt 源设置为公司的镜像源，这将显著提升 deb 包的下载速度，有效提高工作效率。</p>
<h2 id="1-5-Ubuntu-的配置"><a href="#1-5-Ubuntu-的配置" class="headerlink" title="1.5. Ubuntu 的配置"></a>1.5. Ubuntu 的配置</h2><p>运行在 VirtualBox 环境下的 Ubuntu 可以通过多种配置技巧来提升开发效率，以下是一些常见的配置方法：</p>
<p><strong>关闭屏幕锁定</strong>：在 Ubuntu 中，屏幕锁定功能可能会在你不操作电脑一段时间后自动启动，这可能会带来一些不便，因此建议关闭屏幕锁定。虽然这样可能会降低一些安全性，但如果你在已经给宿主机设置了密码和屏幕锁定的情况下，则已经处于一个安全的环境中，因此可以关闭虚拟机的屏幕锁定，这可以提高你的工作效率。</p>
<p><strong>安装增强功能套件</strong>：VirtualBox 的 “增强功能套件” 可以提供更好的视频性能，更强大的虚拟机控制，以及文件和文件夹的拖放功能。在 VirtualBox 的 “设备” 菜单中选择 “安装增强功能”，然后在虚拟机中运行自动启动的安装程序。</p>
<p><strong>设置共享文件夹</strong>：在主机和虚拟机之间共享文件可以大大提高工作效率。在 VirtualBox 的设置中，你可以为虚拟机设置一个或多个共享文件夹。</p>
<p><strong>使用双向剪贴板</strong>：在主机和虚拟机之间共享剪贴板可以让你在两个环境中更轻松地复制和粘贴文本。在 VirtualBox 的设置中，选择 “常规”，然后在 “高级” 选项卡中设置 “双向” 剪贴板。</p>
<p><strong>调整处理器分配</strong>：如果你的主机有多个处理器核心，你可以调整虚拟机使用的核心数，以获得更好的性能。在 VirtualBox 的设置中，选择 “系统”，然后在 “处理器” 选项卡中设置核心数。</p>
<p><strong>调整内存分配</strong>：可以调整虚拟机使用的内存数，以获得更好的性能。通常，根据你的电脑的硬件配置和你要运行的任务，你可以设置为你电脑 RAM 的一半。</p>
<p><strong>通过 SSH 连接到虚拟机</strong>：，如果你主要用命令行进行工作，完全可以关闭图形界面以节省资源。你可以通过 SSH 连接到虚拟机，这样可以显著减少内存的使用，从而提高系统的整体性能。建议在熟悉 Samba 和共享文件夹的操作后，有余力和有需要的情况下再开展。下面是如何进行这些操作的步骤：</p>
<ol>
<li><strong>关闭图形界面</strong>：Ubuntu 默认启动图形用户界面，但是我们可以设置为命令行模式，以下是如何设置的步骤：<ul>
<li>打开终端。</li>
<li>输入 <code>sudo systemctl set-default multi-user.target</code> 并回车。你可能需要输入你的密码。</li>
<li>重启你的系统，你会发现系统启动后进入命令行模式。</li>
</ul>
</li>
<li><strong>设置 SSH 连接</strong>：为了远程访问你的 Ubuntu 系统，你需要安装并设置 SSH 服务，以下是如何设置的步骤：</li>
</ol>
<p>在你的 Ubuntu 系统中，打开终端。</p>
<ul>
<li>输入 <code>sudo apt-get update</code> 来更新你的包列表。</li>
<li>输入 <code>sudo apt-get install openssh-server</code> 来安装 SSH 服务器。</li>
<li>输入 <code>sudo systemctl start ssh</code> 来启动 SSH 服务。</li>
<li>输入 <code>sudo systemctl enable ssh</code> 来设置 SSH 服务在启动时自动运行。</li>
</ul>
<p>现在你可以从你的主机或其他电脑通过 SSH 连接到你的 Ubuntu 系统了，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@ip-address</span><br></pre></td></tr></table></figure>

<p>其中，username 是你的 Ubuntu 用户名，ip-address 是你的 Ubuntu 系统的 IP 地址。</p>
<ol>
<li><strong>调整内存分配</strong>：现在你可以进一步调整内存分配了。现在你可以设置的更小一些，因为你关闭了图形界面。</li>
</ol>
<p>通过关闭图形界面并使用 SSH 连接，你可以使你的 Ubuntu 虚拟机更高效地使用资源。</p>
<p>如果你之后需要再次使用 Ubuntu 的图形界面，你可以按照以下步骤操作：</p>
<ol>
<li>打开虚拟机内的终端。</li>
<li>输入以下命令并回车：<code>sudo systemctl set-default graphical.target</code>。这将把默认目标设置回图形用户界面。</li>
<li>重启你的系统。你可以输入 <code>sudo reboot</code> 命令并回车来重启你的系统。</li>
</ol>
<p>重启后，你的 Ubuntu 系统会启动到图形用户界面。</p>
<h1 id="2-Ubuntu-Linux-环境的基本操作"><a href="#2-Ubuntu-Linux-环境的基本操作" class="headerlink" title="2. Ubuntu Linux 环境的基本操作"></a>2. Ubuntu Linux 环境的基本操作</h1><h2 id="2-1-Nautilus-文件管理器"><a href="#2-1-Nautilus-文件管理器" class="headerlink" title="2.1. Nautilus 文件管理器"></a>2.1. Nautilus 文件管理器</h2><p>Nautilus 是 Ubuntu 系统中默认的文件管理器，提供了强大的文件浏览和管理功能。</p>
<h3 id="Nautilus-基础用法"><a href="#Nautilus-基础用法" class="headerlink" title="Nautilus 基础用法"></a>Nautilus 基础用法</h3><p>Nautilus 文件管理器允许你浏览和管理文件和目录。你可以通过双击桌面上的 “文件” 图标，或者在 Dash（Ubuntu 默认的应用启动器）中搜索 “文件” 来打开 Nautilus。</p>
<p>Nautilus 的主窗口分为三个主要部分：</p>
<ul>
<li>左侧的边栏显示了你的文件系统的各个位置，包括你的主目录、网络位置、已连接的设备和书签。</li>
<li>中央的主视图显示了当前选定位置的文件和目录。</li>
<li>顶部的工具栏提供了各种文件操作的按钮，如创建新文件夹、改变视图模式、搜索文件等。</li>
</ul>
<h3 id="Nautilus-快捷键"><a href="#Nautilus-快捷键" class="headerlink" title="Nautilus 快捷键"></a>Nautilus 快捷键</h3><p>Nautilus 提供了许多快捷键以便更快速、更有效地进行文件操作。以下是一些常用的快捷键：</p>
<ul>
<li><code>Ctrl+H</code>：显示或隐藏隐藏文件。在 Linux 中，隐藏文件的文件名是以 “.” 开头的。</li>
<li><code>Ctrl+L</code>：高亮地址栏，让你可以输入路径或 URL，这对于访问网络位置非常有用。</li>
<li><code>Ctrl+N</code>：打开新的 Nautilus 窗口。</li>
<li><code>Ctrl+T</code>：在当前 Nautilus 窗口中打开新的标签。</li>
<li><code>Ctrl+W</code>：关闭当前 Nautilus 窗口或标签。</li>
<li><code>Ctrl+D</code>：将当前位置添加到书签。</li>
<li><code>Ctrl+1</code>和 <code>Ctrl+2</code>：在图标视图和列表视图之间切换。</li>
</ul>
<h3 id="通过-SMB-协议访问特定-URL"><a href="#通过-SMB-协议访问特定-URL" class="headerlink" title="通过 SMB 协议访问特定 URL"></a>通过 SMB 协议访问特定 URL</h3><p>Nautilus 支持通过多种协议来访问网络位置，包括 SMB、FTP、SFTP 等。你可以直接在地址栏中输入 URL 来访问这些位置。</p>
<p>以下是通过 SMB 协议访问特定 URL 的步骤：</p>
<ol>
<li>打开 Nautilus 并按 <code>Ctrl+L</code> 来高亮地址栏。</li>
<li>在地址栏中输入 SMB URL，格式为 <code>smb://hostname_or_IP/shared_folder</code>。例如，如果你想访问名为 “file.com” 的主机上的 “Public” 共享文件夹，你应该输入 <code>smb://file.com/Public</code>。</li>
<li>按 Enter 键。如果需要，输入你的用户名和密码，然后点击 “连接”。</li>
</ol>
<p>这样，你就可以在 Nautilus 中浏览和管理 SMB 共享的文件和目录了。</p>
<h2 id="2-2-命令语法"><a href="#2-2-命令语法" class="headerlink" title="2.2. 命令语法"></a>2.2. 命令语法</h2><p>Bash 命令的基本语法是 <code>command [options] [arguments]</code>。</p>
<ul>
<li><code>command</code> 是想要执行的命令的名称。</li>
<li><code>[options]</code> 是可选的，用于修改命令的行为。它们通常以破折号 <code>-</code> 开始。例如，<code>ls -l</code> 中的 <code>-l</code> 是一个选项，它告诉 <code>ls</code> 以列表形式显示文件。</li>
<li><code>[arguments]</code> 也是可选的，它们是命令要操作的对象。例如，<code>cd /path/to/directory</code> 中的 <code>/path/to/directory</code> 是一个参数，它告诉 <code>cd</code> 要切换到哪个目录。</li>
</ul>
<h2 id="2-3-命令提示符"><a href="#2-3-命令提示符" class="headerlink" title="2.3. 命令提示符"></a>2.3. 命令提示符</h2><p>在 Bash shell 中，命令提示符是出现在每行命令前的字符或一组字符。它通常用于提供有关环境或当前状态的信息。</p>
<p>默认的 Bash 命令提示符是一个美元符号 <code>$</code>。对于 root 用户，命令提示符是井号 <code>#</code>。</p>
<p>你可以通过修改 <code>PS1</code> 环境变量来自定义命令提示符。例如，如果你想让命令提示符显示当前目录，你可以输入 <code>export PS1=&#39;\w\$ &#39;</code>。这将使命令提示符显示当前工作目录的完整路径。</p>
<p>你可以通过编辑 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 文件（取决于你的系统和特定的环境）来使改变的命令提示符在每次新开启的 Bash 会话中都自动显示当前目录。</p>
<p>下面是具体步骤：</p>
<ol>
<li>使用文本编辑器打开 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 文件。例如，你可以在 Bash 中输入 <code>nano ~/.bashrc</code> 或 <code>nano ~/.bash_profile</code>。</li>
<li>在文件的末尾添加以下行：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PS1=&#x27;\w\$ &#x27;</span><br></pre></td></tr></table></figure>

<ol>
<li>保存并关闭文件。</li>
<li>为了让改变立即生效，你需要在 Bash 中输入 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code>。或者，你可以通过关闭并重新打开 Bash 会话来让改变生效。</li>
</ol>
<p>这样，每次新开启的 Bash 会话都将显示当前目录在命令提示符中。</p>
<p>请注意，<code>~/.bashrc</code> 文件通常用于非登录 shell （例如，新打开的终端窗口），而 <code>~/.bash_profile</code> 文件通常用于登录 shell （例如，通过 SSH 登录）。在某些系统中，可能只有其中一个文件存在。如果都存在，可以选择一个进行编辑，或者在 <code>~/.bash_profile</code> 中添加一行 <code>source ~/.bashrc</code>，以确保无论使用哪种类型的 shell，都会读取 <code>~/.bashrc</code> 中的设置。</p>
<h2 id="2-4-系统操作"><a href="#2-4-系统操作" class="headerlink" title="2.4. 系统操作"></a>2.4. 系统操作</h2><p>正确地管理虚拟机的状态是非常重要的，以确保数据的完整性和系统的稳定性。以下是一些关于管理虚拟机状态的建议：</p>
<ol>
<li><strong>保存状态</strong>：在 VirtualBox 中，你可以选择保存虚拟机的当前状态，而不是完全关闭虚拟机。这就像是在物理机上休眠。当你下次启动虚拟机时，它会恢复到你保存状态时的情况。你可以在 VirtualBox 的 “机器” 菜单中选择 “保存状态” 来进行这个操作。</li>
<li><strong>优雅地关机</strong>：如果你需要完全关闭虚拟机，你应该在虚拟机内部执行关机命令，而不是强制关闭虚拟机。在 Ubuntu 中，你可以输入 <code>sudo poweroff</code> 命令来优雅地关机。这会让系统有足够的时间来正确地关闭所有的进程和服务，然后安全地关机。</li>
</ol>
<p>强制关闭虚拟机（就像物理机突然断电一样）可能会导致数据丢失或系统错误。因此，你应该尽量避免这样做，除非你没有其他选择。</p>
<p>通过正确地管理虚拟机的状态，你可以最大限度地保护你的数据，并确保系统的稳定性和可靠性。</p>
<p>如果你的磁盘空间不足，你需要找到占用大量空间的文件或目录。</p>
<ul>
<li>检查磁盘使用情况：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># df = disk free</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>

<ul>
<li>目录大小统计</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># du = disk usage 磁盘使用率</span><br><span class="line">du -sh</span><br><span class="line"># 查看当前目录各级子目录空间占用情况</span><br><span class="line">du -sh .</span><br><span class="line"># 查看当前目录下一级子文件和子目录占用的磁盘容量</span><br><span class="line">du -lh --max-depth=1</span><br></pre></td></tr></table></figure>

<h2 id="2-5-环境变量"><a href="#2-5-环境变量" class="headerlink" title="2.5. 环境变量"></a>2.5. 环境变量</h2><p>在 Linux 操作系统中，环境变量是用户和系统进程之间的一种信息交互方式，它们包含了诸多用于控制系统行为的重要数据。环境变量的值可以在当前 Shell 会话以及其启动的任何子进程中被访问和使用。环境变量可包含诸如软件安装的路径、当前用户的主目录或者可执行文件的默认位置等信息。下面我们将以 PATH 环境变量为例，来讲解如何在 Linux 中定义和修改环境变量。</p>
<p>PATH 是一个在 Linux 和其他 Unix-like 系统中非常关键的环境变量，它决定了 Shell 在哪些目录下查找用户输入的命令。当你在终端输入一个命令，Shell 将在 PATH 变量指定的目录中，依次查找对应的可执行文件。</p>
<p>你可以使用 <code>echo</code> 命令查看当前的 PATH 变量值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

<p>此命令会返回一个由冒号（:）分隔的目录列表，这些目录就是 Shell 查找命令的路径。</p>
<p>如果你想修改 PATH 变量，有两种方式：一种是临时修改，另一种是永久修改。</p>
<p><strong>临时修改</strong>：此种修改方式只在当前的 Shell 会话中有效。当你关闭终端或启动新的 Shell 会话时，修改不会被保存。例如，你可以使用下列命令临时添加一个目录到 PATH 变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/path/to/your/dir</span><br></pre></td></tr></table></figure>

<p>在上述命令中，<code>/path/to/your/dir</code> 是你希望添加的新目录路径。</p>
<p><strong>永久修改</strong>：如果你希望修改的 PATH 变量能在新的 Shell 会话或系统重启后仍然有效，你应该在 Shell 的配置文件中修改 PATH 变量。对于 Bash Shell，你可以在用户的 home 目录下的 <code>.bashrc</code> 或 <code>.bash_profile</code> 文件中修改 PATH 变量。如下所示：</p>
<p>打开 <code>.bashrc</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>在文件的末尾添加下列行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/path/to/your/dir</span><br></pre></td></tr></table></figure>

<p>保存并关闭文件。然后，你可以通过执行下列命令使更改立即生效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>以上就是如何在 Linux 中定义和修改 PATH 环境变量的过程。对于其他环境变量，你可以采取类似的步骤来进行修改和定义。在实际应用中，你应当根据实际需求来设置和使用环境变量。</p>
<h2 id="2-6-文件和目录操作"><a href="#2-6-文件和目录操作" class="headerlink" title="2.6. 文件和目录操作"></a>2.6. 文件和目录操作</h2><p>在 Ubuntu Linux 中，有一系列的命令用于管理文件和目录：</p>
<p>下面是对以上每个命令的详细介绍，包括常见的选项和操作技巧：</p>
<p>**<code>ls</code>**：这个命令用于列出当前目录的内容。常用的选项包括：</p>
<ul>
<li><code>-l</code>：以详细格式列出文件 / 目录信息，包括权限、所有者、大小、修改时间等。</li>
<li><code>-a</code>：显示所有文件，包括隐藏文件（以 <code>.</code> 开头的文件）。</li>
<li><code>-h</code>：以易读的格式显示文件大小（例如，显示 <code>1K</code> <code>234M</code> <code>2G</code>）。</li>
<li><code>-1</code>：以一列的方式显示文件和目录，这在需要清晰看到每个文件和目录时非常有用。</li>
</ul>
<p>例如，<code>ls -lha</code> 会以详细格式列出所有文件，包括隐藏文件，并以易读的格式显示文件大小。</p>
<p>此外，<code>ls</code> 命令可以与管道 <code>|</code> 和 <code>grep</code> 命令结合使用来过滤输出结果。例如，如果你只想列出所有 <code>.txt</code> 文件，你可以使用 <code>ls | grep .txt</code> 命令。这里，<code>grep .txt</code> 会过滤出包含 <code>.txt</code> 的行。</p>
<p>**<code>tree</code>**：这个命令用于以树状图列出目录的内容。常用的选项包括：</p>
<ul>
<li><code>-f</code>：在每个文件或目录前面显示完整的路径前缀。这会使得每个文件名前面都有一个对应的路径。</li>
<li><code>-i</code>：不显示树状图结构。只显示文件和目录的名称。这个选项通常用来提供一个非分层的文件列表。</li>
<li><code>-n</code>：禁止打印文件和目录名的颜色。默认情况下，tree命令会使用颜色来标记文件和目录的类型，例如目录、符号链接、文件等。使用 <code>-n</code> 选项，tree将只以纯文本的形式打印名称。</li>
<li><code>-d</code>：只显示目录，不显示文件。这可以帮助你快速查看目录的结构，而忽略其中的文件。</li>
</ul>
<p>例如，<code>tree -f</code> 会以完整的路径前缀列出所有文件和目录。<code>tree -i</code> 则只显示文件和目录的名称，而不显示它们的结构。</p>
<p>此外，<code>tree</code> 命令可以使用 <code>-P</code> 选项配合通配符，来匹配特定的文件或目录。例如，如果你只想列出所有 <code>.txt</code> 文件，你可以使用 <code>tree -P &#39;*.txt&#39;</code> 命令。这里，<code>-P &#39;*.txt&#39;</code> 会过滤出所有后缀为 <code>.txt</code> 的文件。</p>
<p>**<code>cd</code>**：这个命令用于改变工作目录。你可以使用相对路径或绝对路径。以下是一些常见的使用方式：</p>
<ul>
<li><code>cd Documents</code>：将进入当前目录下的 “Documents” 目录。</li>
<li><code>cd /home/user/Documents</code>：将进入用户主目录下的 “Documents” 目录。</li>
<li><code>cd ..</code>：返回上级目录。</li>
<li><code>cd</code> 或 <code>cd ~</code>：返回用户主目录。</li>
</ul>
<p>此外，如果你想切换到上一次的工作目录，你可以使用 <code>cd -</code> 命令。这个命令会将当前的工作目录切换到上一次的工作目录。例如，如果你当前在 <code>/home/user/Documents</code> 目录，然后你执行 <code>cd /etc</code> 命令进入到 <code>/etc</code> 目录，此时你可以通过执行 <code>cd -</code> 命令快速切换回 <code>/home/user/Documents</code> 目录。</p>
<p>**<code>pwd</code>**：这个命令用于显示当前工作目录的完整路径。它没有额外的选项。</p>
<p>**<code>cp</code>**：这个命令用于复制文件或目录。常用的选项包括：</p>
<ul>
<li><code>-r</code> 或 <code>-R</code>：递归复制，用于复制目录及其内部的所有文件和子目录。</li>
<li><code>-i</code>：在覆盖文件之前提示用户。</li>
<li><code>-v</code>：在复制过程中显示详细信息。</li>
<li><code>-f</code>：强制复制，即如果目标文件已经存在，不会询问用户，直接覆盖。</li>
</ul>
<p>例如，<code>cp -Riv source_dir destination_dir</code> 将复制整个 <code>source_dir</code> 目录（包括其内部的所有文件和子目录）到 <code>destination_dir</code>，并在覆盖文件之前提示用户，同时在过程中显示详细信息。</p>
<p>如果使用 <code>-f</code> 选项，如 <code>cp -Rfv source_dir destination_dir</code>，则在目标目录存在相同文件时，会直接进行覆盖，不会询问用户。</p>
<p>**<code>mv</code>**：这个命令用于移动或重命名文件或目录。常用的选项包括：</p>
<ul>
<li><code>-i</code>：在覆盖文件之前提示用户。</li>
<li><code>-v</code>：在移动过程中显示详细信息。</li>
</ul>
<p>例如，<code>mv -iv old.txt new.txt</code> 将把 <code>old.txt</code> 文件重命名为 <code>new.txt</code>，在覆盖文件之前会提示用户，同时显示详细信息。</p>
<p>**<code>rm</code>**：这个命令用于删除文件或目录。常用的选项包括：</p>
<ul>
<li><code>-r</code> 或 <code>-R</code>：递归删除，用于删除目录及其内部的所有文件和子目录。</li>
<li><code>-i</code>：在删除文件之前提示用户。</li>
<li><code>-v</code>：在删除过程中显示详细信息。</li>
<li><code>-f</code>：强制删除，即不会询问用户，直接删除目标文件或目录。如果文件不存在，也不会显示错误信息。</li>
</ul>
<p>例如，<code>rm -Riv target_dir</code> 将删除整个 <code>target_dir</code> 目录（包括其内部的所有文件和子目录），并在删除文件之前提示用户，同时在过程中显示详细信息。</p>
<p>如果使用 <code>-f</code> 选项，如 <code>rm -Rfv target_dir</code>，则在删除目标目录时，会直接进行删除，不会询问用户。</p>
<p>**<code>mkdir</code>**：这个命令用于创建新目录。常用的选项包括：</p>
<ul>
<li><code>-p</code>：创建多级目录。如果中间的某些目录不存在，会自动创建。</li>
</ul>
<p>例如，<code>mkdir -p Dir/SubDir</code> 将创建一个名为 “Dir” 的目录和一个名为 “SubDir” 的子目录。</p>
<p>**<code>rmdir</code>**：这个命令用于删除空目录。如果一个目录不为空（即，包含其他文件或子目录），则不能用 <code>rmdir</code> 删除。在这种情况下，你需要使用 <code>rm -r</code> 或 <code>rm -R</code> 命令。</p>
<h2 id="2-7-链接"><a href="#2-7-链接" class="headerlink" title="2.7. 链接"></a>2.7. 链接</h2><p>在 Linux 中，链接是一种特殊的文件类型，它允许我们创建对现有文件或目录的引用。链接有两种类型：硬链接和符号链接，也叫软链接。</p>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>硬链接是一个文件在磁盘上的一个引用。一个文件可能有一个以上的硬链接，每个硬链接都对应同一个文件的数据。这意味着，即使原始文件名被删除，只要至少有一个硬链接存在，文件的数据就可以被访问。</p>
<p>我们可以使用 <code>ln</code> 命令来创建硬链接。例如，要为一个名为 <code>file1</code> 的文件创建一个名为 <code>link1</code> 的硬链接，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln file1 link1</span><br></pre></td></tr></table></figure>

<p>虽然硬链接在许多情况下都很有用，但它们也有一些限制。首先，硬链接不能跨文件系统，也就是说，硬链接只能在同一文件系统的文件之间创建。其次，硬链接不能引用目录，只能引用文件。</p>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>符号链接（软链接）是对另一个文件或目录的间接指针。与硬链接不同，符号链接可以跨文件系统，可以链接目录，且它们是包含了目标文件路径的特殊文件。</p>
<p>我们可以使用 <code>ln</code> 命令的 <code>-s</code> 选项来创建符号链接。例如，要为一个名为 <code>file1</code> 的文件创建一个名为 <code>link1</code> 的符号链接，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s file1 link1</span><br></pre></td></tr></table></figure>

<p>与硬链接不同，如果删除了符号链接的目标文件，符号链接将变得无效。此外，符号链接的权限位通常显示为 <code>lrwxrwxrwx</code>，但实际上符号链接的权限由其目标文件的权限决定。</p>
<h3 id="查看链接"><a href="#查看链接" class="headerlink" title="查看链接"></a>查看链接</h3><p>我们可以使用 <code>ls -l</code> 命令来查看文件的链接信息。对于硬链接，<code>ls -l</code> 将显示文件的链接数量；对于符号链接，<code>ls -l</code> 将显示链接的目标文件。</p>
<h3 id="删除链接"><a href="#删除链接" class="headerlink" title="删除链接"></a>删除链接</h3><p>删除链接的方式与删除普通文件相同，使用 <code>rm</code> 命令。需要注意的是，删除一个硬链接不会影响其它链接，只有当所有链接都被删除，文件才会被真正删除。对于符号链接，删除链接不会删除目标文件。</p>
<p>以上就是 Linux 中的链接的基本概念和使用。理解和掌握链接，对于有效地管理和组织文件系统中的文件和目录具有重要意义。</p>
<h2 id="2-8-打包和解压"><a href="#2-8-打包和解压" class="headerlink" title="2.8. 打包和解压"></a>2.8. 打包和解压</h2><h3 id="tar-命令"><a href="#tar-命令" class="headerlink" title="tar 命令"></a>tar 命令</h3><p><code>tar</code>（磁带存档）命令是 Unix 和 Linux 系统中用于文件打包和解压的工具。<code>tar</code> 可以将多个文件和目录打包为一个 <code>tar</code> 文件，也可以将 <code>tar</code> 文件解压到其组成的文件和目录。以下是 <code>tar</code> 命令的一些常用选项和用法：</p>
<p><strong>创建存档</strong>：使用 <code>-c</code> 选项创建新的 <code>tar</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf archive.tar file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>这会创建一个名为 <code>archive.tar</code> 的文件，其中包含 <code>file1.txt</code> 和 <code>file2.txt</code>。</p>
<p><strong>列出存档内容</strong>：使用 <code>-t</code> 选项列出 <code>tar</code> 文件的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf archive.tar</span><br></pre></td></tr></table></figure>

<p>这会列出 <code>archive.tar</code> 文件中的所有文件和目录。</p>
<p><strong>解压存档</strong>：使用 <code>-x</code> 选项解压 <code>tar</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf archive.tar</span><br></pre></td></tr></table></figure>

<p>这会解压 <code>archive.tar</code> 文件中的所有文件和目录。</p>
<p><strong>带有 gzip 压缩的存档</strong>：使用 <code>-z</code> 选项创建或解压带有 gzip 压缩的 <code>tar</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf archive.tar.gz file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>这会创建一个 gzip 压缩的 <code>tar</code> 文件 <code>archive.tar.gz</code>，其中包含 <code>file1.txt</code> 和 <code>file2.txt</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf archive.tar.gz</span><br></pre></td></tr></table></figure>

<p>这会解压 gzip 压缩的 <code>tar</code> 文件 <code>archive.tar.gz</code>。</p>
<p><strong>带有 bzip2 压缩的存档</strong>：使用 <code>-j</code> 选项创建或解压带有 bzip2 压缩的 <code>tar</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cjvf archive.tar.bz2 file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>这会创建一个 bzip2 压缩的 <code>tar</code> 文件 <code>archive.tar.bz2</code>，其中包含 <code>file1.txt</code> 和 <code>file2.txt</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xjvf archive.tar.bz2</span><br></pre></td></tr></table></figure>

<p>这会解压 bzip2 压缩的 <code>tar</code> 文件 <code>archive.tar.bz2</code>。</p>
<p>在上述选项中，<code>v</code> 是可选的，它表示 “verbose”（详细），如果使用该选项，<code>tar</code> 命令会打印正在进行的操作。</p>
<p><code>tar</code> 命令是一个非常重要的工具，对于文件的打包和解压，以及和其他系统的文件交换，它都是非常有用的。</p>
<h3 id="unzip-命令"><a href="#unzip-命令" class="headerlink" title="unzip 命令"></a>unzip 命令</h3><p><code>unzip</code> 是一个在 Unix 和 Linux 系统中用于解压缩 ZIP 文件的命令。以下是 <code>unzip</code> 命令的一些常用选项和用法：</p>
<p><strong>解压缩 ZIP 文件</strong>：不带任何选项，直接使用 <code>unzip</code> 命令可以解压缩 ZIP 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip archive.zip</span><br></pre></td></tr></table></figure>

<p>这会解压缩 <code>archive.zip</code> 文件中的所有文件和目录到当前目录。</p>
<p><strong>列出 ZIP 文件内容</strong>：使用 <code>-l</code> 选项可以列出 ZIP 文件的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -l archive.zip</span><br></pre></td></tr></table></figure>

<p>这会列出 <code>archive.zip</code> 文件中的所有文件和目录，但不会解压缩。</p>
<p><strong>解压缩到指定目录</strong>：使用 <code>-d</code> 选项可以解压缩 ZIP 文件到指定目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip archive.zip -d /path/to/directory</span><br></pre></td></tr></table></figure>

<p>这会解压缩 <code>archive.zip</code> 文件到 <code>/path/to/directory</code> 目录。</p>
<p><strong>测试 ZIP 文件</strong>：使用 <code>-t</code> 选项可以测试 ZIP 文件的完整性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -t archive.zip</span><br></pre></td></tr></table></figure>

<p>这会检查 <code>archive.zip</code> 文件中的所有文件是否完整。</p>
<p><code>unzip</code> 命令是一个非常重要的工具，对于处理 ZIP 文件，无论是解压缩还是检查 ZIP 文件的完整性，它都是非常有用的。</p>
<h2 id="2-9-文本文件的操作"><a href="#2-9-文本文件的操作" class="headerlink" title="2.9. 文本文件的操作"></a>2.9. 文本文件的操作</h2><p>在 Ubuntu Linux 中，有几种方法可以查看文本文件的内容：</p>
<ul>
<li><code>cat</code>：显示文件的全部内容。例如，<code>cat file.txt</code> 会显示 <code>file.txt</code> 的全部内容。</li>
<li><code>more</code> 或 <code>less</code>：用分页的方式显示文件内容。例如，<code>more file.txt</code> 或 <code>less file.txt</code> 会以分页方式显示 <code>file.txt</code>。</li>
<li><code>tail</code>：显示文件的最后几行。例如，<code>tail file.txt</code> 会显示 <code>file.txt</code> 的最后 10 行。</li>
<li><code>head</code>：显示文件的前几行。例如，<code>head file.txt</code> 会显示 <code>file.txt</code> 的前 10 行。</li>
</ul>
<h2 id="2-10-计算哈希值"><a href="#2-10-计算哈希值" class="headerlink" title="2.10. 计算哈希值"></a>2.10. 计算哈希值</h2><p>在 Unix 和 Linux 系统中，可以使用 <code>md5sum</code> 和 <code>sha256sum</code> 命令计算文件的 MD5 和 SHA-256 哈希值。这些命令可以用于验证文件的完整性和验证下载的文件是否被篡改。</p>
<p><strong>计算文件的 MD5 哈希值</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum file.txt</span><br></pre></td></tr></table></figure>

<p>这将返回 <code>file.txt</code> 的 MD5 哈希值。</p>
<p><strong>计算文件的 SHA-256 哈希值</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sha256sum file.txt</span><br></pre></td></tr></table></figure>

<p>这将返回 <code>file.txt</code> 的 SHA-256 哈希值。</p>
<p>注意：上述命令输出的哈希值应该与预期的哈希值或提供者给出的哈希值匹配，以确保文件完整性和防止篡改。如果两个哈希值不匹配，那么文件可能已经被更改或损坏。</p>
<h2 id="2-11-编程和系统管理"><a href="#2-11-编程和系统管理" class="headerlink" title="2.11. 编程和系统管理"></a>2.11. 编程和系统管理</h2><p>在编程和系统管理中，还常用如下命令：</p>
<ul>
<li>diff 命令</li>
</ul>
<p><code>diff</code> 命令用于比较两个文件的不同点。这对于查看两个版本的文件之间的差异非常有用。例如，你可以使用以下命令比较 <code>file1</code> 和 <code>file2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff file1 file2</span><br></pre></td></tr></table></figure>

<p>这将输出 <code>file1</code> 和 <code>file2</code> 之间的所有差异。</p>
<ul>
<li>vimdiff 命令</li>
</ul>
<p><code>vimdiff</code> 是 <code>vim</code> 文本编辑器的一个模式，用于显示两个或多个文件的差异。它的使用方式和 <code>diff</code> 类似，但它提供了一个交互式的界面，可以更方便地浏览和编辑差异。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdiff file1 file2</span><br></pre></td></tr></table></figure>

<p>这将在 <code>vim</code> 中打开 <code>file1</code> 和 <code>file2</code>，并在分割的窗口中显示它们的差异。</p>
<ul>
<li>patch 命令</li>
</ul>
<p><code>patch</code> 命令用于将由 <code>diff</code> 生成的差异应用到文件中。这对于应用别人的更改或撤销自己的更改非常有用。例如，如果你有一个 <code>file.diff</code> 包含了 <code>file</code> 的一些更改，你可以使用以下命令应用这些更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch file file.diff</span><br></pre></td></tr></table></figure>

<p>这将应用 <code>file.diff</code> 中的所有更改到 <code>file</code> 中。</p>
<ul>
<li>file 命令</li>
</ul>
<p><code>file</code> 命令用于确定文件类型。这个命令对于查看未知文件的信息非常有用。它不仅可以识别文本文件，还可以识别二进制文件，如程序可执行文件。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file myscript.sh</span><br></pre></td></tr></table></figure>

<p>这将告诉你 <code>myscript.sh</code> 是什么类型的文件。</p>
<h2 id="2-12-输入输出重定向"><a href="#2-12-输入输出重定向" class="headerlink" title="2.12. 输入输出重定向"></a>2.12. 输入输出重定向</h2><p>在 Unix 和 Linux 系统中，<code>&gt;</code>、<code>&gt;&gt;</code>、<code>&lt;</code> 和 <code>&lt;&lt;</code> 是用于输入输出重定向的操作符。这些操作符可以帮助你将命令的输出写入文件，或者从文件中读取输入。</p>
<ul>
<li><code>&gt;</code>：这个操作符将命令的输出重定向到一个文件。如果文件已经存在，它会被覆盖。例如，<code>echo Hello &gt; file.txt</code> 会将 “Hello” 写入 <code>file.txt</code>，如果 <code>file.txt</code> 已经存在，它的内容会被 “Hello” 替换。</li>
<li><code>&gt;&gt;</code>：这个操作符将命令的输出追加到一个文件。如果文件已经存在，新的内容会被添加到文件的末尾。例如，<code>echo Hello &gt;&gt; file.txt</code> 会将 “Hello” 添加到 <code>file.txt</code> 的末尾。</li>
<li><code>&lt;</code>：这个操作符将文件的内容作为命令的输入。例如，<code>sort &lt; file.txt</code> 会将 <code>file.txt</code> 的内容排序。</li>
<li><code>&lt;&lt;</code>：这个操作符用于创建一个 “here-document”。”here-document” 是一个在 shell 脚本中使用的输入重定向方式，它可以将多行的输入重定向到一个命令。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF</span><br><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>这个命令会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure>

<p><code>EOF</code> 是 “End of File” 的缩写，它是 “here-document” 的结束标志。你可以使用其他的单词作为结束标志，但 <code>EOF</code> 是最常见的。在 <code>&lt;&lt; EOF</code> 和 <code>EOF</code> 之间的所有行都会被视为输入内容。</p>
<p>在 C 程序中，<code>scanf</code> 函数用于从标准输入（通常是键盘）读取数据。你可以使用输入重定向操作符（<code>&lt;</code>）将文件的内容作为输入提供给 <code>scanf</code> 函数。</p>
<p>例如，假设你有一个 C 程序 <code>program.c</code>，它使用 <code>scanf</code> 函数读取两个整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    scanf (&quot;% d % d&quot;, &amp;a, &amp;b);</span><br><span class="line">    printf (&quot;You entered: % d and % d</span><br><span class="line">&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以先编译这个程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc program.c -o program</span><br></pre></td></tr></table></figure>

<p>然后，你可以创建一个包含两个整数的文件 <code>input.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;123 456&quot; &gt; input.txt</span><br></pre></td></tr></table></figure>

<p>最后，你可以使用输入重定向操作符将 <code>input.txt</code> 的内容作为输入提供给 <code>program</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./program &lt; input.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You entered: 123 and 456</span><br></pre></td></tr></table></figure>

<p>这说明 <code>scanf</code> 函数已经成功地从 <code>input.txt</code> 中读取了两个整数。这种方法对于需要大量输入或者需要重复测试的情况非常有用。</p>
<h2 id="2-13-剪切"><a href="#2-13-剪切" class="headerlink" title="2.13. 剪切"></a>2.13. 剪切</h2><p><code>cut</code> 是一个在 Linux 和 Unix 系统中常用的命令行工具，它用于从文件或标准输入中提取或 “剪切” 出列的部分。<code>cut</code> 命令主要用于处理文本数据，特别是处理分隔符分隔的数据。下面是一些常用的 <code>cut</code> 命令选项以及使用示例。</p>
<p>cut 命令的选项：</p>
<ul>
<li><code>-d</code>：指定字段的分隔符，默认为制表符。例如，<code>-d &#39;:&#39;</code> 会设置分隔符为冒号。</li>
<li><code>-f</code>：指定要显示的字段。例如，<code>-f 1</code> 会显示第一个字段，<code>-f 1,3</code> 会显示第一个和第三个字段，<code>-f 1-3</code> 会显示第一到第三个字段。</li>
<li><code>-c</code>：指定要显示的字符。例如，<code>-c 1-10</code> 会显示每行的第一到第十个字符。</li>
</ul>
<p>cut 命令的使用示例：</p>
<p>假设有一个文件 <code>users.txt</code>，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alice:secret:1000:1000:Alice:/home/alice:/bin/bash</span><br><span class="line">bob:secret:1001:1001:Bob:/home/bob:/bin/bash</span><br></pre></td></tr></table></figure>

<p>以下是一些 <code>cut</code> 命令的使用示例：</p>
<ol>
<li>获取用户名：<code>cut -d &#39;:&#39; -f 1 users.txt</code>。这个命令会显示 <code>users.txt</code> 文件中的每一行的第 1 个字段，即用户名。</li>
<li>获取用户 ID：<code>cut -d &#39;:&#39; -f 3 users.txt</code>。这个命令会显示 <code>users.txt</code> 文件中的每一行的第 3 个字段，即用户 ID。</li>
<li>获取用户名和用户 ID：<code>cut -d &#39;:&#39; -f 1,3 users.txt</code>。这个命令会显示 <code>users.txt</code> 文件中的每一行的第 1 个和第 3 个字段，即用户名和用户 ID。</li>
</ol>
<p>以上就是 <code>cut</code> 命令的基本用法。在处理文本文件时，<code>cut</code> 命令是一个非常有用的工具。</p>
<h2 id="2-14-排序和去重"><a href="#2-14-排序和去重" class="headerlink" title="2.14. 排序和去重"></a>2.14. 排序和去重</h2><h3 id="sort-命令"><a href="#sort-命令" class="headerlink" title="sort 命令"></a>sort 命令</h3><p><code>sort</code> 的主要功能是对输入行进行排序。<code>sort</code> 可以基于字符串或数字排序，也可以基于字段排序。以下是一些常用的 <code>sort</code> 命令选项：</p>
<ul>
<li><code>-n</code>：基于数字值进行排序。</li>
<li><code>-r</code>：反向排序，即降序排序。</li>
<li><code>-k</code>：按照指定的字段进行排序。</li>
</ul>
<p>以下是一个 <code>sort</code> 命令的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -n -k 2 file.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会按照 <code>file.txt</code> 文件中的第2个字段进行数字排序。</p>
<h3 id="uniq-命令"><a href="#uniq-命令" class="headerlink" title="uniq 命令"></a>uniq 命令</h3><p><code>uniq</code> 的主要功能是从输入中过滤掉重复的行。<code>uniq</code> 命令通常与 <code>sort</code> 命令结合使用，因为 <code>uniq</code> 只能检测相邻的重复行。以下是一些常用的 <code>uniq</code> 命令选项：</p>
<ul>
<li><code>-d</code>：仅显示重复出现的行。</li>
<li><code>-u</code>：仅显示非重复的行。</li>
<li><code>-c</code>：显示每行在输入文件中出现的次数。</li>
</ul>
<p>以下是一个 <code>uniq</code> 命令的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort file.txt | uniq</span><br></pre></td></tr></table></figure>

<p>这个命令会先对 <code>file.txt</code> 文件进行排序，然后通过 <code>uniq</code> 删除所有重复的行。</p>
<p><code>uniq</code> 和 <code>sort</code> 命令都是处理文本文件的强大工具，它们可以帮助你进行数据清理和预处理，特别是在处理大量数据时。</p>
<h2 id="2-15-统计"><a href="#2-15-统计" class="headerlink" title="2.15. 统计"></a>2.15. 统计</h2><p><code>wc</code>（word count）命令是一个常用的 Unix/Linux 命令，它用于计算文本文件中的字节数、字数、行数。该命令接收文件名作为参数，然后返回三个值：行数、字数和字节数。</p>
<p><code>wc</code> 的常用选项包括：</p>
<ul>
<li><code>-l</code>：仅打印行数。</li>
<li><code>-w</code>：仅打印字数。</li>
<li><code>-c</code>：仅打印字节数。</li>
</ul>
<p>以下是一些常见的 <code>wc</code> 命令使用示例：</p>
<p><strong>计算文件的行数、字数和字节数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc file.txt</span><br></pre></td></tr></table></figure>

<p>这将返回三个值：<code>file.txt</code> 的行数、字数和字节数。</p>
<p><strong>仅计算文件的行数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -l file.txt</span><br></pre></td></tr></table></figure>

<p>这将返回 <code>file.txt</code> 的行数。</p>
<p><strong>仅计算文件的字数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -w file.txt</span><br></pre></td></tr></table></figure>

<p>这将返回 <code>file.txt</code> 的字数。</p>
<p><strong>仅计算文件的字节数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -c file.txt</span><br></pre></td></tr></table></figure>

<p>这将返回 <code>file.txt</code> 的字节数。</p>
<h2 id="2-16-搜索和替换"><a href="#2-16-搜索和替换" class="headerlink" title="2.16. 搜索和替换"></a>2.16. 搜索和替换</h2><p>在 Linux 系统中，有许多强大的命令行工具可以帮助你进行搜索和替换操作，包括但不限于 <code>grep</code>、<code>sed</code>、<code>awk</code>、<code>find</code> 等。下面是一些详细的使用这些工具进行搜索和替换的方法：</p>
<h3 id="使用-grep-进行搜索"><a href="#使用-grep-进行搜索" class="headerlink" title="使用 grep 进行搜索"></a>使用 <code>grep</code> 进行搜索</h3><p><code>grep</code> 命令是一个强大的文本搜索工具，它可以在文件或者标准输入（stdin）中搜索与指定模式相匹配的行。例如，下面的命令会在 <code>file.txt</code> 文件中搜索包含 ‘pattern’ 的所有行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;pattern&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将会在终端输出所有包含 ‘pattern’ 的行。但是，如果匹配的内容非常多，直接在终端显示可能会导致结果淹没在信息之中，影响查看。在这种情况下，你可以考虑将输出结果重定向到一个文件中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;pattern&#x27; file.txt &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会将所有包含 ‘pattern’ 的行输出到 <code>output.txt</code> 文件中，如果 <code>output.txt</code> 文件已经存在，这个命令会覆盖原有的文件内容。如果你想保留原有内容，可以使用 <code>&gt;&gt;</code> 追加内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;pattern&#x27; file.txt &gt;&gt; output.txt</span><br></pre></td></tr></table></figure>

<p>此外，你还可以使用 <code>-r</code>（或 <code>--recursive</code>）选项在目录及其子目录中递归搜索，或者使用 <code>-i</code>（或 <code>--ignore-case</code>）选项忽略大小写。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r &#x27;pattern&#x27; /path/to/directory &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会从 <code>/path/to/directory</code> 开始，递归搜索所有文件中包含 ‘pattern’ 的行，并将结果输出到 <code>output.txt</code> 文件中。</p>
<p>请注意，<code>grep</code> 命令还有许多其他选项，可以提供更多的搜索功能，例如只显示匹配数量（<code>-c</code>）、显示行号（<code>-n</code>）、使用 Perl 正则表达式（<code>-P</code>）等等。你可以通过 <code>man grep</code> 或 <code>grep --help</code> 来查看更多信息。</p>
<h3 id="使用-sed-进行替换"><a href="#使用-sed-进行替换" class="headerlink" title="使用 sed 进行替换"></a>使用 <code>sed</code> 进行替换</h3><p><code>sed</code> 是一个流编辑器，它可以对输入流（文件或者其他命令的输出）进行处理。最常见的用法之一是进行替换操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed&#x27;s/pattern/replacement/g&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会将 <code>file.txt</code> 中的 ‘pattern’ 替换为 ‘replacement’。这里的 <code>g</code> 表示全局替换，如果去掉 <code>g</code>，只会替换每一行的第一个匹配。</p>
<p><code>sed</code> 的 <code>-i</code> 选项是 <code>sed</code> 命令中的一个非常重要的选项，用于直接修改文件。在没有 <code>-i</code> 选项的情况下，<code>sed</code> 命令会将修改后的结果输出到标准输出（通常是终端或其他命令），原文件保持不变。如果你添加了 <code>-i</code> 选项，<code>sed</code> 将直接修改文件。</p>
<p>例如，下面的命令会将 <code>file.txt</code> 中的 ‘pattern’ 替换为 ‘replacement’，并且直接修改 <code>file.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i&#x27;s/pattern/replacement/g&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>在使用 <code>-i</code> 选项时，你可以提供一个扩展名，<code>sed</code> 会创建一个带有该扩展名的备份文件。例如，下面的命令会将 <code>file.txt</code> 中的 ‘pattern’ 替换为 ‘replacement’，并且创建一个名为 <code>file.txt.bak</code> 的备份文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i.bak&#x27;s/pattern/replacement/g&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>这在你想保留原始文件的情况下非常有用。</p>
<p>同样，你可以用 <code>-i</code> 选项与 <code>find</code> 命令结合，批量修改多个文件。例如，下面的命令会在当前目录及其子目录中的所有 <code>.txt</code> 文件中，将 ‘pattern’ 替换为 ‘replacement’：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.txt&quot; -exec sed -i&#x27;s/pattern/replacement/g&#x27; &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>&#123;&#125;</code> 是 <code>find</code> 找到的每个文件的占位符，<code>\;</code> 表示 <code>-exec</code> 选项的结束。</p>
<h3 id="使用-awk-进行更复杂的处理"><a href="#使用-awk-进行更复杂的处理" class="headerlink" title="使用 awk 进行更复杂的处理"></a>使用 <code>awk</code> 进行更复杂的处理</h3><p><code>awk</code> 是一个强大的文本处理工具，它可以对输入的每一行进行更复杂的处理。例如，下面的命令会打印 <code>file.txt</code> 中包含 ‘pattern’ 的行的第一列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/pattern/ &#123;print $1&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>在 <code>awk</code> 命令中，<code>&#123;print $1&#125;</code> 的含义是：对于每一行，打印第一列的内容。</p>
<p>在 <code>awk</code> 中，<code>$0</code> 表示整行的内容，<code>$1</code> 表示第一列的内容，<code>$2</code> 表示第二列的内容，以此类推。列的默认分隔符是空格或者制表符，但你可以使用 <code>-F</code> 选项指定其他的分隔符。</p>
<p>所以，<code>awk &#39;/pattern/ &#123;print $1&#125;&#39; file.txt</code> 这个命令的意思是：对 <code>file.txt</code> 的每一行，如果这一行包含 ‘pattern’，就打印这一行的第一列。例如，如果 <code>file.txt</code> 的内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apple fruit</span><br><span class="line">banana food</span><br><span class="line">cherry delicious</span><br></pre></td></tr></table></figure>

<p>那么 <code>awk &#39;/fruit/ &#123;print $1&#125;&#39; file.txt</code> 会输出 <code>apple</code>，因为 ‘fruit’ 是 <code>apple</code> 这一行的第二列。</p>
<p><code>print</code> 是 <code>awk</code> 的一个内建函数。它用于输出文本。在 <code>awk</code> 脚本中，<code>print</code> 通常被用来显示处理过的数据。</p>
<p>例如，在 <code>awk &#39;&#123;print $1&#125;&#39; file.txt</code> 这个命令中，<code>&#123;print $1&#125;</code> 是一个 <code>awk</code> 动作。这个动作告诉 <code>awk</code> 对每一行执行 <code>print $1</code> 操作，也就是打印每一行的第一列。</p>
<p><code>awk</code> 还有许多其他的内建函数，例如 <code>length</code>（返回字符串的长度）、<code>sub</code>（在字符串中进行替换）、<code>split</code>（将字符串分割成数组）等。你可以使用这些函数进行复杂的文本处理。</p>
<h3 id="使用-find-搜索文件"><a href="#使用-find-搜索文件" class="headerlink" title="使用 find 搜索文件"></a>使用 <code>find</code> 搜索文件</h3><p><code>find</code> 是一个在目录中搜索文件的工具。例如，下面的命令会在当前目录及其子目录中搜索所有 <code>.txt</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>



<h3 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h3><p>你可以使用管道符（<code>|</code>）将这些命令组合起来，实现更复杂的操作。例如，下面的命令会在当前目录及其子目录中的所有 <code>.txt</code> 文件中搜索 ‘pattern’，然后将 ‘pattern’ 替换为 ‘replacement’：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.txt&quot; -exec grep -l &#x27;pattern&#x27; &#123;&#125; \; | xargs sed -i&#x27;s/pattern/replacement/g&#x27;</span><br></pre></td></tr></table></figure>

<p>这个命令首先使用 <code>find</code> 和 <code>grep</code> 找到包含 ‘pattern’ 的文件，然后使用 <code>xargs</code> 和 <code>sed</code> 将这些文件中的 ‘pattern’ 替换为 ‘replacement’。</p>
<p>这些只是 Linux 命令行工具的基本用法，通过灵活地组合这些工具，你可以实现几乎所有的文本处理任务。</p>
<h2 id="2-17-权限与所有权管理"><a href="#2-17-权限与所有权管理" class="headerlink" title="2.17. 权限与所有权管理"></a>2.17. 权限与所有权管理</h2><p>在 Unix-like 操作系统中，每个文件和目录都有一组权限与所有权，这些权限由三个主体（所有者、用户组和其他用户）以及三种权限（读、写和执行）构成。每个文件或目录都有一个所有者和一个所属的用户组。所有者、用户组和其他用户的权限可以被分别设置，允许的操作分别为读（r）、写（w）和执行（x）。这些权限可以被表示为数字：</p>
<ul>
<li>读取权限（r）：4</li>
<li>写入权限（w）：2</li>
<li>执行权限（x）：1</li>
<li>无任何权限：0</li>
</ul>
<p>可以使用 <code>ls -l</code> 命令查看文件或目录的所有者、所属用户组和权限，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l myfile.txt</span><br></pre></td></tr></table></figure>

<p>返回的结果可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 user group 0 Jul 18 08:30 myfile.txt</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>user</code> 是所有者，<code>group</code> 是所属用户组，而 <code>-rw-r--r--</code> 是权限的表达式。在权限表达式中，第一位 <code>-</code> 表示这是一个文件（如果是 <code>d</code> 则表示这是一个目录），之后的九个字符三个一组（<code>rwx</code>）分别表示所有者、用户组和其他用户的权限。</p>
<p><code>chmod</code> 命令可以用来更改文件或目录的权限。例如，命令 <code>chmod u+x myfile.txt</code> 会给文件的所有者添加执行权限。权限也可以用三个数字表示，如 <code>chmod 755 myfile.txt</code> 将设置文件所有者的权限为读、写、执行，而所属的用户组和其他用户的权限则被设置为读、执行。</p>
<p><code>chown</code> 和 <code>chgrp</code> 命令可以用来更改文件或目录的所有者和所属的用户组。例如，<code>chown newuser myfile.txt</code> 和 <code>chgrp newgroup myfile.txt</code>。</p>
<p>具体使用场景中，<code>chmod</code> 命令的实用性是非常广泛的：</p>
<ol>
<li><strong>设置脚本为可执行</strong>：如 <code>chmod +x script.sh</code> 会给 <code>script.sh</code> 文件添加可执行权限。</li>
<li><strong>限制对敏感文件的访问</strong>：如 <code>chmod 600 secret.txt</code> 会设置 <code>secret.txt</code> 文件的权限，使得只有文件所有者可以进行读写操作。</li>
<li><strong>处理 Samba 权限问题</strong>：如 <code>chmod -x file.txt</code> 将去除 <code>file.txt</code> 文件的所有可执行权限。</li>
</ol>
<p>以上是 Unix-like 操作系统中文件和目录的权限与所有权管理的基本知识。我们可以通过理解和运用这些知识，有效地控制在系统中的文件和目录的访问权限，提高系统的安全性。</p>
<h2 id="2-18-进程管理和系统监控"><a href="#2-18-进程管理和系统监控" class="headerlink" title="2.18. 进程管理和系统监控"></a>2.18. 进程管理和系统监控</h2><p>在 Unix 和 Linux 系统中，进程管理和系统监控是非常重要的。以下是一些常用的命令和操作：</p>
<h3 id="2-18-1-查看进程"><a href="#2-18-1-查看进程" class="headerlink" title="2.18.1. 查看进程"></a>2.18.1. 查看进程</h3><p><code>top</code> 命令可以显示系统中的进程和它们的状态。使用 <code>top</code> 可以查看哪些进程在使用 CPU 或内存。<code>htop</code> 是 <code>top</code> 的一个增强版本，它提供了一个颜色的界面，并且可以直接用键盘进行交互。</p>
<h3 id="2-18-2-结束进程"><a href="#2-18-2-结束进程" class="headerlink" title="2.18.2. 结束进程"></a>2.18.2. 结束进程</h3><p>如果你需要结束一个进程，你可以使用 <code>kill</code> 命令。例如，<code>kill 12345</code> 将结束 PID 为 12345 的进程。</p>
<p><code>kill</code> 的 <code>-9</code> 选项是 <code>kill</code> 命令中的一种信号。在 Linux 中，每个信号都有一个名字和一个对应的数字。<code>-9</code> 对应的信号名字是 <code>SIGKILL</code>。当 <code>kill</code> 命令发送 <code>SIGKILL</code> 信号给一个进程时，它会立即结束该进程，进程没有机会进行任何清理操作。</p>
<p>如果你需要结束一个进程，并且该进程不响应正常的结束信号（例如 <code>SIGTERM</code>，对应的数字是 <code>-15</code>），你可以使用 <code>-9</code> 选项。例如，<code>kill -9 12345</code> 会立即结束 PID 为 12345 的进程。注意，虽然 <code>-9</code> 选项可以立即结束进程，但它也可能会导致数据丢失或其他问题，因为进程没有机会进行清理操作。因此，你应该尽量避免使用 <code>-9</code> 选项，除非你没有其他选择。</p>
<p><code>find</code> 和 <code>grep</code> 是两个非常强大的命令，你可以用它们来查找文件和过滤输出。如果你想要查找并结束一个特定的进程，你可以这样做：</p>
<ol>
<li>使用 <code>ps</code> 命令列出所有进程。</li>
<li>使用 <code>grep</code> 命令过滤出你想要结束的进程。</li>
<li>使用 <code>awk</code> 命令提取出进程的 PID。</li>
<li>使用 <code>kill</code> 命令结束该进程。</li>
</ol>
<p>例如，如果你想要结束所有名为 firefox 的进程，你可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $(ps aux | grep firefox | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p>这个命令的意思是：</p>
<ol>
<li><code>ps aux</code>：列出所有进程。</li>
<li><code>grep firefox</code>：过滤出名为 firefox 的进程。</li>
<li><code>grep -v grep</code>：删除包含 <code>grep</code> 的行，因为我们不想要结束 <code>grep</code> 命令自身。</li>
<li><code>awk &#39;&#123;print $2&#125;&#39;</code>：提取出第二列，即 PID。</li>
<li><code>kill -9</code>：结束这些进程。</li>
</ol>
<p>你也可以使用 <code>killall</code> 命令结束所有名字相同的进程，例如，<code>killall firefox</code> 会结束所有名为 firefox 的进程。</p>
<p><code>kill</code> 和 <code>killall</code> 这两个命令都可以添加 <code>-9</code> 选项（或其他的信号选项）来发送特定的信号。</p>
<h3 id="2-18-3-查看进程状态"><a href="#2-18-3-查看进程状态" class="headerlink" title="2.18.3. 查看进程状态"></a>2.18.3. 查看进程状态</h3><p><code>ps</code> 命令是一个非常强大的工具，可以查看和控制系统中运行的进程。<code>ps aux</code> 会显示所有的进程，并包括各种详细信息，如 PID、CPU 使用率、内存使用率、所属用户等。但是，当进程数量较多时，直接运行 <code>ps aux</code> 可能会返回过多的结果，这时就需要依赖其他工具，如 <code>grep</code>，来过滤和搜索具体的进程。</p>
<p><code>grep</code> 是一个用于文本搜索的命令行工具，它可以从输入中筛选出包含（或不包含）特定模式的行。当与 <code>ps</code> 命令结合使用时，你可以快速定位特定的进程。</p>
<p>例如，如果你想要查找所有名为 firefox 的进程，你可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep firefox</span><br></pre></td></tr></table></figure>

<p>这个命令会列出所有名为 firefox 的进程。<code>|</code> 是一个管道符，它会把 <code>ps aux</code> 的输出作为 <code>grep firefox</code> 的输入。因此，最后的结果只会包含名为 firefox 的进程。</p>
<p>有时，你会发现 <code>grep</code> 命令自身也出现在了结果中。如果你想要排除 <code>grep</code> 命令，你可以再加一个 <code>grep</code> 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep firefox | grep -v grep</span><br></pre></td></tr></table></figure>

<p>这个命令会排除所有包含 <code>grep</code> 的行。</p>
<p><code>ps</code> 和 <code>grep</code> 的结合应用非常广泛，常常用于系统监控、故障排查等场景。另外，<code>ps</code> 命令还可以与其他命令结合使用，例如 <code>awk</code>（用于文本处理）、<code>sort</code>（用于排序输出结果）等，可以实现更复杂的操作。</p>
<h3 id="2-18-4-查看-proc-中的信息"><a href="#2-18-4-查看-proc-中的信息" class="headerlink" title="2.18.4. 查看 /proc 中的信息"></a>2.18.4. 查看 /proc 中的信息</h3><p><code>/proc</code> 是一个虚拟的文件系统，它包含了关于系统和进程的信息。例如，<code>/proc/cpuinfo</code> 包含了关于 CPU 的信息，<code>/proc/meminfo</code> 包含了关于内存的信息，<code>/proc/PID</code> 包含了关于 PID 进程的信息。</p>
<p>确实，<code>/proc</code> 文件系统是一个具有大量信息的宝库，包含了关于系统和正在运行的进程的许多详细信息。你可以使用 <code>cat</code> 命令来查看这些文件的内容。</p>
<h4 id="查看-CPU-信息"><a href="#查看-CPU-信息" class="headerlink" title="查看 CPU 信息"></a>查看 CPU 信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<p>这将显示关于系统 CPU 的详细信息，例如型号，厂商，核数等。</p>
<h4 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure>

<p>这将显示关于系统内存的详细信息，例如总内存，可用内存，缓冲区大小等。</p>
<h4 id="查看特定进程的信息"><a href="#查看特定进程的信息" class="headerlink" title="查看特定进程的信息"></a>查看特定进程的信息</h4><p>每一个正在运行的进程都有一个与其 PID 对应的目录在 <code>/proc</code> 下。例如，如果你有一个 PID 为 1234 的进程，你可以使用以下命令查看其状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/1234/status</span><br></pre></td></tr></table></figure>

<p>这将显示关于该进程的各种信息，如其状态（Sleeping，Running 等），内存占用等。</p>
<p>对于查看进程的内存占用以分析是否存在内存泄露，你可以查看 <code>/proc/PID/smaps</code> 或 <code>/proc/PID/status</code> 文件。</p>
<p><code>/proc/PID/smaps</code> 提供了进程使用的每个内存区域的详细信息，包括大小，位置，权限等。你可以通过汇总这些区域的大小来获取进程的总内存使用量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/1234/smaps</span><br></pre></td></tr></table></figure>

<p><code>/proc/PID/status</code> 文件中的 <code>VmRSS</code> 和 <code>VmSize</code> 字段也提供了有关进程内存使用的信息。<code>VmRSS</code> 是进程正在使用的物理内存量，<code>VmSize</code> 是进程虚拟内存大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/1234/status</span><br></pre></td></tr></table></figure>

<p>如果你观察到这些值随着时间的推移持续增长，可能就存在内存泄漏的问题。</p>
<p>请注意，分析内存泄漏通常需要结合其他工具和技术，例如 <code>valgrind</code>，<code>gdb</code>，或者专门的内存分析器。</p>
<h3 id="2-18-5-查看网络参数"><a href="#2-18-5-查看网络参数" class="headerlink" title="2.18.5. 查看网络参数"></a>2.18.5. 查看网络参数</h3><h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><p><code>traceroute</code> 命令用于显示数据包从你的机器到达目标机器所经过的所有路由。这对于诊断网络问题非常有用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.baidu.com</span><br></pre></td></tr></table></figure>



<h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p><code>ping</code> 命令用于测试你的机器和目标机器之间的网络连接。如果你能成功地 “ping” 到一个机器，那么你的机器就能和那台机器通信：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>



<h4 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h4><p><code>nslookup</code> 命令用于查询 DNS 记录。这可以帮助你查看域名的 IP 地址，以及其他 DNS 记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup www.baidu.com</span><br></pre></td></tr></table></figure>



<h4 id="ifconfig-和-ip"><a href="#ifconfig-和-ip" class="headerlink" title="ifconfig 和 ip"></a>ifconfig 和 ip</h4><p><code>ifconfig</code> 和 <code>ip</code> 命令用于查看和配置网络接口。你可以使用这些命令来查看你的网络配置，或者更改你的 IP 地址或路由表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">ip addr</span><br></pre></td></tr></table></figure>



<h4 id="netstat-和-ss"><a href="#netstat-和-ss" class="headerlink" title="netstat 和 ss"></a>netstat 和 ss</h4><p><code>netstat</code> 和 <code>ss</code>，能够显示网络连接，路由表，接口状态等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -tuln</span><br><span class="line">ss -t</span><br></pre></td></tr></table></figure>

<p>以上的命令都是网络诊断工具中的基础，但是也有许多其他的工具和技术可以用于更复杂的网络问题的诊断。例如，<code>tcpdump</code> 和 <code>wireshark</code> 可以用于捕获和分析网络流量，<code>nmap</code> 可以用于网络扫描和安全审计，<code>curl</code> 和 <code>wget</code> 可以用于从 web 服务器下载文件，等等。</p>
<h2 id="2-19-键盘快捷和命令"><a href="#2-19-键盘快捷和命令" class="headerlink" title="2.19. 键盘快捷和命令"></a>2.19. 键盘快捷和命令</h2><p>在 Ubuntu 的命令行中，有很多键盘快捷键和命令可以提高程序员的效率。以下是一些实用的操作技巧：</p>
<p><strong>自动完成（Tab 键）</strong>：在输入命令或文件名的时候，可以按 <code>Tab</code> 键自动补全。如果有多个选项，按两次 <code>Tab</code> 键将列出所有匹配的选项。</p>
<p><strong>历史命令（上 / 下方向键）</strong>：在命令行中，你可以使用上 / 下方向键来浏览你之前输入过的命令。按上方向键可以回到更早之前的命令，按下方向键可以回到更近的命令。</p>
<p><strong>命令行中的光标移动（左 / 右方向键）</strong>：左 / 右方向键可以在当前命令行中移动光标，这样你可以编辑命令行中的任何部分。</p>
<p><strong>历史命令（history）</strong>：<code>history</code> 命令可以显示你之前输入过的所有命令。这样你可以找到并重新执行之前的命令，而不是手动输入。</p>
<p><strong>搜索历史命令（Ctrl+R）</strong>：按下 <code>Ctrl+R</code>，然后开始输入，你会看到一个提示符，显示你正在搜索历史命令。这是一个增量搜索，也就是说，随着你的输入，系统会显示匹配的历史命令。在执行 <code>Ctrl+R</code> 输入关键词进行搜索后，可以使用上 / 下方向键在匹配的历史命令之间进行切换。</p>
<p><strong>跳转到行首（Ctrl+A）和行尾（Ctrl+E）</strong>：在命令行中，你可以使用 <code>Ctrl+A</code> 快速跳到当前行的开头，或者使用 <code>Ctrl+E</code> 快速跳到当前行的末尾。</p>
<p><strong>单词跳跃（Ctrl + 左方向键 / 右方向键）</strong>：按下 <code>Ctrl</code> 键的同时按左方向键或右方向键，可以一次跳过一个单词，而不是一个字符。</p>
<p><strong>删除单词（Ctrl+W）</strong>：按下 <code>Ctrl+W</code> 会删除光标左边的一个单词。</p>
<p><strong>清空命令行（Ctrl+L）</strong>：这个快捷键可以帮助你清空命令行界面，类似于输入 <code>clear</code> 命令。</p>
<p><strong>中止当前命令（Ctrl+C）</strong>：这个快捷键可以帮助你中止当前正在运行的命令。</p>
<p><strong>将命令放入后台运行（Ctrl+Z）</strong>：这个快捷键可以将当前正在运行的命令放入后台。你可以使用 <code>fg</code> 命令将其恢复到前台。</p>
<p><strong>复制和粘贴（Ctrl+Shift+C 和 Ctrl+Shift+V）</strong>：在命令行中，你不能直接使用 <code>Ctrl+C</code> 和 <code>Ctrl+V</code> 来复制和粘贴，因为这两个快捷键已经被其他功能占用。但你可以使用 <code>Ctrl+Shift+C</code> 来复制，使用 <code>Ctrl+Shift+V</code> 来粘贴。</p>
<p><strong>切换命令行标签页（Ctrl+PgUp 和 Ctrl+PgDn）</strong>：如果你在使用带标签页的命令行界面（例如 GNOME Terminal），你可以使用 <code>Ctrl+PgUp</code> 和 <code>Ctrl+PgDn</code> 在标签页之间切换。</p>
<p><strong>命令别名（alias）</strong>：如果你有一些经常使用的长命令，你可以使用 <code>alias</code> 命令为它们创建别名。例如，你可以使用 <code>alias ll=&#39;ls -lh&#39;</code> 创建一个 <code>ll</code> 的别名，这样每次输入 <code>ll</code> 都相当于输入 <code>ls -lh</code>。</p>
<p>以上只是一部分实用的命令行技巧，还有许多其他的技巧和快捷键可以帮助你提高效率。你可以尝试在网上搜索更多的信息，或者查看相关的文档和教程。</p>
<h2 id="2-20-包管理"><a href="#2-20-包管理" class="headerlink" title="2.20. 包管理"></a>2.20. 包管理</h2><p>Ubuntu 使用 <code>apt</code> 包管理器来处理软件包。以下是一些基本的 <code>apt</code> 命令：</p>
<ul>
<li><code>sudo apt update</code>：更新软件包列表。这应该是安装新软件之前执行的第一个命令。</li>
<li><code>sudo apt upgrade</code>：升级所有的软件包。这将更新所有已安装的软件包至最新版本。</li>
<li><code>sudo apt install</code>：安装一个新的软件包。例如，<code>sudo apt install firefox</code> 将安装 Firefox 浏览器。</li>
<li><code>sudo apt remove</code>：删除一个已安装的软件包。例如，<code>sudo apt remove firefox</code> 将卸载 Firefox 浏览器。</li>
<li><code>sudo apt search</code>：搜索软件包。例如，<code>sudo apt search firefox</code> 将显示所有与 Firefox 相关的软件包。</li>
</ul>
<p>如果你下载了一个 <code>.deb</code> 文件并希望通过命令行手动安装，你可以使用 <code>dpkg</code> 命令。以下是具体的操作：</p>
<ul>
<li><code>sudo dpkg -i package_file.deb</code>：安装一个 <code>.deb</code> 软件包。例如，<code>sudo dpkg -i firefox.deb</code> 将安装名为 <code>firefox.deb</code> 的软件包。</li>
</ul>
<p>这里的 <code>sudo</code> 命令是 “superuser do” 的缩写，它允许普通用户以超级用户（或称为 root 用户）的身份执行命令。由于安装和卸载软件包可能会影响系统的运行，所以需要超级用户的权限。当你在命令前添加 <code>sudo</code> 时，系统可能会提示你输入密码，以验证你有执行该命令的权限。</p>
<h2 id="2-21-其他"><a href="#2-21-其他" class="headerlink" title="2.21. 其他"></a>2.21. 其他</h2><h3 id="watch-命令"><a href="#watch-命令" class="headerlink" title="watch 命令"></a>watch 命令</h3><p><code>watch</code> 是一个非常有用的命令，它允许你周期性地执行命令并显示结果。这对于监视文件、系统状态或任何可以通过命令行查看的内容非常有用。</p>
<p>例如，你可以使用 <code>watch</code> 每两秒刷新一次 <code>ls</code> 命令的输出，以监视目录的变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 2 du -sh</span><br></pre></td></tr></table></figure>

<p>这将每两秒执行一次 <code>du -sh</code> 命令并显示其输出。</p>
<h3 id="time-命令"><a href="#time-命令" class="headerlink" title="time 命令"></a>time 命令</h3><p><code>time</code> 命令用于测量命令的执行时间。这对于性能测试非常有用。</p>
<p>例如，你可以使用 <code>time</code> 来测量 <code>make all</code> 命令的执行时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time make all</span><br></pre></td></tr></table></figure>

<p>这将显示 <code>make all</code> 命令的执行时间，包括用户态，内核态的 CPU 时间以及实际经过的墙钟时间。</p>
<p>这些工具提供了非常有用的功能，可以帮助你更好地理解和监控你的系统。和其他命令一样，你可以通过查看它们的手册页（例如，通过运行 <code>man watch</code> 或 <code>man time</code>）来学习更多关于它们的信息。</p>
<h2 id="2-22-查看帮助手册"><a href="#2-22-查看帮助手册" class="headerlink" title="2.22. 查看帮助手册"></a>2.22. 查看帮助手册</h2><p>在 Ubuntu Linux 中，你可以通过两种主要方式查看命令的帮助和手册：使用 <code>man</code> 命令或者使用 <code>--help</code> 或 <code>-h</code> 选项。</p>
<p><strong>man 命令</strong>：<code>man</code> 命令用于显示用户手册页，这些手册页包含了关于各种命令和程序的详细信息。要查看某个命令的手册页，只需在 <code>man</code> 后面跟上你想要查询的命令即可。例如，<code>man ls</code> 将显示 <code>ls</code> 命令的手册页。这个命令的结果通常会很详尽，包含了命令的描述、选项、使用示例等。</p>
<p><strong>–help 或 -h 选项</strong>：大多数的命令都支持 <code>--help</code> 或 <code>-h</code> 选项，这个选项可以显示命令的简短帮助信息。这个选项通常会列出命令的基本用法和所有可用的选项，但不会像 <code>man</code> 命令那样详尽。例如，<code>ls --help</code> 或 <code>ls -h</code> 将显示 <code>ls</code> 命令的帮助信息。</p>
<p>需要注意的是，不是所有的命令都支持 <code>--help</code> 或 <code>-h</code> 选项，而且即使支持，显示的信息也可能因命令而异。如果 <code>--help</code> 或 <code>-h</code> 选项无法提供足够的信息，那么你可以考虑使用 <code>man</code> 命令。</p>
<h1 id="3-编辑器的使用"><a href="#3-编辑器的使用" class="headerlink" title="3. 编辑器的使用"></a>3. 编辑器的使用</h1><h2 id="3-1-Vim-编辑器的介绍"><a href="#3-1-Vim-编辑器的介绍" class="headerlink" title="3.1. Vim 编辑器的介绍"></a>3.1. Vim 编辑器的介绍</h2><p>Vim 是一款由 Bram Moolenaar 开发的文本编辑器，它是 Unix 类操作系统下 vi 编辑器的克隆版本，但比 vi 更为强大。Vim 是全键盘操作的编辑器，可以实现对文本的高效编辑。</p>
<p>Vim 的功能强大，主要表现在以下几个方面：</p>
<ul>
<li>语法高亮：Vim 支持多种编程语言的语法高亮。</li>
<li>多重撤销：Vim 支持无限次的撤销操作。</li>
<li>分屏：Vim 可以打开多个文档，并进行分屏显示。</li>
<li>扩展性：Vim 的功能可以通过插件进行扩展，有丰富的插件可供选择。</li>
</ul>
<h2 id="3-2-Vim-的模式"><a href="#3-2-Vim-的模式" class="headerlink" title="3.2. Vim 的模式"></a>3.2. Vim 的模式</h2><p>Vim 有以下几种模式：</p>
<ul>
<li>一般模式（Normal Mode）：这是 Vim 打开后的默认模式，可以进行光标移动、复制、粘贴、搜索、替换等多种操作。</li>
<li>插入模式（Insert Mode）：在此模式下，可以插入文本。从一般模式按 <code>i</code> 键进入此模式，按 <code>ESC</code> 键回到一般模式。</li>
<li>命令模式（Command Mode）：在此模式下，可以输入命令行命令。从一般模式按 <code>:</code> 键进入此模式，按 <code>ESC</code> 键回到一般模式。</li>
<li>可视模式（Visual Mode）：在此模式下，可以对文本进行选中操作。从一般模式按 <code>v</code>（字符可视模式）、<code>V</code>（行可视模式）或 <code>Ctrl+v</code>（块可视模式）进入此模式，按 <code>ESC</code> 键回到一般模式。</li>
</ul>
<h2 id="3-3-Vim-的基本操作"><a href="#3-3-Vim-的基本操作" class="headerlink" title="3.3. Vim 的基本操作"></a>3.3. Vim 的基本操作</h2><p>以下是 Vim 的一些基本操作：</p>
<ul>
<li>光标移动：在一般模式下，<code>h</code>（左）、<code>j</code>（下）、<code>k</code>（上）、<code>l</code>（右）用于光标的基础移动。</li>
<li>插入文本：在一般模式下，<code>i</code> 进入插入模式，然后可以输入文本。在完成后，按 <code>ESC</code> 键回到一般模式。</li>
<li>保存文件：在命令模式下，输入 <code>:w</code> 可以保存文件。</li>
<li>退出 Vim：在命令模式下，输入 <code>:q</code> 可以退出 Vim。如果有未保存的修改，需要输入 <code>:q!</code> 强制退出。</li>
</ul>
<p>在 Vim 中，你可以快速地跳转到文件的任何一行。以下是具体的步骤：</p>
<ul>
<li>在命令模式（也就是一般模式）下，输入行数，然后按 <code>G</code> 键。例如，如果你想跳转到第 25 行，你应该输入 <code>25G</code>。</li>
<li>另一种方法是在命令行模式中使用 <code>:</code> 和行号。例如，如果你想跳转到第 25 行，你应该输入 <code>:25</code>。在输入完毕后，按 <code>Enter</code> 键即可。</li>
</ul>
<p>这两种方法都可以让你快速地在文件中跳转。</p>
<h2 id="3-4-Vim-的高级功能"><a href="#3-4-Vim-的高级功能" class="headerlink" title="3.4. Vim 的高级功能"></a>3.4. Vim 的高级功能</h2><p>以下是 Vim 的一些高级功能：</p>
<ul>
<li>搜索：在一般模式下，输入 <code>/</code> 后跟着要搜索的内容，然后按 <code>Enter</code> 键可以进行搜索。按 <code>n</code> 键跳转到下一个搜索结果，按 <code>N</code> 键跳转到上一个搜索结果。</li>
<li>替换：在命令模式下，输入 <code>:s/old/new/g</code> 可以替换当前行中的所有 “old” 为 “new”。如果要在整个文件中进行替换，可以使用 <code>:% s/old/new/g</code> 命令。</li>
<li>分屏：在命令模式下，输入 <code>:split</code> 或 <code>:vsplit</code> 可以进行水平分屏或垂直分屏。使用 <code>Ctrl+w</code> 键可以在各个分屏窗口中切换。</li>
<li>宏：Vim 支持宏录制和播放，可以批量处理复杂的文本操作。</li>
</ul>
<h2 id="3-5-Vim-的实际应用练习"><a href="#3-5-Vim-的实际应用练习" class="headerlink" title="3.5. Vim 的实际应用练习"></a>3.5. Vim 的实际应用练习</h2><p>Vim 是一款高度可配置的文本编辑器，用于有效地创建和更改任何类型的文本。 它被包含在大多数 UNIX 系统并且在许多其他地方有所应用。 在本章节中，我们将通过一些实际的练习来探索 Vim 编辑器的应用。</p>
<p><strong>练习 1：创建和保存文件</strong></p>
<p>让我们从创建和保存一个新文档开始。 在终端中，键入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim newfile.txt</span><br></pre></td></tr></table></figure>

<p>这将打开一个名为 “newfile.txt” 的新 Vim 窗口。 现在，键入 <code>i</code> 进入插入模式，在其中你可以输入文本。 输入一些文本，然后按 <code>ESC</code> 返回到命令模式。 在命令模式下，键入 <code>:wq</code> 或者按 <code>Shift + ZZ</code> 快捷键保存并退出 Vim。</p>
<p><strong>练习 2：导航文本</strong></p>
<p>Vim 有多种导航文档的方法。 在 Vim 中打开一个文档，然后试试下面的命令：</p>
<ul>
<li><code>gg</code> - 跳到文档的开始</li>
<li><code>G</code> - 跳到文档的结尾</li>
<li><code>0</code> - 跳到行的开头</li>
<li><code>$</code> - 跳到行的末尾</li>
<li><code>w</code> - 跳到下一个单词的开头</li>
<li><code>b</code> - 跳到上一个单词的开头</li>
</ul>
<p><strong>练习 3：编辑文本</strong></p>
<p>Vim 提供了许多强大的文本编辑功能，包括复制、粘贴和删除。 在 Vim 中打开一个文档，然后尝试以下命令：</p>
<ul>
<li><code>dd</code> - 删除当前行</li>
<li><code>yy</code> - 复制当前行</li>
<li><code>p</code> - 粘贴剪贴板中的内容到当前行之后</li>
<li><code>u</code> - 撤销上一次操作</li>
<li><code>Ctrl + r</code> - 重做上一次撤销的操作</li>
</ul>
<p><strong>练习 4：查找和替换</strong></p>
<p>Vim 的查找和替换功能非常实用。 在 Vim 中打开一个文档，然后尝试以下命令：</p>
<ul>
<li><code>/word</code> - 查找 “word”</li>
<li><code>n</code> - 跳到下一个匹配项</li>
<li><code>N</code> - 跳到上一个匹配项</li>
<li><code>:% s/old/new/g</code> - 全文替换 “old” 为 “new”</li>
</ul>
<p><strong>练习 5：使用 Vim 宏</strong></p>
<p>Vim 的宏是一种强大的自动化工具，可以记录和重播键入序列。 试试以下步骤：</p>
<ul>
<li>在命令模式下，键入 <code>qa</code> 开始记录宏 a</li>
<li>输入一系列的命令，例如 <code>iHello World&lt;Esc&gt;</code></li>
<li>键入 <code>q</code> 停止记录</li>
<li>键入 <code>@a</code> 运行宏 a</li>
</ul>
<h1 id="4-Bash-Shell-编程基础"><a href="#4-Bash-Shell-编程基础" class="headerlink" title="4. Bash Shell 编程基础"></a>4. Bash Shell 编程基础</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1. 介绍"></a>4.1. 介绍</h2><h3 id="Bash-Shell-是什么"><a href="#Bash-Shell-是什么" class="headerlink" title="Bash Shell 是什么"></a>Bash Shell 是什么</h3><p>Bash（Bourne Again Shell）是一个 Unix shell 和命令语言，由 Brian Fox 为 GNU 项目开发。它是 Bourne Shell (sh) 的扩展版，并提供了许多改善和新特性。Bash 是许多 Linux 发行版的默认 shell，并且也是 macOS 和 Windows 的 Subsystem for Linux（WSL）中可用的。</p>
<p>Shell 是一个用户与操作系统进行交互的界面。通过 shell，用户可以执行命令、运行脚本、操作文件系统等。Bash 作为一个 shell，提供了丰富的编程特性，如变量、数组、流程控制结构（如 if，for，while 等）和函数。</p>
<h3 id="Bash-Shell-的历史和应用"><a href="#Bash-Shell-的历史和应用" class="headerlink" title="Bash Shell 的历史和应用"></a>Bash Shell 的历史和应用</h3><p>Bash Shell 最初于 1989 年发布，作为自由软件基础构建块的一部分，它旨在完全兼容 “sh”（Bourne Shell），同时还引入了 C Shell（csh）和 Korn Shell（ksh）的许多有用特性。</p>
<p>由于其强大的特性和开源的本质，Bash 已经成为了许多系统管理员和开发人员的首选工具。它不仅用于日常的文件管理和系统管理任务，也用于编写复杂的脚本和自动化程序。</p>
<h2 id="4-2-Shell-变量"><a href="#4-2-Shell-变量" class="headerlink" title="4.2. Shell 变量"></a>4.2. Shell 变量</h2><h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><p>在 Bash shell 中，变量是用来存储和操作数据的名称。这些数据可能是字符串，数字，或者是其他命令的输出。变量的主要用途是提供一个方法来保存和操纵数据，以便在脚本或命令行中使用。</p>
<h3 id="如何声明和使用变量"><a href="#如何声明和使用变量" class="headerlink" title="如何声明和使用变量"></a>如何声明和使用变量</h3><p>在 Bash 中，你可以使用等号 <code>=</code> 来声明变量和赋值。例如，下面的命令声明了一个名为 <code>my_variable</code> 的变量，并将其值设置为 <code>Hello, world!</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_variable=&quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>

<p>请注意，变量名和等号之间不能有空格。</p>
<p>一旦你声明了一个变量，你就可以使用美元符号 <code>$</code> 来使用它。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $my_variable</span><br></pre></td></tr></table></figure>

<p>这会在终端中输出 <code>Hello, world!</code>。</p>
<h3 id="环境变量和局部变量"><a href="#环境变量和局部变量" class="headerlink" title="环境变量和局部变量"></a>环境变量和局部变量</h3><p>Bash 中有两种主要类型的变量：环境变量和局部变量。</p>
<p>局部变量只在它们被声明的 shell 会话中可用。如果你在一个终端窗口中声明了一个变量，然后打开了一个新的终端窗口，那么新的终端窗口将无法访问那个变量。</p>
<p>环境变量，另一方面，是在所有的 shell 会话中都可用的。你可以使用 <code>export</code> 命令来创建环境变量。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export my_variable=&quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>

<p>一旦你这样做，<code>my_variable</code> 将在所有的子 shell 会话中都可用。</p>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><p>Bash 还定义了一些特殊的变量，这些变量在 shell 中有特定的用途。以下是一些最常用的特殊变量：</p>
<ul>
<li><code>$HOME</code>：当前用户的主目录的路径。</li>
<li><code>$PATH</code>：用于查找命令的目录列表。</li>
<li><code>$PS1</code>：默认的命令提示符。</li>
<li><code>$USER</code>：当前用户的用户名。</li>
<li><code>$?</code>：最后执行的命令的退出状态。如果命令成功执行，该值为 0，否则为非零值。</li>
<li><code>$$</code>：当前 shell 进程的 PID。</li>
<li><code>$#</code>：传递给脚本或函数的参数个数。</li>
<li><code>$*</code> 和 <code>$@</code>：传递给脚本或函数的所有参数。</li>
</ul>
<p>这些特殊变量为你在 Bash 中编写脚本和处理数据提供了强大的工具。</p>
<h2 id="4-3-Shell-脚本"><a href="#4-3-Shell-脚本" class="headerlink" title="4.3. Shell 脚本"></a>4.3. Shell 脚本</h2><h3 id="什么是-Shell-脚本"><a href="#什么是-Shell-脚本" class="headerlink" title="什么是 Shell 脚本"></a>什么是 Shell 脚本</h3><p>Shell 脚本是一个包含了一系列命令的文本文件，当这个脚本被执行时，这些命令会按照它们在脚本中出现的顺序被执行。Shell 脚本可以帮助我们自动化一些日常的任务，例如文件管理、程序运行等。</p>
<h3 id="如何创建和运行-Shell-脚本"><a href="#如何创建和运行-Shell-脚本" class="headerlink" title="如何创建和运行 Shell 脚本"></a>如何创建和运行 Shell 脚本</h3><p>创建一个 Shell 脚本其实就是创建一个文本文件，并在文件中写入你想要执行的命令。例如，你可以创建一个名为 <code>my_script.sh</code> 的文件，并在其中写入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>

<p>在这个脚本中，<code>#!/bin/bash</code> 是一个特殊的指示符，称为 shebang，它告诉系统这个脚本应该用哪个解释器来执行，这里是 <code>/bin/bash</code>。接下来的命令 <code>echo&quot;Hello, world!&quot;</code>将会在脚本被执行时输出”Hello, world!”。</p>
<p>你可以通过以下命令来运行这个脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash my_script.sh</span><br></pre></td></tr></table></figure>

<p>或者，你可以先给这个脚本添加执行权限，然后直接运行它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x my_script.sh</span><br><span class="line">./my_script.sh</span><br></pre></td></tr></table></figure>



<h3 id="Shell-脚本的结构和语法"><a href="#Shell-脚本的结构和语法" class="headerlink" title="Shell 脚本的结构和语法"></a>Shell 脚本的结构和语法</h3><p>一个典型的 Shell 脚本包含了以下元素：</p>
<ul>
<li>Shebang：这是脚本的第一行，它指定了执行这个脚本的解释器。对于 Bash 脚本，这通常是 <code>#!/bin/bash</code>。</li>
<li>命令：这些是你想要自动执行的命令。它们按照在脚本中出现的顺序执行。</li>
<li>注释：以 <code>#</code> 开始的行是注释，它们不会被执行。你可以使用注释来解释脚本的功能或者说明某个命令的作用。</li>
<li>变量：你可以在脚本中定义变量来保存和操作数据。</li>
<li>控制结构：例如 <code>if</code>、<code>for</code>、<code>while</code>。这些可以让你的脚本根据条件执行不同的命令，或者重复执行某些命令。</li>
</ul>
<p>以下是一个更复杂的脚本的例子，它使用了变量和 <code>if</code> 控制结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">name=$1</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$name&quot; ]; then</span><br><span class="line">  echo &quot;Hello, world!&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;Hello, $name!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>这个脚本接受一个参数，并将其值赋给 <code>name</code> 变量。然后，它使用 <code>if</code> 语句检查 <code>name</code> 是否为空。如果 <code>name</code> 为空，它会输出 “Hello, world!”，否则，它会输出 “Hello, $name!”。</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>你可以在执行脚本时传递参数，这些参数在脚本中可以通过 <code>$1</code>、<code>$2</code>、<code>$3</code> 等变量来访问，其中 <code>$1</code> 对应第一个参数，<code>$2</code> 对应第二个参数，以此类推。例如，如果你执行 <code>bash my_script.sh Alice</code>，那么在 <code>my_script.sh</code> 脚本中，<code>$1</code> 的值就会是 “Alice”。</p>
<p>另外，你也可以使用 <code>$@</code> 或者 <code>$*</code> 来获取所有的参数，而 <code>$#</code> 可以获取参数的个数。</p>
<h2 id="4-4-流程控制"><a href="#4-4-流程控制" class="headerlink" title="4.4. 流程控制"></a>4.4. 流程控制</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>在 Shell 脚本中，我们可以使用 <code>if</code>、<code>else</code> 和 <code>case</code> 来进行条件判断。</p>
<p>-<strong>if/else</strong>语句</p>
<p><code>if</code> 语句用于根据条件执行不同的代码块。基本的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ condition ]; then</span><br><span class="line">    # commands to execute if condition is true</span><br><span class="line">else</span><br><span class="line">    # commands to execute if condition is false</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ $1 -gt 100 ]; then</span><br><span class="line">    echo &quot;The number is larger than 100.&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;The number is 100 or less.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>-<strong>case</strong>语句</p>
<p><code>case</code> 语句用于根据值的不同执行不同的代码块。基本的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case value in</span><br><span class="line">    pattern1)</span><br><span class="line">        # commands to execute if value matches pattern1</span><br><span class="line">        ;;</span><br><span class="line">    pattern2)</span><br><span class="line">        # commands to execute if value matches pattern2</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        # commands to execute if value doesn&#x27;t match any pattern</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case $1 in</span><br><span class="line">    start)</span><br><span class="line">        echo &quot;Starting...&quot;</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        echo &quot;Stopping...&quot;</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;Unknown command: $1&quot;</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<h3 id="循环语句（for-while-until）"><a href="#循环语句（for-while-until）" class="headerlink" title="循环语句（for, while, until）"></a>循环语句（for, while, until）</h3><p>在 Shell 脚本中，我们可以使用 <code>for</code>、<code>while</code> 和 <code>until</code> 来进行循环。</p>
<p>-<strong>for</strong>循环</p>
<p>``for` 循环用于重复执行一段代码。基本的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for var in list; do</span><br><span class="line">    # commands to execute</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in 1 2 3; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>-<strong>while</strong>循环</p>
<p>``while` 循环用于当条件为真时重复执行一段代码。基本的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while [ condition ]; do</span><br><span class="line">    # commands to execute</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line">while [ $i -le 3 ]; do</span><br><span class="line">    echo $i</span><br><span class="line">    i=$((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>-<strong>until</strong>循环</p>
<p>``until` 循环用于当条件为假时重复执行一段代码。基本的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">until [ condition ]; do</span><br><span class="line">    # commands to execute</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line">until [ $i -gt 3 ]; do</span><br><span class="line">    echo $i</span><br><span class="line">    i=$((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>这些流程控制结构为我们在 Shell 脚本中编写复杂的逻辑提供了强大的工具。</p>
<h2 id="4-5-函数"><a href="#4-5-函数" class="headerlink" title="4.5. 函数"></a>4.5. 函数</h2><h3 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h3><p>在 Shell 脚本中，函数是一段可被重复使用的代码块。你可以在脚本的任何地方声明一个函数，并在需要的地方调用它。函数可以帮助你组织和重用代码，使你的脚本更简洁、更易于理解和维护。</p>
<h3 id="如何声明和调用函数"><a href="#如何声明和调用函数" class="headerlink" title="如何声明和调用函数"></a>如何声明和调用函数</h3><p>在 Shell 脚本中，你可以使用 <code>function</code> 关键字或者直接使用函数名来声明函数。函数的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function_name () &#123;</span><br><span class="line">  # commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function function_name &#123;</span><br><span class="line">  # commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以通过函数名来调用函数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function_name</span><br></pre></td></tr></table></figure>

<p>以下是一个简单的函数示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greet () &#123;</span><br><span class="line">  echo &quot;Hello, $1!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet &quot;world&quot;  # 输出 &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>greet</code> 是一个接受一个参数的函数，它会输出 “Hello, $1!”，其中 <code>$1</code> 是函数的第一个参数。</p>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>在函数中，你可以使用 <code>return</code> 语句来指定函数的返回值，但是这个值只能是一个介于 0 到 255 的整数。如果你不指定返回值，函数将返回最后一个命令的退出状态。</p>
<p>你可以使用 <code>$?</code> 变量来获取上一个命令或函数的返回值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_func () &#123;</span><br><span class="line">  return 42</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_func</span><br><span class="line">echo $?  # 输出 &quot;42&quot;</span><br></pre></td></tr></table></figure>

<p>如果你想返回一个字符串或其他类型的值，你可以通过 <code>echo</code> 或 <code>printf</code> 命令将值输出到标准输出，然后在调用函数时使用命令替换的方式来获取这个值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_func () &#123;</span><br><span class="line">  echo &quot;Hello, $1!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greeting=$(my_func &quot;world&quot;)</span><br><span class="line">echo $greeting  # 输出 &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>



<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>递归函数是一种在其定义中调用自身的函数。在 Shell 脚本中，你可以创建递归函数，但是请注意控制递归的深度，避免出现无限递归的情况。</p>
<p>以下是一个计算阶乘的递归函数的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">factorial () &#123;</span><br><span class="line">  if [ $1 -eq 0 ]; then</span><br><span class="line">    echo 1</span><br><span class="line">  else</span><br><span class="line">    last_factorial=$(factorial $(( $1 - 1 )))</span><br><span class="line">    echo $(( $1 * last_factorial ))</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo $(factorial 5)  # 输出 &quot;120&quot;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>factorial</code> 函数接受一个参数，如果这个参数等于 0，它就返回 1，否则，它就调用自身来计算 <code>($1 - 1)</code> 的阶乘，然后将这个值乘以 <code>$1</code>。</p>
<h2 id="4-6-用户输入和输出"><a href="#4-6-用户输入和输出" class="headerlink" title="4.6. 用户输入和输出"></a>4.6. 用户输入和输出</h2><p>在 Shell 脚本中，处理用户输入和输出是非常重要的。我们可以通过几种不同的方式来读取用户的输入，打印输出到终端，或者将输出重定向到文件或其他命令。</p>
<h3 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h3><p>在 Shell 脚本中，我们可以使用 <code>read</code> 命令来读取用户的输入。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;What is your name?&quot;</span><br><span class="line">read name</span><br><span class="line">echo &quot;Hello, $name!&quot;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>read</code> 命令会等待用户输入，然后将输入的值赋给变量 <code>name</code>。</p>
<h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><p>在 Shell 脚本中，我们一般使用 <code>echo</code> 或 <code>printf</code> 命令来打印输出到终端。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;John Doe&quot;</span><br><span class="line">echo &quot;Hello, $name!&quot;</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>echo</code> 命令会打印出 “Hello, John Doe!”。</p>
<h3 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h3><p>在 Shell 中，我们可以使用重定向操作符 <code>&gt;</code> 和 <code>&gt;&gt;</code> 来将输出重定向到文件。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello, world!&quot; &gt; myfile.txt</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>echo</code> 命令的输出 “Hello, world!” 会被写入到 <code>myfile.txt</code> 文件中。如果文件已经存在，<code>&gt;</code> 操作符会覆盖文件的内容。如果我们想要将内容追加到文件的末尾，可以使用 <code>&gt;&gt;</code> 操作符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello again, world!&quot; &gt;&gt; myfile.txt</span><br></pre></td></tr></table></figure>



<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>在 Shell 中，我们可以使用管道 <code>|</code> 操作符将一个命令的输出作为另一个命令的输入。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | grep &quot;.txt&quot;</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>ls</code> 命令会列出当前目录下的所有文件，然后这个列表会被传递给 <code>grep</code> 命令，<code>grep</code> 命令会从这个列表中筛选出所有包含 “.txt” 的行。这样我们就可以找出当前目录下的所有 txt 文件。</p>
<h2 id="4-7-错误处理和调试"><a href="#4-7-错误处理和调试" class="headerlink" title="4.7. 错误处理和调试"></a>4.7. 错误处理和调试</h2><p>在编写和运行 Shell 脚本时，错误处理和调试是必不可少的环节。在不同的情况下，我们可以使用不同的技术来寻找和解决问题。</p>
<h3 id="4-7-1-错误处理"><a href="#4-7-1-错误处理" class="headerlink" title="4.7.1. 错误处理"></a>4.7.1. 错误处理</h3><p>在 Shell 脚本中，我们可以使用特殊变量 <code>$?</code> 来获取上一个命令的退出状态。如果命令成功执行，退出状态为 0，否则为非零值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls /nonexistentdirectory</span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">    echo &quot;An error occurred.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果 <code>ls</code> 命令因为目录不存在而失败，我们会打印出一条错误信息。</p>
<p>另外，我们可以使用 <code>set -e</code> 命令让脚本在任何命令失败时立即退出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set -e</span><br><span class="line">ls /nonexistentdirectory</span><br><span class="line">echo &quot;This will not be printed.&quot;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ls</code> 命令会失败，然后脚本立即退出，所以 “This will not be printed.” 永远不会被打印出来。</p>
<h3 id="4-7-2-脚本调试"><a href="#4-7-2-脚本调试" class="headerlink" title="4.7.2. 脚本调试"></a>4.7.2. 脚本调试</h3><p>在 Shell 脚本中，我们可以使用 <code>set -x</code> 命令打开调试模式，这会打印出所有执行的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set -x</span><br><span class="line">echo &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们会看到 <code>+ echo &#39;Hello, world!&#39;</code> 和 <code>Hello, world!</code> 两行输出。前一行显示了实际执行的命令，后一行显示了命令的输出。</p>
<p>如果你想在运行某个 shell 脚本时启用调试模式，你可以在命令行中使用 <code>-x</code> 选项和 Shell 解释器一起调用脚本，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -x script.sh</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>bash -x</code> 会启动一个新的 bash shell，并在这个 shell 中以调试模式运行 <code>script.sh</code> 脚本。这样，脚本中的每一条命令在执行前都会被打印出来。</p>
<h3 id="4-7-3-日志记录"><a href="#4-7-3-日志记录" class="headerlink" title="4.7.3. 日志记录"></a>4.7.3. 日志记录</h3><p>在 Shell 脚本中，记录执行过程和结果是一种常见的做法，以便于后续查看和分析。这通常通过将脚本的输出（包括标准输出和错误输出）重定向到文件实现。这样，我们可以随时查看这些日志文件，了解脚本运行时的具体情况。</p>
<h4 id="标准输出重定向"><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h4><p>我们可以使用 <code>&gt;</code> 和 <code>&gt;&gt;</code> 运算符将脚本的标准输出重定向到文件。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;This is a message.&quot; &gt; output.log</span><br></pre></td></tr></table></figure>

<p>这个例子中，”This is a message.” 会被写入到 <code>output.log</code> 文件中。如果文件已经存在，<code>&gt;</code> 运算符会覆盖文件的内容。如果我们想要将内容追加到文件的末尾，可以使用 <code>&gt;&gt;</code> 运算符。</p>
<h4 id="错误输出重定向"><a href="#错误输出重定向" class="headerlink" title="错误输出重定向"></a>错误输出重定向</h4><p>同样地，我们也可以使用 <code>2&gt;</code> 和 <code>2&gt;&gt;</code> 运算符将脚本的错误输出重定向到文件。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /nonexistentdirectory 2&gt; error.log</span><br></pre></td></tr></table></figure>

<p>这个例子中，如果 <code>ls</code> 命令失败，错误信息会被写入到 <code>error.log</code> 文件中。</p>
<h4 id="同时重定向标准输出和错误输出"><a href="#同时重定向标准输出和错误输出" class="headerlink" title="同时重定向标准输出和错误输出"></a>同时重定向标准输出和错误输出</h4><p>如果我们想要同时重定向标准输出和错误输出，可以使用 <code>&amp;&gt;</code> 运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /nonexistentdirectory &amp;&gt; output_and_error.log</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>ls</code> 命令的标准输出和错误输出都会被写入到 <code>output_and_error.log</code> 文件中。</p>
<p>通过这样的方式，我们可以将脚本的输出和错误信息记录下来，以便于后续查看和分析，从而更好地理解和控制 Shell 脚本的行为，更有效地找出和解决问题。</p>
<h2 id="4-8-Python-与-Shell-脚本的差异"><a href="#4-8-Python-与-Shell-脚本的差异" class="headerlink" title="4.8. Python 与 Shell 脚本的差异"></a>4.8. Python 与 Shell 脚本的差异</h2><p>Python 和 Shell 脚本是两种常用的脚本语言，它们各有特点和用途。了解它们的差异有助于我们在不同的场景下选择合适的工具。</p>
<h3 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h3><p>在 Python 中，我们使用 <code>=</code> 来给变量赋值，可以直接使用变量名引用变量，而且变量可以有多种类型，如整数、浮点数、字符串、列表、字典等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 1</span><br><span class="line">y = &quot;hello&quot;</span><br><span class="line">z = [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们同样使用 <code>=</code> 来给变量赋值，但是不能在变量名和 <code>=</code> 之间有空格，而且需要使用 <code>$</code> 来引用变量。Shell 脚本中的变量只有字符串一种类型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=1</span><br><span class="line">y=&quot;hello&quot;</span><br><span class="line">z=&quot;1 2 3&quot;</span><br></pre></td></tr></table></figure>



<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><p>Python 和 Shell 脚本都支持常见的控制结构，如条件判断和循环，但是语法有所不同。</p>
<p>在 Python 中，我们使用 <code>if</code>、<code>elif</code>、<code>else</code> 进行条件判断，使用 <code>for</code> 和 <code>while</code> 进行循环。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if x == 1:</span><br><span class="line">    print (&quot;x is 1&quot;)</span><br><span class="line">elif x == 2:</span><br><span class="line">    print (&quot;x is 2&quot;)</span><br><span class="line">else:</span><br><span class="line">    print (&quot;x is neither 1 nor 2&quot;)</span><br><span class="line"></span><br><span class="line">for i in range (3):</span><br><span class="line">    print (i)</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们使用 <code>if</code>、<code>elif</code>、<code>else</code> 进行条件判断，需要配合 <code>then</code>、<code>fi</code> 关键字。循环则可以使用 <code>for</code>、<code>while</code>，且 <code>for</code> 循环的语法与 Python 有显著差异。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if [ $x -eq 1 ]; then</span><br><span class="line">    echo &quot;x is 1&quot;</span><br><span class="line">elif [ $x -eq 2 ]; then</span><br><span class="line">    echo &quot;x is 2&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;x is neither 1 nor 2&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for i in 1 2 3; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Python 和 Shell 脚本都支持定义和调用函数，但是语法有所不同。</p>
<p>在 Python 中，我们使用 <code>def</code> 关键字来定义函数，使用函数名和括号来调用函数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def greet (name):</span><br><span class="line">    print (&quot;Hello,&quot; + name + &quot;!&quot;)</span><br><span class="line"></span><br><span class="line">greet (&quot;world&quot;)</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们使用 <code>function</code> 关键字或直接使用函数名来定义函数，调用函数时只需写出函数名，无需括号。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greet () &#123;</span><br><span class="line">    echo &quot;Hello, $1!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet &quot;world&quot;</span><br></pre></td></tr></table></figure>

<p>以上只是 Python 和 Shell 脚本的一部分差异，它们在其他方面，如错误处理、文件操作、进程控制等，也有各自的特点和用法。但是，了解这些基本的差异可以帮助我们更快地从 Python 迁移到 Shell 脚本。</p>
<h2 id="4-9-C-语言与-Shell-脚本的差异"><a href="#4-9-C-语言与-Shell-脚本的差异" class="headerlink" title="4.9. C 语言与 Shell 脚本的差异"></a>4.9. C 语言与 Shell 脚本的差异</h2><p>C 语言和 Shell 脚本是两种常用的编程和脚本语言，它们各有特点和用途。了解它们的差异有助于我们在不同的场景下选择合适的工具。</p>
<h3 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h3><p>在 C 语言中，我们必须为每个变量声明数据类型。C 语言支持多种数据类型，包括整型、浮点型、字符型、数组、结构体等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">char y [] = &quot;hello&quot;;</span><br><span class="line">int z [] = &#123;1, 2, 3&#125;;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，所有的变量都是字符串类型，我们不需要声明变量类型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=1</span><br><span class="line">y=&quot;hello&quot;</span><br><span class="line">z=&quot;1 2 3&quot;</span><br></pre></td></tr></table></figure>



<h3 id="控制结构-1"><a href="#控制结构-1" class="headerlink" title="控制结构"></a>控制结构</h3><p>C 语言和 Shell 脚本都支持常见的控制结构，如条件判断和循环，但是语法有所不同。</p>
<p>在 C 语言中，我们使用 <code>if</code>、<code>else if</code>、<code>else</code> 进行条件判断，使用 <code>for</code>、<code>while</code> 和 <code>do...while</code> 进行循环。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (x == 1) &#123;</span><br><span class="line">    printf (&quot;x is 1&quot;);</span><br><span class="line">&#125; else if (x == 2) &#123;</span><br><span class="line">    printf (&quot;x is 2&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    printf (&quot;x is neither 1 nor 2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    printf (&quot;% d&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们使用 <code>if</code>、<code>elif</code>、<code>else</code> 进行条件判断，需要配合 <code>then</code>、<code>fi</code> 关键字。循环则可以使用 <code>for</code>、<code>while</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if [ $x -eq 1 ]; then</span><br><span class="line">    echo &quot;x is 1&quot;</span><br><span class="line">elif [ $x -eq 2 ]; then</span><br><span class="line">    echo &quot;x is 2&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;x is neither 1 nor 2&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for i in 1 2 3; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>C 语言和 Shell 脚本都支持定义和调用函数，但是语法有所不同。</p>
<p>在 C 语言中，我们需要为函数声明返回类型和参数类型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void greet (char* name) &#123;</span><br><span class="line">    printf (&quot;Hello, % s!</span><br><span class="line">&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet (&quot;world&quot;);</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们不需要声明函数的返回类型和参数类型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greet () &#123;</span><br><span class="line">    echo &quot;Hello, $1!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet &quot;world&quot;</span><br></pre></td></tr></table></figure>



<h3 id="变量相等的判断"><a href="#变量相等的判断" class="headerlink" title="变量相等的判断"></a>变量相等的判断</h3><p>在 C 语言中，我们使用 <code>==</code> 符号来判断两个变量是否相等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (x == y) &#123;</span><br><span class="line">    printf (&quot;x is equal to y</span><br><span class="line">&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们使用 <code>-eq</code>（用于整数）或 <code>=</code>（用于字符串）来判断两个变量是否相等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $x -eq $y ]; then</span><br><span class="line">    echo &quot;x is equal to y&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h3 id="变量的大小比较"><a href="#变量的大小比较" class="headerlink" title="变量的大小比较"></a>变量的大小比较</h3><p>在 C 语言中，我们使用 <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 符号来比较两个变量的大小。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (x &lt; y) &#123;</span><br><span class="line">    printf (&quot;x is less than y</span><br><span class="line">&quot;);</span><br><span class="line">&#125; else if (x &gt; y) &#123;</span><br><span class="line">    printf (&quot;x is greater than y</span><br><span class="line">&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    printf (&quot;x is equal to y</span><br><span class="line">&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们使用 <code>-lt</code>、<code>-gt</code>、<code>-le</code>、<code>-ge</code> 来比较两个整数的大小。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ $x -lt $y ]; then</span><br><span class="line">    echo &quot;x is less than y&quot;</span><br><span class="line">elif [ $x -gt $y ]; then</span><br><span class="line">    echo &quot;x is greater than y&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;x is equal to y&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>在 C 语言中，我们使用字符串函数（如 <code>strcpy</code>、<code>strcat</code>、<code>strlen</code> 等）来操作字符串。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char s [100];</span><br><span class="line">strcpy (s, &quot;hello&quot;);</span><br><span class="line">strcat (s, &quot;, world&quot;);</span><br><span class="line">printf (&quot;% s</span><br><span class="line">&quot;, s); //prints &quot;hello, world&quot;</span><br><span class="line">printf (&quot;% lu</span><br><span class="line">&quot;, strlen (s)); //prints &quot;13&quot;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们可以直接使用变量和字符串字面量来连接字符串，使用 <code>$&#123;# 变量名&#125;</code> 来获取字符串长度。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s=&quot;hello&quot;</span><br><span class="line">s+=&quot;, world&quot;</span><br><span class="line">echo $s # prints &quot;hello, world&quot;</span><br><span class="line">echo $&#123;#s&#125; # prints &quot;13&quot;</span><br></pre></td></tr></table></figure>

<p>在 C 语言中，我们通常使用函数（如 <code>strstr</code> 或 <code>regex</code> 库函数）来进行字符串的模式匹配。</p>
<p>在 Shell 脚本中，我们可以直接使用 <code>=</code> 或 <code>!=</code> 运算符来进行简单的模式匹配，或者使用 <code>case</code> 语句、<code>[[ ]]</code> 结构，或者 <code>grep</code> 命令等来进行更复杂的模式匹配。</p>
<h3 id="字符串空值和非空值的判断"><a href="#字符串空值和非空值的判断" class="headerlink" title="字符串空值和非空值的判断"></a>字符串空值和非空值的判断</h3><p>在 C 语言中，我们通常使用 <code>==</code> 或 <code>!=</code> 符号来判断字符串是否为空。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *s = &quot;hello&quot;;</span><br><span class="line">if (s [0] == &#x27; &#x27;) &#123;</span><br><span class="line">    printf (&quot;s is an empty string</span><br><span class="line">&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    printf (&quot;s is not an empty string</span><br><span class="line">&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们使用 <code>-z</code> 或 <code>-n</code> 来判断字符串是否为空。另外，为了避免字符串变量未定义或为空时出错，我们在比较字符串时，常常会在字符串前加一个常量，例如 <code>x$string</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s=&quot;hello&quot;</span><br><span class="line">if [ -z &quot;$s&quot; ]; then</span><br><span class="line">    echo &quot;s is an empty string&quot;</span><br><span class="line">elif [ &quot;x$s&quot; = &quot;x&quot; ]; then</span><br><span class="line">    echo &quot;s is an empty string&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;s is not an empty string&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p>在 C 语言中，我们使用索引来访问数组元素，使用循环来遍历数组。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a [] = &#123;1, 2, 3&#125;;</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    printf (&quot;% d</span><br><span class="line">&quot;, a [i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们也使用索引来访问数组元素，使用 <code>$&#123;数组名 [@]&#125;</code> 来获取数组的所有元素，然后用 <code>for</code> 循环来遍历数组。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=(1 2 3)</span><br><span class="line">for i in $&#123;a [@]&#125;; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在 C 语言中，错误处理通常通过函数的返回值或全局变量（如 <code>errno</code>）进行。</p>
<p>在 Shell 脚本中，我们可以使用 <code>$?</code> 变量来获取上一个命令的退出状态，这通常被用作错误处理。</p>
<p>以上只是 C 语言和 Shell 脚本的一部分差异，它们在其他方面，如文件操作、进程控制、信号处理等，也有各自的特点和用法。理解这些差异有助于我们在编写或阅读这两种语言的代码时，更准确地理解其行为。</p>
<p>这些只是 C 语言和 Shell 脚本的部分差异，理解这些差异有助于我们在编写或阅读代码时，更</p>
<h1 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5. 正则表达式"></a>5. 正则表达式</h1><p>在 Shell 中，你可以使用正则表达式（Regular Expression，经常被简写为 RegEx）来描述复杂的匹配模式。正则表达式是一种强大的文本匹配工具，它可以用于 <code>grep</code>、<code>sed</code>、<code>awk</code> 等命令。</p>
<h2 id="5-1-元字符和构造"><a href="#5-1-元字符和构造" class="headerlink" title="5.1. 元字符和构造"></a>5.1. 元字符和构造</h2><p>下面是一些常用的正则表达式元字符和构造：</p>
<p><strong><code>.</code>（点）</strong>：匹配任何单个字符（除了换行符）。</p>
<p><strong><code>\*</code>（星号）</strong>：匹配前面的元素零次或多次。</p>
<p><strong><code>+</code>（加号）</strong>：匹配前面的元素一次或多次。</p>
<p><strong><code>?</code>（问号）</strong>：匹配前面的元素零次或一次。</p>
<p><strong><code>[]</code>（方括号）</strong>：匹配方括号中的任何一个字符。例如，<code>[abc]</code> 会匹配 ‘a’、’b’ 或 ‘c’。</p>
<p><strong><code>^</code>（脱字符）</strong>：在方括号中，表示否定（例如，<code>[^abc]</code> 会匹配任何不是 ‘a’、’b’ 或 ‘c’ 的字符）；在方括号外，表示行的开始。</p>
<p><strong><code>$</code>（美元符号）</strong>：表示行的结束。</p>
<p><strong><code>\</code>（反斜杠）</strong>：用于转义元字符（例如，<code>\.</code> 会匹配实际的 ‘.’ 字符，而不是任何字符）。</p>
<p><strong><code>()</code>（括号）</strong>：用于分组。</p>
<p><strong><code>|</code>（竖线）</strong>：表示或（例如，<code>a|b</code> 会匹配 ‘a’ 或 ‘b’）。</p>
<p><strong><code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code>（花括号）</strong>：匹配前面的元素 n 次、至少 n 次、或者 n 到 m 次。</p>
<p>注意，这些元字符和构造在不同的命令和环境中可能有不同的行为，具体取决于你是否使用了扩展正则表达式（Extended Regular Expression）或者 Perl 正则表达式（Perl-Compatible Regular Expression）。你可以通过查阅相应命令的手册页（例如 <code>man grep</code>）来获取更详细的信息。</p>
<h2 id="5-2-正则表达式的实例"><a href="#5-2-正则表达式的实例" class="headerlink" title="5.2. 正则表达式的实例"></a>5.2. 正则表达式的实例</h2><p>让我们看一些在 Shell 中使用正则表达式的实例。这些例子主要涉及 <code>grep</code>，<code>sed</code> 和 <code>awk</code> 命令，这些都是日常工作中常用的命令。</p>
<p><strong>使用 <code>grep</code> 进行搜索</strong></p>
<p><code>grep</code> 是一种常见的使用正则表达式的方式。你可以使用正则表达式来匹配复杂的模式。例如，下面的命令会在 <code>file.txt</code> 中找到所有以’start’ 开始并以 ‘end’ 结束的行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;^start.*end$&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>如果你想使用扩展的正则表达式特性（例如 <code>+</code>、<code>?</code>、<code>|</code> 和 <code>()</code>），你需要使用 <code>egrep</code> 或者 <code>grep -E</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E&#x27;start.*end1|end2$&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会找到所有以’start’ 开始并以 ‘end1’ 或 ‘end2’ 结束的行。</p>
<p><strong>使用 <code>sed</code> 进行替换</strong></p>
<p><code>sed</code> 可以使用正则表达式来执行复杂的替换操作。例如，下面的命令会在 <code>file.txt</code> 中将所有以’start’ 开始并以 ‘end’ 结束的行替换为 ‘replacement’：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -E&#x27;s/^start.*end$/replacement/g&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>awk</code> 进行文本处理</strong></p>
<p><code>awk</code> 可以使用正则表达式来处理复杂的文本模式。例如，下面的命令会打印 <code>file.txt</code> 中所有包含 ‘pattern’ 的行的第一列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/pattern/ &#123;print $1&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>这只是正则表达式在 Shell 中的一些基本用法，你可以根据需要进行组合和扩展，以处理更复杂的模式和任务。</p>
<h1 id="6-Linux-环境下的编程常见操作"><a href="#6-Linux-环境下的编程常见操作" class="headerlink" title="6. Linux 环境下的编程常见操作"></a>6. Linux 环境下的编程常见操作</h1><h2 id="6-1-C-编程环境的配置"><a href="#6-1-C-编程环境的配置" class="headerlink" title="6.1. C 编程环境的配置"></a>6.1. C 编程环境的配置</h2><p>在 Linux 环境下进行 C 语言编程，需要先配置好开发环境。一般而言，你应该已经安装了 GCC（GNU Compiler Collection）集合，它包含了 C 语言的编译器。如果你还未安装 GCC，可以通过以下命令进行安装（以 Ubuntu 为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

<p>安装完 GCC 后，你可以通过在终端输入 <code>gcc --version</code> 来验证安装是否成功。</p>
<h2 id="6-2-基本的编译命令"><a href="#6-2-基本的编译命令" class="headerlink" title="6.2. 基本的编译命令"></a>6.2. 基本的编译命令</h2><p>编译 C 程序主要使用 <code>gcc</code> 命令。如果你有一个名为 <code>program.c</code> 的 C 语言源文件，你可以使用以下命令进行编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc program.c -o program</span><br></pre></td></tr></table></figure>

<p>在这个命令中，<code>-o program</code> 表示编译后生成的可执行文件名为 <code>program</code>。如果你省略 <code>-o</code> 选项，那么默认的输出文件名为 <code>a.out</code>。</p>
<h2 id="6-3-版本控制工具"><a href="#6-3-版本控制工具" class="headerlink" title="6.3. 版本控制工具"></a>6.3. 版本控制工具</h2><p>在 Linux 环境下，最常用的版本控制工具无疑是 Git。Git 是一个分布式的版本控制系统，可以帮助你跟踪和管理项目的代码变更。</p>
<p>首次使用 Git 时，你需要配置你的用户名和电子邮件地址，因为 Git 每次提交会使用这些信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;Your Email&quot;</span><br></pre></td></tr></table></figure>

<p>Git 的基本工作流程包括：初始化仓库（<code>git init</code>）、添加文件到仓库（<code>git add</code>）、提交变更（<code>git commit</code>）、查看状态（<code>git status</code>）、查看提交历史（<code>git log</code>）等。</p>
<h2 id="6-4-调试工具"><a href="#6-4-调试工具" class="headerlink" title="6.4. 调试工具"></a>6.4. 调试工具</h2><p>对于 C 语言程序，最常用的调试工具是 GDB（GNU Debugger）。GDB 可以让你逐行地运行程序，查看和修改程序状态，以帮助你查找和修复错误。</p>
<p>在使用 GDB 之前，你需要使用 <code>-g</code> 选项来编译你的 C 程序，以包含调试信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g program.c -o program</span><br></pre></td></tr></table></figure>

<p>然后，你可以使用 <code>gdb</code> 命令启动 GDB 并加载你的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb program</span><br></pre></td></tr></table></figure>

<p>在 GDB 中，你可以使用各种命令进行调试，如：<code>run</code>（运行程序）、<code>break</code>（设置断点）、<code>next</code>（执行下一行程序）、<code>print</code>（打印变量的值）等。</p>
<p>以上就是在 Linux 环境下进行编程的一些常见操作，包括 C 编程环境的配置、基本的编译命令、版本控制工具以及调试工具。希望对你有所帮助。</p>
<h1 id="7-Makefile-的使用和编写"><a href="#7-Makefile-的使用和编写" class="headerlink" title="7. Makefile 的使用和编写"></a>7. Makefile 的使用和编写</h1><p>在 C 程序的编译和构建过程中，<code>make</code> 是一个非常重要的工具。<code>make</code> 工具可以自动化编译和链接的过程，它依赖于一个名为 <code>Makefile</code> 的文件，该文件描述了各个源文件之间的依赖关系以及如何从源文件生成目标文件。</p>
<h2 id="7-1-什么是-Makefile"><a href="#7-1-什么是-Makefile" class="headerlink" title="7.1. 什么是 Makefile"></a>7.1. 什么是 Makefile</h2><p>Makefile 是一个包含了一系列规则（rules）和变量的文件。规则定义了目标文件的生成过程，变量则可以在多个地方重复使用同一个值。</p>
<p>一个基本的 <code>Makefile</code> 规则包含了一个目标（target），它的依赖项（dependencies）和一个命令（command）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target: dependencies</span><br><span class="line">    command</span><br></pre></td></tr></table></figure>



<h2 id="7-2-Makefile-的基本结构"><a href="#7-2-Makefile-的基本结构" class="headerlink" title="7.2. Makefile 的基本结构"></a>7.2. Makefile 的基本结构</h2><p>一个简单的 Makefile 示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myprogram: main.o utility.o</span><br><span class="line">    gcc -o myprogram main.o utility.o</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">    gcc -c main.c</span><br><span class="line"></span><br><span class="line">utility.o: utility.c</span><br><span class="line">    gcc -c utility.c</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myprogram</code> 是最终的目标，它依赖于两个 <code>.o</code> 文件，每个 <code>.o</code> 文件又各自依赖于一个 <code>.c</code> 文件。</p>
<p>如果我们在终端中运行 <code>make</code> 命令，<code>make</code> 工具会检查 <code>Makefile</code> 文件，并按照规则执行命令。如果一个 <code>.o</code> 文件的时间戳比其对应的 <code>.c</code> 文件新，<code>make</code> 工具就会跳过编译这个 <code>.c</code> 文件的步骤。</p>
<h2 id="7-3-使用变量"><a href="#7-3-使用变量" class="headerlink" title="7.3. 使用变量"></a>7.3. 使用变量</h2><p>在 <code>Makefile</code> 中，我们可以定义变量，然后在命令中使用它们。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I.</span><br><span class="line"></span><br><span class="line">%.o: %.c</span><br><span class="line">    $(CC) -c -o $@ $&lt; $(CFLAGS)</span><br><span class="line"></span><br><span class="line">myprogram: main.o utility.o</span><br><span class="line">    $(CC) -o myprogram main.o utility.o</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>CC</code> 和 <code>CFLAGS</code> 是变量，<code>$(CC)</code> 和 <code>$(CFLAGS)</code> 是对变量的引用。<code>$@</code> 和 <code>$&lt;</code> 是自动变量，<code>$@</code> 表示目标文件名，<code>$&lt;</code> 表示第一个依赖文件名。</p>
<h2 id="7-4-使用伪目标"><a href="#7-4-使用伪目标" class="headerlink" title="7.4. 使用伪目标"></a>7.4. 使用伪目标</h2><p>有时候，我们希望定义一些并不产生文件的目标，例如清理构建生成的文件。我们可以使用 <code>.PHONY</code> 伪目标来定义这种规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f *.o myprogram</span><br></pre></td></tr></table></figure>

<p>在这个示例中，如果我们运行 <code>make clean</code>，<code>make</code> 工具就会执行 <code>rm -f *.o myprogram</code> 命令，删除所有 <code>.o</code> 文件和 <code>myprogram</code> 文件。</p>
<p>以上就是 Makefile 的基础知识。理解并会用 Makefile 可以帮助你更有效地编译和构建 C 程序。在实际使用中，Makefile 可能会包含更复杂的规则和变量，但基本的思想和结构都是一样的。</p>
<h2 id="7-5-编译选项和标记"><a href="#7-5-编译选项和标记" class="headerlink" title="7.5. 编译选项和标记"></a>7.5. 编译选项和标记</h2><p>在使用 <code>make</code> 和 <code>Makefile</code> 进行 C 程序编译和链接时，你可能会遇到很多选项和标记。以下是其中一些最常见的。</p>
<p><strong>CFLAGS</strong></p>
<p><code>CFLAGS</code> 是 <code>gcc</code> (GNU Compiler Collection 的 C 编译器部分) 中用于设置 C 编译器选项的环境变量。这些选项包括优化级别、警告级别、调试信息等。</p>
<p>以下是一些常见的 <code>CFLAGS</code> 选项：</p>
<ul>
<li><code>-O</code> : 这个选项用于设置优化级别，如 <code>-O1</code>， <code>-O2</code>， <code>-O3</code> 和 <code>-Os</code>。更高的优化级别会使编译器花更多的时间来优化代码，以生成更快的程序。</li>
<li><code>-g</code> : 这个选项使编译器生成调试信息，这对于使用 gdb 等调试工具非常有用。</li>
<li><code>-Wall</code> : 这个选项使编译器生成所有的警告信息，这可以帮助你发现代码中的问题。</li>
</ul>
<p><strong>LDFLAGS</strong></p>
<p><code>LDFLAGS</code> 是 <code>gcc</code> 中用于设置链接器选项的环境变量。这些选项包括库搜索路径、链接的库等。</p>
<p>以下是一些常见的 <code>LDFLAGS</code> 选项：</p>
<ul>
<li><code>-L</code> : 这个选项用于指定库搜索路径，如 <code>-L/usr/local/lib</code>。</li>
<li><code>-l</code> : 这个选项用于指定要链接的库，如 <code>-lm</code> 指定链接数学库。</li>
</ul>
<p><strong>-I</strong></p>
<p><code>-I</code> 是 <code>gcc</code> 中用于设置头文件搜索路径的选项。例如，<code>-I/usr/local/include</code> 会使编译器在 <code>/usr/local/include</code> 目录中搜索头文件。</p>
<p><strong>-D</strong></p>
<p><code>-D</code> 是 <code>gcc</code> 中用于定义宏的选项。例如，<code>-DDEBUG</code> 会定义一个名为 <code>DEBUG</code> 的宏。</p>
<p>在 <code>Makefile</code> 中，你可以设置 <code>CFLAGS</code> 和 <code>LDFLAGS</code> 变量，然后在编译和链接命令中使用它们。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I. -g -O2 -Wall</span><br><span class="line">LDFLAGS=-L/usr/local/lib -lm</span><br><span class="line"></span><br><span class="line">myprogram: main.o utility.o</span><br><span class="line">    $(CC) $(LDFLAGS) -o $@ $^ $(CFLAGS)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，编译命令会包含 <code>-I. -g -O2 -Wall</code> 选项，链接命令会包含 <code>-L/usr/local/lib -lm</code> 选项。</p>
<h2 id="7-6-编写通用性强的-Makefile"><a href="#7-6-编写通用性强的-Makefile" class="headerlink" title="7.6. 编写通用性强的 Makefile"></a>7.6. 编写通用性强的 Makefile</h2><p>当我们有很多 <code>.c</code> 文件时，如果每次增加或删除 <code>.c</code> 文件都需要修改 <code>Makefile</code>，那么将会非常麻烦。一个解决办法是编写一个通用性强的 <code>Makefile</code>，使其能自动检测并编译所有 <code>.c</code> 文件。</p>
<p>以下是一个示例，这个 <code>Makefile</code> 可以自动检测所有 <code>.c</code> 文件，并编译它们生成对应的 <code>.o</code> 文件，最后链接所有 <code>.o</code> 文件生成目标程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I.</span><br><span class="line"></span><br><span class="line"># 使用 Shell 命令查找所有 .c 文件</span><br><span class="line">SRCS=$(shell find . -name &quot;*.c&quot;)</span><br><span class="line"># 把 .c 文件列表转化为 .o 文件列表</span><br><span class="line">OBJS=$(patsubst %.c,%.o,$(SRCS))</span><br><span class="line"></span><br><span class="line">myprogram: $(OBJS)</span><br><span class="line">    $(CC) -o $@ $^ $(CFLAGS)</span><br><span class="line"></span><br><span class="line">%.o: %.c</span><br><span class="line">    $(CC) -c -o $@ $&lt; $(CFLAGS)</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f $(OBJS) myprogram</span><br></pre></td></tr></table></figure>

<p>在这个 <code>Makefile</code> 中：</p>
<ul>
<li><code>$(shell find . -name &quot;*.c&quot;)</code> 使用 <code>find</code> 命令查找所有 <code>.c</code> 文件。</li>
<li><code>$(patsubst %.c,%.o,$(SRCS))</code> 把 <code>.c</code> 文件列表转化为 <code>.o</code> 文件列表。</li>
<li><code>myprogram: $(OBJS)</code> 指定了 <code>myprogram</code> 依赖于所有 <code>.o</code> 文件。</li>
<li><code>%.o: %.c</code> 是一个模式规则，它指定了如何从 <code>.c</code> 文件生成 <code>.o</code> 文件。</li>
</ul>
<p>当我们运行 <code>make</code> 命令时，<code>make</code> 工具会自动检测并编译所有 <code>.c</code> 文件，然后链接所有 <code>.o</code> 文件生成目标程序。</p>
<p>这个 <code>Makefile</code> 具有很好的通用性，无论我们增加或删除 <code>.c</code> 文件，都不需要修改 <code>Makefile</code>。我们只需要保证所有 <code>.c</code> 文件都在 <code>Makefile</code> 所在目录或其子目录下即可。</p>
<h2 id="7-7-调试-Makefile"><a href="#7-7-调试-Makefile" class="headerlink" title="7.7. 调试 Makefile"></a>7.7. 调试 Makefile</h2><p>当你编写的 <code>Makefile</code> 没有按预期的方式工作时，你可能需要调试它。幸运的是，<code>make</code> 工具提供了一些选项来帮助我们调试 <code>Makefile</code>。</p>
<p><code>-n</code> 或 <code>--just-print</code> 选项可以让 <code>make</code> 工具只打印命令，而不真正执行它们。这个选项对于检查 <code>Makefile</code> 中的命令是否正确非常有用。</p>
<p>例如，你可以运行 <code>make -n myprogram</code> 来查看生成 <code>myprogram</code> 的命令是否正确。</p>
<p><code>-d</code> 选项会让 <code>make</code> 工具打印大量的调试信息，包括它是如何读取 <code>Makefile</code>，如何决定规则的依赖关系，以及如何执行命令等等。这个选项非常有用，但它可能会产生很多输出。</p>
<p><code>$(warning ...)</code> 函数会打印一条警告信息，然后继续执行 <code>make</code>。<code>$(info ...)</code> 函数会打印一条信息，但不会产生警告或错误。这两个函数可以用来检查变量的值或调试 <code>Makefile</code>。</p>
<p>例如，你可以在 <code>Makefile</code> 中添加一行 <code>$(info SRCS is $(SRCS))</code> 来查看 <code>SRCS</code> 变量的值。</p>
<p><code>--debug</code> 或 <code>-d</code> 选项可以让 <code>make</code> 打印出大量的调试信息，这对于理解 <code>make</code> 是如何解析 <code>Makefile</code>，以及它是如何决定哪些目标需要重新构建的，非常有用。</p>
<p><code>make</code> 是通过比较目标和它的依赖项的时间戳来决定是否需要重新构建目标。如果你的 <code>Makefile</code> 没有按预期的方式工作，可能是因为文件的时间戳有问题。你可以使用 <code>ls -l</code> 命令来查看文件的时间戳。</p>
<p>调试 <code>Makefile</code> 可能需要一些耐心和实践，但是一旦你理解了 <code>make</code> 工具的工作方式，你就能编写出更强大、更灵活的 <code>Makefile</code>。</p>
<h2 id="7-8-xuedue"><a href="#7-8-xuedue" class="headerlink" title="7.8. xuedue"></a>7.8. xuedue</h2><ul>
<li>符号信息</li>
</ul>
<p>file 查看文件信息，可以看到符号信息，not stripped 就是没有去符号</p>
<p>使用 strip filename 可以去符号（strip可能在其他目录中）</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Shell-常用命令速查表"><a href="#Shell-常用命令速查表" class="headerlink" title="Shell 常用命令速查表"></a>Shell 常用命令速查表</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>常用选项</th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code></td>
<td>列出目录中的文件和子目录</td>
<td><code>-l</code>：长格式 &lt; br&gt; <code>-a</code>：包括隐藏文件 &lt; br&gt; <code>-h</code>：易读的文件大小 &lt; br&gt; <code>-t</code>：按修改时间排序 &lt; br&gt; <code>-r</code>：反向排序</td>
</tr>
<tr>
<td><code>cd</code></td>
<td>改变当前目录</td>
<td><code>..</code>：上级目录 &lt; br&gt; <code>~</code>：用户主目录 &lt; br&gt; <code>-</code>：上次工作目录</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>打印当前工作目录</td>
<td>-</td>
</tr>
<tr>
<td><code>cp</code></td>
<td>复制文件或目录</td>
<td><code>-r</code>：复制目录 &lt; br&gt; <code>-p</code>：保留文件属性</td>
</tr>
<tr>
<td><code>mv</code></td>
<td>移动或重命名文件或目录</td>
<td>-</td>
</tr>
<tr>
<td><code>rm</code></td>
<td>删除文件或目录</td>
<td><code>-r</code>：删除目录 &lt; br&gt; <code>-f</code>：强制删除</td>
</tr>
<tr>
<td><code>cat</code></td>
<td>查看或连接文件内容</td>
<td><code>-n</code>：显示行号</td>
</tr>
<tr>
<td><code>less</code></td>
<td>分页查看文件内容</td>
<td>-</td>
</tr>
<tr>
<td><code>grep</code></td>
<td>搜索文本</td>
<td><code>-i</code>：忽略大小写 &lt; br&gt; <code>-r</code>：递归搜索 &lt; br&gt; <code>-v</code>：显示不匹配行</td>
</tr>
<tr>
<td><code>find</code></td>
<td>查找文件或目录</td>
<td><code>-name</code>：按名称查找 &lt; br&gt; <code>-type</code>：按类型查找 &lt; br&gt; <code>-size</code>：按大小查找</td>
</tr>
<tr>
<td><code>tar</code></td>
<td>打包或解压缩文件</td>
<td><code>-c</code>：创建归档文件 &lt; br&gt; <code>-x</code>：提取文件 &lt; br&gt; <code>-f</code>：指定文件名 &lt; br&gt; <code>-v</code>：显示详细信息 &lt; br&gt; <code>-z</code>：gzip 压缩 / 解压 &lt; br&gt; <code>-j</code>：bzip2 压缩 / 解压</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">xuedue</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/08/09/OS/OS-Linux-Command/">http://example.com/2021/08/09/OS/OS-Linux-Command/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">xuedue</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/img/default.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/08/09/OS/OS-Linux-screen/" title="OS-Linux-screen"><img class="cover" src="https://i.loli.net/2021/08/02/DnqpSa6M5R1eHvG.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">OS-Linux-screen</div></div><div class="info-2"><div class="info-item-1">screen 使用命令行下的screen命令创建名为xuedue的session 1screen -S xuedue  列出当前所有session 1screen -ls  远程离线(detach)名为xuedue的session(如果有多个同名记得带编号)   1screen -d name  回到名为xuedue的session 1screen -r xuedue  删除名为xuedue的session 1screen -X -S xuedue quit  session中使用Ctrl+a的命令只记录一些最常用的离线当前session 1Ctrl+a+d  </div></div></div></a><a class="pagination-related" href="/2021/08/01/Hexo/Hexo-Markdown/" title="Markdown语法记录"><img class="cover" src="https://i.loli.net/2021/08/02/DnqpSa6M5R1eHvG.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Markdown语法记录</div></div><div class="info-2"><div class="info-item-1">只记录自己在写的时候会发问的语法（以防忘记 加粗,斜体,删除线   语法 效果    **加粗** 加粗   *斜体* 斜体   ***粗斜体文本*** 粗斜体文本   ~~删除线~~ 删除线   代码块语法 ``` language ``` 效果 1  csdn或者hexo上显示连续中划线-&zwnj;- 在连续中划线之间使用零宽不连字 &amp;zwnj;      语法 效果    -&amp;zwnj;- -&zwnj;-    直接用``进行包裹      语法 效果    `–` --     添加分割线语法 12345***  * * *  *****  - - -  ----------  效果  添加待办事项语法 12- [ ] 准备做- [x] 已经完成  效果   准备做  已经完成  Markdown添加参考文献参考资料 </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2021/07/22/OS/OS-Linux-Q&A/" title="Linux命令和问题"><img class="cover" src="https://i.loli.net/2021/08/02/DnqpSa6M5R1eHvG.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-22</div><div class="info-item-2">Linux命令和问题</div></div><div class="info-2"><div class="info-item-1">解决ubuntu 16.4解压后中文乱码zip格式没有指定编码格式，window下的zip编码是GBK/GB2312等 使用命令进行解压 1unzip -O CP936  xxx.zip  其中字符可以是CP936、GBK、GB18030三种中的任一一种 Linux查看占用GPU的进程1sudo fuser -v /dev/nvidia*  </div></div></div></a><a class="pagination-related" href="/2021/08/14/OS/OS-Linux-Ubuntu%E6%8D%A2%E9%A9%B1%E5%8A%A8/" title="OS-Linux-Ubuntu换驱动"><img class="cover" src="https://i.loli.net/2021/08/02/DnqpSa6M5R1eHvG.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-14</div><div class="info-item-2">OS-Linux-Ubuntu换驱动</div></div><div class="info-2"><div class="info-item-1">参考文章  ubuntu16.04更换nvidia驱动极简教程  驱动下载网址   禁用nouveau123sudo echo &quot;blacklist nouveau&quot; &gt;&gt; /etc/modprobe.d/blacklist.confsudo update-initramfs -ureboot  可使用以下命令查询是否禁用成功。1lsmod | grep nouveau 安装nvidia驱动nvidia官网下载显卡对应驱动，更改文件权限。1sudo chmod 777 NVIDIA-Linux-XXX.run Ctrl + Alt + F1 进入命令行模式。12sudo service lightdm stopsudo ./NVIDIA-Linux-XXX.run 一直确定即可。最后重启。1reboot 可使用以下命令查看驱动是否安装成功。1nvidia-smi  </div></div></div></a><a class="pagination-related" href="/2021/08/09/OS/OS-Linux-screen/" title="OS-Linux-screen"><img class="cover" src="https://i.loli.net/2021/08/02/DnqpSa6M5R1eHvG.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-09</div><div class="info-item-2">OS-Linux-screen</div></div><div class="info-2"><div class="info-item-1">screen 使用命令行下的screen命令创建名为xuedue的session 1screen -S xuedue  列出当前所有session 1screen -ls  远程离线(detach)名为xuedue的session(如果有多个同名记得带编号)   1screen -d name  回到名为xuedue的session 1screen -r xuedue  删除名为xuedue的session 1screen -X -S xuedue quit  session中使用Ctrl+a的命令只记录一些最常用的离线当前session 1Ctrl+a+d  </div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xuedue</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xuedue"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xuedue" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://bilibili.com" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">今天超市薯片半价</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BPID%E6%89%80%E5%9C%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">1.</span> <span class="toc-text">查看PID所在的文件夹</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Ubuntu-Linux-%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">1. Ubuntu Linux 系统的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">1.1. Linux 操作系统的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Linux-%E5%92%8C-Windows-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">1.2. Linux 和 Windows 的主要区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Linux-%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">1.3. Linux 常见目录结构和作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Ubuntu-%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%BC%98%E5%8A%BF"><span class="toc-number">2.4.</span> <span class="toc-text">1.4. Ubuntu 的特点和优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Ubuntu-%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">2.5.</span> <span class="toc-text">1.5. Ubuntu 的配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Ubuntu-Linux-%E7%8E%AF%E5%A2%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">2. Ubuntu Linux 环境的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Nautilus-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">2.1. Nautilus 文件管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Nautilus-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">Nautilus 基础用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nautilus-%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">3.1.2.</span> <span class="toc-text">Nautilus 快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-SMB-%E5%8D%8F%E8%AE%AE%E8%AE%BF%E9%97%AE%E7%89%B9%E5%AE%9A-URL"><span class="toc-number">3.1.3.</span> <span class="toc-text">通过 SMB 协议访问特定 URL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">2.2. 命令语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6"><span class="toc-number">3.3.</span> <span class="toc-text">2.3. 命令提示符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.</span> <span class="toc-text">2.4. 系统操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">3.5.</span> <span class="toc-text">2.5. 环境变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.</span> <span class="toc-text">2.6. 文件和目录操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E9%93%BE%E6%8E%A5"><span class="toc-number">3.7.</span> <span class="toc-text">2.7. 链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">3.7.1.</span> <span class="toc-text">硬链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-number">3.7.2.</span> <span class="toc-text">软链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%93%BE%E6%8E%A5"><span class="toc-number">3.7.3.</span> <span class="toc-text">查看链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E6%8E%A5"><span class="toc-number">3.7.4.</span> <span class="toc-text">删除链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8E%8B"><span class="toc-number">3.8.</span> <span class="toc-text">2.8. 打包和解压</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tar-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.8.1.</span> <span class="toc-text">tar 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unzip-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.8.2.</span> <span class="toc-text">unzip 命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.9.</span> <span class="toc-text">2.9. 文本文件的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E8%AE%A1%E7%AE%97%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">3.10.</span> <span class="toc-text">2.10. 计算哈希值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-%E7%BC%96%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">3.11.</span> <span class="toc-text">2.11. 编程和系统管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">3.12.</span> <span class="toc-text">2.12. 输入输出重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13-%E5%89%AA%E5%88%87"><span class="toc-number">3.13.</span> <span class="toc-text">2.13. 剪切</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-14-%E6%8E%92%E5%BA%8F%E5%92%8C%E5%8E%BB%E9%87%8D"><span class="toc-number">3.14.</span> <span class="toc-text">2.14. 排序和去重</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sort-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.14.1.</span> <span class="toc-text">sort 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uniq-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.14.2.</span> <span class="toc-text">uniq 命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-15-%E7%BB%9F%E8%AE%A1"><span class="toc-number">3.15.</span> <span class="toc-text">2.15. 统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-16-%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="toc-number">3.16.</span> <span class="toc-text">2.16. 搜索和替换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-grep-%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2"><span class="toc-number">3.16.1.</span> <span class="toc-text">使用 grep 进行搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-sed-%E8%BF%9B%E8%A1%8C%E6%9B%BF%E6%8D%A2"><span class="toc-number">3.16.2.</span> <span class="toc-text">使用 sed 进行替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-awk-%E8%BF%9B%E8%A1%8C%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.16.3.</span> <span class="toc-text">使用 awk 进行更复杂的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-find-%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="toc-number">3.16.4.</span> <span class="toc-text">使用 find 搜索文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4"><span class="toc-number">3.16.5.</span> <span class="toc-text">组合命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-17-%E6%9D%83%E9%99%90%E4%B8%8E%E6%89%80%E6%9C%89%E6%9D%83%E7%AE%A1%E7%90%86"><span class="toc-number">3.17.</span> <span class="toc-text">2.17. 权限与所有权管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-18-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7"><span class="toc-number">3.18.</span> <span class="toc-text">2.18. 进程管理和系统监控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-18-1-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.18.1.</span> <span class="toc-text">2.18.1. 查看进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-18-2-%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.18.2.</span> <span class="toc-text">2.18.2. 结束进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-18-3-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">3.18.3.</span> <span class="toc-text">2.18.3. 查看进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-18-4-%E6%9F%A5%E7%9C%8B-proc-%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">3.18.4.</span> <span class="toc-text">2.18.4. 查看 &#x2F;proc 中的信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-CPU-%E4%BF%A1%E6%81%AF"><span class="toc-number">3.18.4.1.</span> <span class="toc-text">查看 CPU 信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF"><span class="toc-number">3.18.4.2.</span> <span class="toc-text">查看内存信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%89%B9%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">3.18.4.3.</span> <span class="toc-text">查看特定进程的信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-18-5-%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0"><span class="toc-number">3.18.5.</span> <span class="toc-text">2.18.5. 查看网络参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#traceroute"><span class="toc-number">3.18.5.1.</span> <span class="toc-text">traceroute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ping"><span class="toc-number">3.18.5.2.</span> <span class="toc-text">ping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nslookup"><span class="toc-number">3.18.5.3.</span> <span class="toc-text">nslookup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ifconfig-%E5%92%8C-ip"><span class="toc-number">3.18.5.4.</span> <span class="toc-text">ifconfig 和 ip</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#netstat-%E5%92%8C-ss"><span class="toc-number">3.18.5.5.</span> <span class="toc-text">netstat 和 ss</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-19-%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E5%92%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">3.19.</span> <span class="toc-text">2.19. 键盘快捷和命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-20-%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-number">3.20.</span> <span class="toc-text">2.20. 包管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-21-%E5%85%B6%E4%BB%96"><span class="toc-number">3.21.</span> <span class="toc-text">2.21. 其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#watch-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.21.1.</span> <span class="toc-text">watch 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#time-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.21.2.</span> <span class="toc-text">time 命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-22-%E6%9F%A5%E7%9C%8B%E5%B8%AE%E5%8A%A9%E6%89%8B%E5%86%8C"><span class="toc-number">3.22.</span> <span class="toc-text">2.22. 查看帮助手册</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">3. 编辑器的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Vim-%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">3.1. Vim 编辑器的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Vim-%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">3.2. Vim 的模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Vim-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.</span> <span class="toc-text">3.3. Vim 的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Vim-%E7%9A%84%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD"><span class="toc-number">4.4.</span> <span class="toc-text">3.4. Vim 的高级功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Vim-%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%BB%83%E4%B9%A0"><span class="toc-number">4.5.</span> <span class="toc-text">3.5. Vim 的实际应用练习</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Bash-Shell-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">5.</span> <span class="toc-text">4. Bash Shell 编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">4.1. 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bash-Shell-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.1.1.</span> <span class="toc-text">Bash Shell 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bash-Shell-%E7%9A%84%E5%8E%86%E5%8F%B2%E5%92%8C%E5%BA%94%E7%94%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">Bash Shell 的历史和应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Shell-%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.</span> <span class="toc-text">4.2. Shell 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">什么是变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">如何声明和使用变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.3.</span> <span class="toc-text">环境变量和局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.4.</span> <span class="toc-text">特殊变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Shell-%E8%84%9A%E6%9C%AC"><span class="toc-number">5.3.</span> <span class="toc-text">4.3. Shell 脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Shell-%E8%84%9A%E6%9C%AC"><span class="toc-number">5.3.1.</span> <span class="toc-text">什么是 Shell 脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C-Shell-%E8%84%9A%E6%9C%AC"><span class="toc-number">5.3.2.</span> <span class="toc-text">如何创建和运行 Shell 脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell-%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E6%B3%95"><span class="toc-number">5.3.3.</span> <span class="toc-text">Shell 脚本的结构和语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">5.3.4.</span> <span class="toc-text">参数传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">4.4. 流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.4.1.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%EF%BC%88for-while-until%EF%BC%89"><span class="toc-number">5.4.2.</span> <span class="toc-text">循环语句（for, while, until）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.</span> <span class="toc-text">4.5. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.1.</span> <span class="toc-text">什么是函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.2.</span> <span class="toc-text">如何声明和调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.5.3.</span> <span class="toc-text">函数的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.4.</span> <span class="toc-text">递归函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">5.6.</span> <span class="toc-text">4.6. 用户输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5"><span class="toc-number">5.6.1.</span> <span class="toc-text">读取输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA"><span class="toc-number">5.6.2.</span> <span class="toc-text">打印输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.6.3.</span> <span class="toc-text">文件重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">5.6.4.</span> <span class="toc-text">管道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%92%8C%E8%B0%83%E8%AF%95"><span class="toc-number">5.7.</span> <span class="toc-text">4.7. 错误处理和调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">5.7.1.</span> <span class="toc-text">4.7.1. 错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-%E8%84%9A%E6%9C%AC%E8%B0%83%E8%AF%95"><span class="toc-number">5.7.2.</span> <span class="toc-text">4.7.2. 脚本调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-number">5.7.3.</span> <span class="toc-text">4.7.3. 日志记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.7.3.1.</span> <span class="toc-text">标准输出重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.7.3.2.</span> <span class="toc-text">错误输出重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E5%92%8C%E9%94%99%E8%AF%AF%E8%BE%93%E5%87%BA"><span class="toc-number">5.7.3.3.</span> <span class="toc-text">同时重定向标准输出和错误输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-Python-%E4%B8%8E-Shell-%E8%84%9A%E6%9C%AC%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">5.8.</span> <span class="toc-text">4.8. Python 与 Shell 脚本的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.8.1.</span> <span class="toc-text">变量和类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">5.8.2.</span> <span class="toc-text">控制结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">5.8.3.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-C-%E8%AF%AD%E8%A8%80%E4%B8%8E-Shell-%E8%84%9A%E6%9C%AC%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">5.9.</span> <span class="toc-text">4.9. C 语言与 Shell 脚本的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">5.9.1.</span> <span class="toc-text">数据类型和变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84-1"><span class="toc-number">5.9.2.</span> <span class="toc-text">控制结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-1"><span class="toc-number">5.9.3.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9B%B8%E7%AD%89%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">5.9.4.</span> <span class="toc-text">变量相等的判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83"><span class="toc-number">5.9.5.</span> <span class="toc-text">变量的大小比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">5.9.6.</span> <span class="toc-text">字符串操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A9%BA%E5%80%BC%E5%92%8C%E9%9D%9E%E7%A9%BA%E5%80%BC%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">5.9.7.</span> <span class="toc-text">字符串空值和非空值的判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">5.9.8.</span> <span class="toc-text">数组操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">5.9.9.</span> <span class="toc-text">错误处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">5. 正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%85%83%E5%AD%97%E7%AC%A6%E5%92%8C%E6%9E%84%E9%80%A0"><span class="toc-number">6.1.</span> <span class="toc-text">5.1. 元字符和构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.2.</span> <span class="toc-text">5.2. 正则表达式的实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Linux-%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-number">7.</span> <span class="toc-text">6. Linux 环境下的编程常见操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-C-%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">7.1.</span> <span class="toc-text">6.1. C 编程环境的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4"><span class="toc-number">7.2.</span> <span class="toc-text">6.2. 基本的编译命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7"><span class="toc-number">7.3.</span> <span class="toc-text">6.3. 版本控制工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">7.4.</span> <span class="toc-text">6.4. 调试工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Makefile-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BC%96%E5%86%99"><span class="toc-number">8.</span> <span class="toc-text">7. Makefile 的使用和编写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E4%BB%80%E4%B9%88%E6%98%AF-Makefile"><span class="toc-number">8.1.</span> <span class="toc-text">7.1. 什么是 Makefile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Makefile-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">8.2.</span> <span class="toc-text">7.2. Makefile 的基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">8.3.</span> <span class="toc-text">7.3. 使用变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E4%BD%BF%E7%94%A8%E4%BC%AA%E7%9B%AE%E6%A0%87"><span class="toc-number">8.4.</span> <span class="toc-text">7.4. 使用伪目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E5%92%8C%E6%A0%87%E8%AE%B0"><span class="toc-number">8.5.</span> <span class="toc-text">7.5. 编译选项和标记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E7%BC%96%E5%86%99%E9%80%9A%E7%94%A8%E6%80%A7%E5%BC%BA%E7%9A%84-Makefile"><span class="toc-number">8.6.</span> <span class="toc-text">7.6. 编写通用性强的 Makefile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-%E8%B0%83%E8%AF%95-Makefile"><span class="toc-number">8.7.</span> <span class="toc-text">7.7. 调试 Makefile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-xuedue"><span class="toc-number">8.8.</span> <span class="toc-text">7.8. xuedue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">9.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="toc-number">9.1.</span> <span class="toc-text">Shell 常用命令速查表</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/80211%206G%E8%B0%83%E7%A0%94/" title="80211 6G调研">80211 6G调研</a><time datetime="2026-02-04T15:39:55.000Z" title="发表于 2026-02-04 15:39:55">2026-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/20/Proxy/telegram%E7%99%BB%E5%BD%95/" title="Telegram需要旧手机验证/收不到验证码100%可用解决方法">Telegram需要旧手机验证/收不到验证码100%可用解决方法</a><time datetime="2026-01-20T16:02:09.000Z" title="发表于 2026-01-20 16:02:09">2026-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/18/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%B0%83%E6%B5%8B%E5%B7%A5%E5%85%B7/" title="嵌入式调测工具">嵌入式调测工具</a><time datetime="2026-01-18T16:08:55.000Z" title="发表于 2026-01-18 16:08:55">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/default.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By xuedue</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 5.4.2</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/js/tw_cn.js?v=5.5.3"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liuy5uBHgv2OwgD3',
      clientSecret: '5846745c3fef6377eeb8df8b4ad3aaf4cf0f1cb8',
      repo: 'xuedue_comments',
      owner: 'xuedue',
      admin: ['xuedue'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'e83ffbf9b6b0bf07ba4e07157de73c27'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>