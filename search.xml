<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VirtualBox磁盘扩容</title>
    <url>/2026/01/18/VirtualBox%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<p>虚拟机磁盘空间不足，需要对磁盘进行扩容，这种时候有两种选择，第一种是挂载一个新的磁盘（win中在C盘基础上添加一个D盘），第二种是直接对原文件系统进行扩容（win中直接对C盘进行扩容）</p>
<h2 id="挂载新磁盘"><a href="#挂载新磁盘" class="headerlink" title="挂载新磁盘"></a>挂载新磁盘</h2><h3 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h3><ul>
<li><p>关闭虚拟机，在virtualbox管理器界面中右键虚拟机选择 </p>
<p>设置——存储——SATA——添加虚拟硬盘——选择VDI——选择固定大小——选择文件位置和磁盘大小——选择新加的磁盘空间</p>
</li>
</ul>
<h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><ul>
<li><p>打开虚拟机，检查硬盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure>

<p>可以看到新的/dev/sdb，需要对这个磁盘进行分区</p>
</li>
<li><p>磁盘分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure>

<p>输入<code>m</code>进入帮助</p>
<p>输入<code>n</code>添加分区</p>
<p>输入<code>p</code>添加主分区</p>
<p>后续可以直接回车，使用默认值来创建分区数量等</p>
<p>输入<code>w</code>保存退出</p>
<p>检查分区是否创建成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fdisk -l</span><br></pre></td></tr></table></figure></li>
<li><p>格式化磁盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkfs.ext4 /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>会有 done 或者 完成 的输出提示</p>
</li>
<li><p>创建挂载点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir &lt;path&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>挂载硬盘（/dev/sdb1 需要替换为自己的硬盘路径）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount /dev/sdb1 &lt;path&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>自动挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/fstab</span><br><span class="line"><span class="comment"># 文件末尾添加</span></span><br><span class="line">/dev/sdb &lt;path&gt; ext4 defaults 0 0</span><br></pre></td></tr></table></figure></li>
<li><p>卸载硬盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> umount &lt;path&gt;</span><br><span class="line"><span class="comment"># 删除/etc/fstab中添加的内容</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>上述格式化和挂载的操作也可以通过Ubuntu中的disk磁盘应用来进行可视化操作，点击选项按钮进行设置</p>
<p>但是在我的机子中，挂载成功后，在复制文件到新磁盘的过程中瞬间就用完了200G，导致虚拟机直接崩溃（后续猜测可能和当时的快照操作以及可视化的磁盘操作有关）</p>
<h2 id="原磁盘扩容"><a href="#原磁盘扩容" class="headerlink" title="原磁盘扩容"></a>原磁盘扩容</h2><h3 id="VirtualBox-1"><a href="#VirtualBox-1" class="headerlink" title="VirtualBox"></a>VirtualBox</h3><ul>
<li><p>关闭虚拟机，在virtualbox管理器界面中右键虚拟机选择 </p>
<p>管理——虚拟介质管理——选择扩容磁盘——修改大小</p>
</li>
<li><p>列出所有虚拟磁盘</p>
<p>cmd到VirtualBox的安装目录，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VBoxManage listt hdds</span><br></pre></td></tr></table></figure>

<p>查看所有的虚拟硬盘，并找到需要扩容的虚拟硬盘</p>
</li>
<li><p>输入命令进行扩容（单位是MB）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VBoxManage modify <span class="string">&quot;扩容磁盘路径&quot;</span> --resize 256000</span><br><span class="line">或者</span><br><span class="line">VBoxManage modify <span class="string">&quot;扩容磁盘UUID&quot;</span> --resize 256000</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>这里有一个需要注意的点</p>
<p>如果有快照的话，还需要修改备份快照的vdi大小，因为Ubuntu启动时使用的快照vdi文件</p>
<p>另外，这种分配的方式应该是属于动态分配存储方式</p>
</blockquote>
<h3 id="Ubuntu-1"><a href="#Ubuntu-1" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><ul>
<li><p>打开虚拟机，在应用中搜索disk，找到磁盘并打开</p>
</li>
<li><p>选择扩容的磁盘，应该可以看到扩容后的剩余空间，直接左键选项按钮，点击<code>调整大小...</code></p>
</li>
<li><p>弹出界面 调整卷大小，然后选择调整你想要的大小</p>
</li>
<li><p>最后在终端执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fdisk -l /dev/sda</span><br></pre></td></tr></table></figure>

<p>完成对sda的扩容</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda命令和环境</title>
    <url>/2021/07/22/Anaconda/Anaconda%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="Anaconda命令和环境"><a href="#Anaconda命令和环境" class="headerlink" title="Anaconda命令和环境"></a>Anaconda命令和环境</h1><h2 id="conda常用命令"><a href="#conda常用命令" class="headerlink" title="conda常用命令"></a>conda常用命令</h2><ul>
<li>创建一个名为xuedue的环境，指定Python版本是3.6(优先寻找3.6.x的最新版本), 这里的–name可以简化为-n<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create --name xuedue python=3.6  </span><br></pre></td></tr></table></figure></li>
<li>安装好后，使用activate激活某个环境<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> activate xuedue </span><br></pre></td></tr></table></figure></li>
<li>如果想返回普通环境，运行<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>(conda) deactivate</span><br></pre></td></tr></table></figure></li>
<li>删除一个已有的环境<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda remove --name xuedue --all</span><br></pre></td></tr></table></figure></li>
<li>复制一个已有的环境<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n xuedue_clone --<span class="built_in">clone</span> xuedue</span><br></pre></td></tr></table></figure></li>
<li>查看已经安装的环境<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda info --<span class="built_in">env</span></span><br></pre></td></tr></table></figure></li>
<li>conda安装scipy<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install scipy</span><br></pre></td></tr></table></figure></li>
<li>查看已经安装的packages<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></li>
<li>查看某个指定环境的已安装包<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda list -n xuedue</span><br></pre></td></tr></table></figure></li>
<li>查找package信息<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda search numpy</span><br></pre></td></tr></table></figure></li>
<li>安装某个指定环境的package(如果不用-n指定环境名称，则被安装在当前活跃环境，也可以通过-c指定通过某个channel安装)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -n xuedue numpy</span><br></pre></td></tr></table></figure></li>
<li>更新package<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda update -n xuedue numpy</span><br></pre></td></tr></table></figure></li>
<li>删除package<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda remove -n xuedue numpy</span><br></pre></td></tr></table></figure></li>
<li>使用yaml文件配置环境<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> create -f example.yml</span><br></pre></td></tr></table></figure>
<h2 id="anaconda-prompt中cd命令不起作用"><a href="#anaconda-prompt中cd命令不起作用" class="headerlink" title="anaconda prompt中cd命令不起作用"></a>anaconda prompt中cd命令不起作用</h2>conda prompt 中cd命令只能在同一个盘下进行切换路径，而不能切换到其他盘  </li>
<li>方法一：先输入要进入的盘，再使用cd命令  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">e:</span><br><span class="line"><span class="built_in">cd</span> xxx\xxx</span><br></pre></td></tr></table></figure></li>
<li>方法二：添加/d  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d e:\xxx\xxx</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Anaconda</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Android</title>
    <url>/2021/08/12/Android/Android-Q&amp;A/</url>
    <content><![CDATA[<h1 id="Android-Studio完全卸载"><a href="#Android-Studio完全卸载" class="headerlink" title="Android Studio完全卸载"></a>Android Studio完全卸载</h1><ol>
<li>在安装目录中找到uninstall，然后卸载整个安装文件夹</li>
<li>找到Android SDK安装目录，手动删除</li>
<li>在用户文件夹中（如C:Users/yourname/) 找到”.android”, “.AndroidStudioX.X”, “.gradle”等文件夹（如果有的话，一般进行第一步的时候也会同时删除）</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++知识点整理</title>
    <url>/2021/07/22/C%E8%AF%AD%E8%A8%80/C&amp;C++%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="C-关键词"><a href="#C-关键词" class="headerlink" title="C++关键词"></a>C++关键词</h1><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul>
<li>指向常量的指针<br>int const *p;<br>const int *p;  </li>
<li>指针本身是常量<br>int *const p;<br>分辨:从右往左看，看const离谁近  </li>
<li>const修饰成员函数<br>void func() const{} 常成员函数，可以使用类中的所有成员变量，但是不能修改它们，一般用于返回成员变量；</li>
</ul>
<h2 id="define-预处理阶段"><a href="#define-预处理阶段" class="headerlink" title="define(预处理阶段)"></a>define(预处理阶段)</h2><p>  define 在预处理阶段进行替换<br>  define函数<br>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">define <span class="title">add</span><span class="params">(a,b)</span> </span>&#123;a++; b++; cout&lt;&lt;a+b&lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="inline-编译阶段"><a href="#inline-编译阶段" class="headerlink" title="inline(编译阶段)"></a>inline(编译阶段)</h2><p><strong>内联函数和普通函数的区别</strong>：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。  </p>
<ul>
<li>优点: 有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。</li>
<li>缺点: <ul>
<li>使用内联函数会使最终可执行程序的体积增加。以空间换时间，或增加空间消耗来节省时间，这是计算机学科中常用的方法; </li>
<li>inline造成代码膨胀会导致额外的换页行为，降低指令高速缓存装置的命中率，以及伴随这些而来的效率降低。——-摘自effective</li>
</ul>
</li>
</ul>
<p>内联函数中的代码应该只是很简单、执行很快的几条语句。如果一个函数较为复杂，它执行的时间可能上万倍于函数调用的额外开销，那么将其作为内联函数处理的结果是付出让代码体积增加不少的代价，却只使速度提高了万分之一，这显然是不划算的。</p>
<p><strong>内联函数和宏的区别</strong>：宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的，而且内联函数是真正的函数。</p>
<p>Q: 类中的构造函数和析构函数可以是内联的吗？<br>A: 你当然可以将其声明为内联的，因为你有权利向编译器建议任何函数为内联的。哈哈，当然我们应该换一种问法，类中的构造函数和析构函数适合作为内联函数吗？effective里面说，构造函数和析构函数往往是inlining的糟糕候选人。因为编译器在编译期间会给你的构造函数和析构函数额外加入很多的代码，像成员函数的构造析构等代码，所以通常构造析构函数比表面上看起来的要多，并不适合作为内联函数。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ol>
<li><p><strong>全局静态变量</strong><br>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。<br>静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
</li>
<li><p><strong>局部静态变量</strong><br>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。<br>内存中的位置：静态存储区<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
</li>
<li><p><strong>静态函数</strong><br>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在<strong>声明他的文件当中可见，不能被其他文件所用</strong>。<br>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；<br>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
</li>
<li><p><strong>类的静态成员</strong><br>static修饰的变量先于对象存在，所以<strong>static修饰的变量要在类外初始化</strong>。因为static是所有对象共享的东西嘛，必须要比对象先存在的。<strong>初始化不受private和protected访问限制</strong>，但是若是private，下面main函数就无法访问。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i; <span class="comment">//声明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Test::i = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>:&#123;</span></span><br><span class="line">  cout&lt;&lt;Test::i&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通常，非static数据成员存在于类类型的每个对象中。然而，static数据成员<strong>独立于该类的任意对象而存在</strong>；每个static数据成员是<strong>与类关联的对象，而不是与该类的对象相关联</strong>。<br> static数据成员定义：  </p>
<ul>
<li>一般情况下，static数据成员是类内声明，类外定义;</li>
<li>static成员不通过类构造函数初始化，而是在定义时进行初始化；</li>
<li>一个例外：初始化式为常量表达式，整型static const 数据成员（static const int） 可以在类的定义体内进行初始化：</li>
</ul>
</li>
<li><p><strong>类的静态函数</strong><br>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。<br>在静态成员函数的实现中<strong>不能直接引用类中说明的非静态成员</strong>（没有this指针），<strong>可以引用类中说明的静态成员</strong>（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);<br>注意：类的<strong>非static成员函数</strong>是可以直接访问类的<strong>static和非static成员</strong>，而不用作用域操作符。<br>使用static成员的优点：  </p>
<ul>
<li>避免命名冲突：static成员的名字在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突。</li>
<li>可以实施封装：static成员可以是私有成员，而全局对象不可以。</li>
<li>易读性：static成员是与特定类关联的，可显示程序员的意图。</li>
</ul>
</li>
</ol>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>extern有两个作用: </p>
<ol>
<li>extern “C”:当它与”C”一起连用时，如: extern “C” void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的”脾气”了(不同的编译器采用的方法不一样)</li>
<li>extern:当extern不与”C”在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是<strong>声明函数或全局变量的作用范围</strong>的关键字，其声明的函数和变量可以在本模块或其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>定义为volatile的变量是说这变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确的处理，每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取，比如读取缓存在寄存器中的数值，从而保证volatile变量被正确的读取。</p>
<h1 id="C-模板以及底层实现"><a href="#C-模板以及底层实现" class="headerlink" title="C++模板以及底层实现"></a>C++模板以及底层实现</h1><ol>
<li>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行<strong>两次编译</strong>：在<strong>声明的地方</strong>对模板代码本身进行编译，在<strong>调用的地方</strong>对参数替换后的代码进行编译。</li>
<li>这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</li>
</ol>
<h1 id="include-“”和include-lt-gt-区别"><a href="#include-“”和include-lt-gt-区别" class="headerlink" title="include “”和include&lt;&gt;区别"></a>include “”和include&lt;&gt;区别</h1><ul>
<li>include “”查找头文件路径顺序<br>当前头文件目录(比如D:\MyProjects\tmp\ )<br>编译器设置的头文件路径(编译器可使用-I显式指定搜索路径)(比如C:\Keil\c51\INC\ )<br>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径  </li>
<li>include&lt;&gt;查找头文件的路径顺序为：<br>编译器设置的头文件路径(编译器可使用-I显式指定搜索路径)<br>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</li>
</ul>
<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ol>
<li>指针有自己的一块空间，而引用只是一个别名；</li>
<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>
<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；</li>
<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</li>
<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</li>
<li>指针可以有多级指针（**p），而引用只有一级；</li>
<li>指针和引用使用++运算符的意义不一样(一个指针本身的大小是4字节)； <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p1,<span class="type">double</span>* p2;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>,<span class="type">double</span> b=<span class="number">2</span>;</span><br><span class="line">p1=&amp;a,p2=&amp;b;</span><br><span class="line">cout&lt;&lt;p1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p2&lt;&lt;endl;</span><br><span class="line">p1++;	p2++;</span><br><span class="line"><span class="comment">//指向的内存空间+1，所以和类型有关，第一个+4，第二个+8</span></span><br><span class="line">cout&lt;&lt;p1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p2&lt;&lt;endl;	</span><br><span class="line"><span class="comment">//本身内存空间+1，所以两个地址值都是+4</span></span><br><span class="line">cout&lt;&lt;(&amp;p1<span class="number">+1</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(&amp;p2<span class="number">+1</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="调用赋值构造函数还是拷贝（复制）构造函数的情况（历史悠久，还没理清）"><a href="#调用赋值构造函数还是拷贝（复制）构造函数的情况（历史悠久，还没理清）" class="headerlink" title="调用赋值构造函数还是拷贝（复制）构造函数的情况（历史悠久，还没理清）"></a>调用赋值构造函数还是拷贝（复制）构造函数的情况（历史悠久，还没理清）</h1><p>总结，还没初始化的调用拷贝构造函数，已经初始化过的调用赋值构造函数。</p>
<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funtion</span><span class="params">()</span> </span>&#123;函数体&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funtion</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>虚函数，在基类声明，在其派生类中根据需要进行重写(不需要可以不重写，继承基类的虚函数)。<br>而声明纯虚函数的类为抽象类，不可定义对象，由其派生的子类想要使用该虚函数，必须重新实现该虚函数，不会自动继承抽象类的虚函数。有纯虚函数的类为抽象类，不能定义抽象类的对象，它的子类要么实现它所有的纯虚函数变为一个普通类，要么还是一个抽象类。</p>
<h1 id="虚函数实现"><a href="#虚函数实现" class="headerlink" title="虚函数实现"></a>虚函数实现</h1><p>虚函数表：类的虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址。</p>
<p>编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。类的每个虚函数占据虚函数表中的一块。如果类中有N个虚函数，那么其虚函数表将有N*4字节的大小。</p>
<p>虚函数表是在编译阶段创建，运行时动态绑定虚函数</p>
<p>编译器另外还为每个特定类的对象提供了一个虚表指针（即vptr），这个指针指向了对象所属类的虚表。在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向所属类的虚表，从而在调用虚函数时，就能够找到正确的函数。</p>
<ol>
<li>一个类中的某个方法被声明为虚函数，则它将放在虚函数表中。</li>
<li>当一个类继承了另一个类，就会继承它的虚函数表，虚函数表中所包含的函数，如果在子类中有重写，则指向当前重写的实现，否则指向基类实现。若在子类中定义了新的虚函数，则该虚函数指针在虚函数表的后面。</li>
<li>在继承或多级继承中，要用一个祖先类的指针调用一个后代类实例的方法，若想体现出多态，则必须在该祖先类中就将需要的方法声明为虚函数，否则虽然后代类的虚函数表中有这个方法在后代类中的实现，但对祖先类指针的方法调用依然是早绑定的。</li>
</ol>
<p>有虚函数或虚继承的类实例化后的对象大小至少为4字节（确切的说是一个指针的字节数；说至少是因为还要加上其他非静态数据成员，还要考虑对齐问题）；没有虚函数和虚继承的类实例化后的对象大小至少为1字节（没有非静态数据成员的情况下也要有1个字节来记录它的地址）。</p>
<h1 id="构造函数能否使用虚函数，析构函数呢"><a href="#构造函数能否使用虚函数，析构函数呢" class="headerlink" title="构造函数能否使用虚函数，析构函数呢"></a>构造函数能否使用虚函数，析构函数呢</h1><ul>
<li>构造函数<strong>不能</strong>为虚函数：构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；但是构造函数中可以调用虚函数，不过并没有动态效果，只会调用本类中的对应函数；</li>
<li>析构函数<strong>可以</strong>为虚函数：对象已经创建，虚表指针存放析构函数的地址，基类与派生类都含有析构虚函数，创建基类与子类对象，都含有各类的虚表指针，当写通用函数时，运行根据传入对象的类型确定析构函数的地址，然后调用该析构函数。<br>析构函数可以是纯虚函数，但是必须提供纯虚析构函数的定义。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">awov</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">awov</span>() = <span class="number">0</span>; <span class="comment">// 声明一个纯虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line">awov::~<span class="built_in">awov</span>() &#123;&#125; <span class="comment">// 纯虚析构函数的定义</span></span><br></pre></td></tr></table></figure>
这个定义是必需的，因为虚析构函数工作的方式是：最底层的派生类的析构函数最先被调用，然后各个基类的析构函数被调用。这就是说，即使是抽象类，编译器也要产生对~awov的调用，所以要保证为它提供函数体。如果不这么做，链接器就会检测出来，最后还是得回去把它添上.</li>
</ul>
<h1 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h1>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC</title>
    <url>/2026/01/18/C%E8%AF%AD%E8%A8%80/GCC/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Linux 下最常用的 C 编译器是 GCC，大多数发行版本都默认安装了 GCC。我们可以用以下 GCC 命令，把 test.c 编译成可执行文件 <code>test</code>：<code>gcc -g test.c -o test</code>。</p>
<p>如果大家习惯了 Visual Studio 等集成开发环境的话，会觉得上述的命令很费解。但掌握 GCC 等工具的用法，是一个程序员所必备的技能。</p>
<p>回到上面的 GCC 命令，它的作用是编译源文件 <code>test.c</code> 并生成可执行文件。其中 <code>-o</code> 表示生成的可执行文件名为 <code>test</code>，<code>-g</code> 表明要在可执行文件中添加调试信息。如果要使用 GDB 单步调试程序，必须使用 <code>-g</code> 参数。</p>
<p>可以看到，GCC 的行为是通过命令行参数进行指定的。所以，要掌握 GCC，重点在于熟悉 GCC 的各种参数上。但 GCC 的参数实在太多了，所以更普遍的做法是掌握其常用参数，并在遇到不认识的参数时多查资料进行学习。</p>
<h2 id="GCC-的常用参数"><a href="#GCC-的常用参数" class="headerlink" title="GCC 的常用参数"></a>GCC 的常用参数</h2><p><strong>-c</strong></p>
<p>作用：只对源文件进行编译操作。</p>
<p>例子: <code>gcc -c test.c</code></p>
<p>说明：这将生成目标文件（object file）test.o。</p>
<p><strong>-E</strong></p>
<p>作用：只对源文件进行预处理操作。</p>
<p>例子: <code>gcc -E test.c &gt; test.pre</code></p>
<p><strong>-o</strong></p>
<p>作用：指定输出文件（目标文件或者可执行文件）的文件名。</p>
<p>例子：<code>gcc test.c -o test</code></p>
<p>说明：指定可执行文件的文件名为 <code>test</code>，否则默认为 <code>a.out</code>。</p>
<p><strong>-D</strong></p>
<p>作用：定义一个宏。</p>
<p>例子：<code>gcc test.c -o test –DBIG_ENDIAN</code></p>
<p>说明：这和我们在源代码中加入语句 <code>#define BIG_ENDIAN</code> 的效果是一样的。</p>
<p><strong>-M</strong></p>
<p>作用：生成目标文件的依赖信息。</p>
<p>例子：执行 <code>gcc -M test.c</code>，输出结果如下所示。这表明要编译出目标文件 <code>test.o</code>，必须依赖源文件 <code>test.c</code>以及一堆的头文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.o: test.c/usr/include/stdio.h/usr/include/features.h \</span><br><span class="line"></span><br><span class="line">/usr/include/sys/cdefs.h/usr/include/gnu/stubs.h \</span><br><span class="line"></span><br><span class="line">/usr/lib/gcc/i386-redhat-linux/3.4.3/include/stddef.h \</span><br><span class="line"></span><br><span class="line">/usr/include/bits/types.h/usr/include/bits/wordsize.h \</span><br><span class="line"></span><br><span class="line">/usr/include/bits/typesizes.h/usr/include/libio.h \</span><br><span class="line"></span><br><span class="line">/usr/include/_G_config.h \</span><br><span class="line"></span><br><span class="line">/usr/include/wchar.h/usr/include/bits/wchar.h \</span><br><span class="line"></span><br><span class="line">/usr/include/gconv.h \</span><br><span class="line"></span><br><span class="line">/usr/lib/gcc/i386-redhat-linux/3.4.3/include/stdarg.h \</span><br><span class="line"></span><br><span class="line">/usr/include/bits/stdio_lim.h/usr/include/bits/sys_errlist.h</span><br></pre></td></tr></table></figure>

<p>说明：大家要记住 “依赖（dependency）” 这个新名词。在学习 Makefile 时，这个名词还会不断出现。</p>
<p><strong>-O0/-O1/-O2/-O3</strong></p>
<p>作用：O 是大写的英文字母 <code>o</code>，对应 <code>Optimization</code>。它指定编译器的优化选项，<code>-O0</code> 表示没有优化，<code>-O1</code> 为缺省值，<code>-O3</code> 优化级别最高。</p>
<p>例子：无</p>
<p>说明：只有对代码进行反汇编，我们才能看到这四个编译选项之间的差异。比如内联函数，在 <code>-O0</code> 作用下和普通函数无任何区别，仍需要显示调用；但在其他优化级别下，内联函数就会被直接嵌入被调用处。</p>
<p><strong>-g</strong></p>
<p>作用：<code>-g</code> 表明要在可执行文件中添加调试信息。如果要使用 GDB 单步调试程序，必须使用 <code>-g</code> 参数。</p>
<p>例子：无</p>
<p>说明：无</p>
<p>小结：上面只是列举了 gcc 的一小部分参数。如果在实际工作中遇到你不认识的参数，多使用 <code>man gcc</code> 命令学习。</p>
<h2 id="ld、objdump、strip"><a href="#ld、objdump、strip" class="headerlink" title="ld、objdump、strip"></a>ld、objdump、strip</h2><p>以下简单介绍其他常用的编译、链接工具。在实际工作中，接触它们的机会相对较少，这里只作简单介绍。</p>
<p>ld：负责链接工作。较常用。</p>
<p>objdump：对目标文件和可执行文件进行反汇编。较常用。</p>
<p>例子：<code>objdump –D test &gt; test.S</code></p>
<p>strip：含义为 symbol table rip，它会删除目标文件或可执行文件中的符号表，在精简可执行文件的体积时会用到。</p>
<p>readelf：读取 elf 文件，并列出其详细信息，较少使用。</p>
<h2 id="库依赖"><a href="#库依赖" class="headerlink" title="库依赖"></a>库依赖</h2><p>有时候我们的代码要依赖标准库以外的库函数，如果库文件不在默认路径下，要显式地指明头文件/库文件的路径：</p>
<p>头文件用 <code>-I</code>；</p>
<p>库文件用 <code>-L</code>，用 <code>-l</code> 指明要寻找的库，例如引用 <code>libcurl.so</code>，则加上 <code>-lcurl</code></p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -I /home/curl/include -o test.o</span><br><span class="line"></span><br><span class="line">gcc test.c -L /home/curl/lib -lcurl o test.o</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB简介</title>
    <url>/2026/01/18/C%E8%AF%AD%E8%A8%80/GDB%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GDB，又称 GNU 调试器，是用来帮助调试我们程序的工具。</p>
<p>GDB有如下两种使用方式</p>
<ol>
<li>调试会崩溃、有逻辑错误的程序；</li>
<li>调试程序崩溃时自动生成的 core dump；</li>
</ol>
<p>GDB 可以干以下几件事：</p>
<ol>
<li>给程序设置（特定条件下的）断点，包括某块内存的内容改变时触发断点，如果某个变量不知被哪段代码意外篡改了，可以使用 GDB 打数据断点抓到肇事者。</li>
<li>当程序停在断点处时，我们查看所有变量、寄存器的值</li>
<li>当程序停在断点处时，我们除了能查看所有变量的值以外，还能在不改变源代码的情况下改变这些值</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdb</span><br></pre></td></tr></table></figure>



<h2 id="编译被测程序"><a href="#编译被测程序" class="headerlink" title="编译被测程序"></a>编译被测程序</h2><p>被测程序需修改 Makefile，将 <code>CFLAGS</code> 添加 <code>-O0 -g</code> 重新编译并且保证不去符号。如果不加 <code>-g</code> ，gdb 加载后将提示 <code>No symbol table is loaded</code>。缺少调试信息，调试起来会比较麻烦。</p>
<p>如果不使用 <code>-O0</code> 而是<code>-O1</code>、 <code>-O2</code>、<code>-O3</code>，代码优化后，给调试带来难度。</p>
<p>make 编译时，后面需要加 <code>STRIP=/bin/true</code>，当然如果 Makefile 里没有调用 strip 去符号，可以不用加。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time make -j STRIP=/bin/true</span><br></pre></td></tr></table></figure>



<h2 id="加载被测程序"><a href="#加载被测程序" class="headerlink" title="加载被测程序"></a>加载被测程序</h2><p>设被测程序名为 hello。</p>
<p>使用 gdb 运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb ./hello</span><br><span class="line"></span><br><span class="line">Reading symbols from ./hello... # 如果未输出此行，则说明 hello 没有加 -g 编译</span><br></pre></td></tr></table></figure>



<h2 id="普通断点"><a href="#普通断点" class="headerlink" title="普通断点"></a>普通断点</h2><p>在 main 函数打普通断点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b main</span><br></pre></td></tr></table></figure>

<p>然后运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br></pre></td></tr></table></figure>

<p>运行到 main 函数时程序暂停。</p>
<h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><p>顾名思义，这种断点是当满足一定条件时才会触发，比较适合进行异常排查。设置方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b line-or-function if (condition)</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b src/main.cpp:127 if count==10</span><br></pre></td></tr></table></figure>



<h2 id="监视"><a href="#监视" class="headerlink" title="监视"></a>监视</h2><p>设置监视也必须是在程序运行后才行。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) watch *地址    # 当地址所指内容发生变化时断点</span><br><span class="line">(gdb) watch var    # 当 var 值变化时，断点</span><br><span class="line">(gdb) watch (condition)    # 当条件符合时，断点</span><br></pre></td></tr></table></figure>

<p>监视也被称为硬件断点。可以监测栈变量和堆变量值的变化，当被监测变量值发生变化时，程序被停住。</p>
<h2 id="调试-coredump"><a href="#调试-coredump" class="headerlink" title="调试 coredump"></a>调试 <strong>coredump</strong></h2><p>coredump 叫做核心转储，它是进程运行时在突然崩溃的那一刻的一个内存快照。操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下，会把进程此刻内存、寄存器状态、运行堆栈等信息转储保存在一个文件里。</p>
<p>该文件也是二进制文件，可以使用 gdb、elfdump、objdump 进行打开分析里面的具体内容。</p>
<p><strong>ulimit</strong></p>
<p>虽然我们知道进程在 coredump 的时候会产生core文件，但是有时候却发现进程虽然崩溃了，但是我们却找不到coredump 文件。</p>
<p>在 Linux 下是需要进行设置的。</p>
<p><code>ulimit -c</code> 可以设置core文件的大小，如果这个值为0.则不会产生core文件，这个值太小，则 core 文件也不会产生，因为core文件一般都比较大。</p>
<p>使用<code>ulimit -c unlimited</code> 来设置无限大，则任意情况下都会产生 core 文件。Ubuntu 18.04，coredump会默认产生在以下目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/lib/apport/coredump/</span><br></pre></td></tr></table></figure>

<p><strong>gdb 分析 coredump 的简单示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void dumpCrash()</span><br><span class="line">&#123;</span><br><span class="line">    char *pStr = &quot;test_content&quot;;</span><br><span class="line">    free(pStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    dumpCrash();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码，pStr 指针指向的是字符串常量，字符串常量是保存在常量区的，free 释放常量区的内存肯定会导致coredump。</p>
<p>首先把上面的代码保存为 dumpTest.c 文件，gcc 编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc dumpTest.c -o dumpTest</span><br></pre></td></tr></table></figure>

<p>设置 core 文件大小为无限制大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure>

<p>运行 dumpTest 产生 core 文件。</p>
<p><strong>gdb 调试 coredump 初步尝试</strong></p>
<p>gdb打开 core 文件的格式为</p>
<p>gdb 程序名(包含路径) core*（core文件名和路径）</p>
<p>gdb 打开 core 文件时，有显示没有调试信息，因为之前编译的时候没有带上 <code>-g</code> 选项，没有调试信息是正常的，实际上它也不影响调试 core 文件。因为调试 core 文件时，符号信息都来自符号表，用不到调试信息。</p>
<p><strong>查看 coredump 时的堆栈</strong></p>
<p>查看堆栈使用 bt 或者 where 命令。</p>
<p>在带上调试信息的情况下，我们实际上是可以看到 core 的地方和代码行的匹配位置。</p>
<p>但往往正常发布环境是不会带上调试信息的，因为调试信息通常会占用比较大的存储空间，一般都会在编译的时候把 <code>-g</code> 选项去掉。</p>
<p>没有调试信息的情况下，打开 coredump 堆栈，并不会直接显示 core 的代码行。</p>
<p>此时只能通过 disassemble 命令打开该帧函数的反汇编代码进行分析。具体的分析方法后续再补充完善。</p>
<p>在实际问题中，C 程序的很多 coredump 问题都是和指针相关的，很多 segmentfault 都是由于指针被误删或者访问空指针、或者越界等造成的。</p>
<h2 id="多进程调试"><a href="#多进程调试" class="headerlink" title="多进程调试"></a>多进程调试</h2><blockquote>
<p><strong>提示</strong></p>
<p>在入职培训之初的 C 语言作业，不涉及多进程，下面的内容简单浏览，有个印象即可。后续正式开发工作中可能需要使用。</p>
</blockquote>
<p>gdb调试多进程的命令：</p>
<p><code>set follow-fork-mode mode</code> 设置调试器的模式</p>
<p>mode 参数可以是</p>
<p>parent: fork之后调试原进程，子进程不受影响，这是缺省的方式</p>
<p>child: fork之后调试新的进程，父进程不受影响。</p>
<p><code>show follow-fork-mode</code> 显示当前调试器的模式</p>
<p><code>set detach-on-fork mode</code> 设置gdb在fork之后是否detach进程中的其中一个，或者继续保留控制这两个进程</p>
<p>on 子进程(或者父进程，依赖于follow-fork-mode的值)会detach然后独立运行，这是缺省的mode</p>
<p>off 两个进程都受gdb控制，一个进程（子进程或父进程，依赖于follow-fork-mode）被调试，另外一个进程被挂起</p>
<p><code>info inferiors</code> 显示所有进程</p>
<p><code>inferiors processid</code> 切换进程</p>
<p><code>detach inferiors processid</code> detach 一个由指定的进程，然后从fork 列表里删除。这个进程会被</p>
<p>允许继续独立运行。</p>
<p><code>kill inferiors processid</code> 杀死一个由指定的进程，然后从fork 列表里删除。</p>
<p>catch fork 让程序在fork，vfork或者exec调用的时候中断</p>
<h2 id="调试范例"><a href="#调试范例" class="headerlink" title="调试范例"></a>调试范例</h2><h3 id="范例1"><a href="#范例1" class="headerlink" title="范例1"></a>范例1</h3><p>编译并构建程序，加上调试选项 -g，若为 make 构建，修改 Makefile 的 CFLAGS。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -g main.c -o test.out</span><br></pre></td></tr></table></figure>

<p>用 GDB 来运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb test.out</span><br></pre></td></tr></table></figure>

<p>在 main 函数入口处设置一个断点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b main</span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r</span><br></pre></td></tr></table></figure>

<p>不断按 <code>s</code> 单步运行到第N行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>查看 balance, rate, interest 变量的值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p balance</span><br><span class="line">p rate</span><br><span class="line">p interest</span><br></pre></td></tr></table></figure>



<h3 id="范例2"><a href="#范例2" class="headerlink" title="范例2"></a>范例2</h3><p>假设要调试程序 、/bin/hello 的wlanAC.c 中的 wacAddWhitelist() 函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/******************************************************************************</span><br><span class="line">* FUNCTION      :   wacAddWhitelist()</span><br><span class="line">* DESCRIPTION   :   添加一个站点设备MAC地址到白名单。</span><br><span class="line">* INPUT         :</span><br><span class="line">* OUTPUT        :   N/A</span><br><span class="line">* RETURN        :</span><br><span class="line">* HISTORY       :</span><br><span class="line">******************************************************************************/</span><br><span class="line">LOCAL int wacAddWhitelist(WAC_WHITELIST_ITEM *item)</span><br><span class="line">&#123;</span><br><span class="line">    int res = ERROR;</span><br><span class="line">    UINT32 index = 0;</span><br><span class="line"></span><br><span class="line">    if (NULL == item || INVALID_MAC(item-&gt;staMac))</span><br><span class="line">    &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 添加一个条目到白名单列表里。*/</span><br><span class="line">    WACLOCK(wacWhitelistMutex);</span><br><span class="line">    if (gWacWhitelist.count &lt; WAC_WHITELIST_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        /* 是否有重复添加的，没有则允许加入。*/</span><br><span class="line">        for (index = 0; index &lt; gWacWhitelist.count; index++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (0 == memcmp(gWacWhitelist.list[index].staMac, item-&gt;staMac, WAC_MAC_SIZE))</span><br><span class="line">            &#123;</span><br><span class="line">                WACUNLOCK(wacWhitelistMutex);</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memcpy(&amp;gWacWhitelist.list[gWacWhitelist.count], item, sizeof(WAC_WHITELIST_ITEM));</span><br><span class="line">        gWacWhitelist.count++;</span><br><span class="line">        res = OK;</span><br><span class="line">    &#125;</span><br><span class="line">    WACUNLOCK(wacWhitelistMutex);</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试图在变量 index 的值发生变化时触发断点，相关命令和输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@TDMP:~# gdb /bin/hello</span><br><span class="line">GNU gdb (GDB) 8.3.1</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;arm-brcm-linux-gnueabi&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from /bin/hello...</span><br><span class="line"></span><br><span class="line">(gdb) set detach-on-fork off  # 设置 gdb 在 fork 之后继续保留控制这两个进程</span><br><span class="line"></span><br><span class="line">(gdb) r  # 等效于 run 命令，开始运行</span><br><span class="line">Starting program: /bin/hello </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line">[New inferior 2 (process 5488)]</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line">[Inferior 1 (process 5485) exited normally]</span><br><span class="line"></span><br><span class="line">(gdb) info inferiors  # 显示所有进程</span><br><span class="line">  Num  Description       Executable        </span><br><span class="line">* 1    &lt;null&gt;            /bin/hello          </span><br><span class="line">  2    process 5488      /bin/hello  </span><br><span class="line"></span><br><span class="line">(gdb) inferior 2    # 切换到进程2</span><br><span class="line">[Switching to inferior 2 [process 5488] (/bin/hello)]</span><br><span class="line">[Switching to thread 2.1 (process 5488)]</span><br><span class="line">Reading symbols from /bin/hello...</span><br><span class="line">Reading symbols from /usr/lib/libjson.so.0...</span><br><span class="line">Reading symbols from /lib/libpthread.so.0...</span><br><span class="line">Reading symbols from /lib/libsecurity.so...</span><br><span class="line">Reading symbols from /usr/lib/libcyassl.so.5...</span><br><span class="line">Reading symbols from /usr/lib/libz.so.1...</span><br><span class="line">Reading symbols from /lib/libbcm_flashutil.so...</span><br><span class="line">Reading symbols from /lib/libbcm_boardctl.so...</span><br><span class="line">Reading symbols from /lib/libbcm_util.so...</span><br><span class="line">Reading symbols from /lib/libgen_util.so...</span><br><span class="line">Reading symbols from /lib/libsys_util.so...</span><br><span class="line">Reading symbols from /lib/libethswctl.so...</span><br><span class="line">Reading symbols from /lib/libc.so.6...</span><br><span class="line">Reading symbols from /lib/ld-linux.so.3...</span><br><span class="line">Reading symbols from /lib/libm.so.6...</span><br><span class="line">#0  0xf75ae2c8 in fork () from /lib/libc.so.6</span><br><span class="line"></span><br><span class="line">(gdb) b wacAddWhitelist # 等效于 break wacAddWhitelist， 在 wacAddWhitelist 函数开头打断点</span><br><span class="line">Breakpoint 1 at 0x2311c4: wacAddWhitelist. (2 locations)</span><br><span class="line"></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[New Thread 0xf73c3460 (LWP 22[  487.008626] gpio 17 request failed.</span><br><span class="line">14)]</span><br><span class="line">[New Th[  487.013850] gpio 10 request failed.</span><br><span class="line">......</span><br><span class="line">60 (LWP 2215)]</span><br><span class="line">[New Thread 0xf63c3460 (LWP 2216)]</span><br><span class="line">......</span><br><span class="line">[New Thread 0xf5bc3460 (LWP 2217)]</span><br><span class="line">......</span><br><span class="line">Can not resume the parent process over vfork in the foreground while</span><br><span class="line">holding the child stopped.  Try &quot;set detach-on-fork&quot; or &quot;set schedule-multiple&quot;.</span><br><span class="line"></span><br><span class="line">(gdb) bt  # 等效于 backtrace，打印栈回溯信息，可知在 vfork 处暂停</span><br><span class="line">#0  0xf75ae560 in vfork () from /lib/libc.so.6</span><br><span class="line">#1  0x0029ab14 in doSystemExec (cmdline=0x33bf84 &quot;insmod slp_gpio.ko&quot;, sync=1)</span><br><span class="line">    at systemOps.c:83</span><br><span class="line">#2  0x0029ad50 in systemExec (cmdline=0x33bf84 &quot;insmod slp_gpio.ko&quot;)</span><br><span class="line">    at systemOps.c:142</span><br><span class="line">#3  0x002917b4 in gpioInit () at gpio.c:215</span><br><span class="line">#4  0x002db7c8 in __libc_csu_init ()</span><br><span class="line">#5  0xf7528b08 in __libc_start_main () from /lib/libc.so.6</span><br><span class="line">#6  0x0003f2e4 in _start ()</span><br><span class="line">Backtrace stopped: previous frame identical to this frame (corrupt stack?)</span><br><span class="line"></span><br><span class="line">(gdb) set detach-on-fork on # 子进程(或者父进程，依赖于 follow-fork-mode 的值)会 detach 然后独立运行</span><br><span class="line"></span><br><span class="line">(gdb) c # 继续运行直到在 wacAddWhitelist 入口处暂停</span><br><span class="line">Continuing.</span><br><span class="line">......</span><br><span class="line">[Detaching after vfork from child process 4737]</span><br><span class="line"></span><br><span class="line">Thread 2.1 &quot;hello&quot; hit Breakpoint 2, wacAddWhitelist (item=0xfffefad8)</span><br><span class="line">    at wlanAC.c:98</span><br><span class="line">98     wlanAC.c: No such file or directory.</span><br><span class="line"></span><br><span class="line">(gdb) bt  ## 栈回溯显示确实是在 wacAddWhitelist 暂停</span><br><span class="line">#0  wacAddWhitelist (item=0xfffefad8) at wlanAC.c:98</span><br><span class="line">#1  0x00232740 in wacSyncWhitelistFromFlash () at wlanAC.c:631</span><br><span class="line">#2  0x00231838 in wacEnableOperation () at wlanAC.c:302</span><br><span class="line">#3  0x00233b34 in wacStart () at wlanAC.c:1034</span><br><span class="line">#4  0x002431e4 in ctrlModuleStart () at control.c:672</span><br><span class="line">#5  0x002436d0 in ctrlPowerOn () at control.c:895</span><br><span class="line">#6  0x002da9b0 in main (argc=1, argv=0xfffefe54) at main.c:103</span><br><span class="line"></span><br><span class="line">(gdb) watch index  # 设置当 index 变量发生变化时暂停</span><br><span class="line">Watchpoint 2: index</span><br><span class="line"></span><br><span class="line">(gdb) c  # 继续运行</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread 2.1 &quot;hello&quot; hit Watchpoint 5: index</span><br><span class="line"></span><br><span class="line">Old value = 4147980344</span><br><span class="line">New value = 0</span><br><span class="line">wacAddWhitelist (item=0xfffefad8) at wlanAC.c:101</span><br><span class="line">101    in wlanAC.c</span><br></pre></td></tr></table></figure>



<h2 id="GDB-常用命令"><a href="#GDB-常用命令" class="headerlink" title="GDB 常用命令"></a>GDB 常用命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r   直接调到断点处，没有设置断点的话直接运行程序</span><br><span class="line">b fun   设置一个断点breakpoint在函数”fun”的最开始</span><br><span class="line">b N     在当前运行源文件的第N行设置断点</span><br><span class="line">b file.c:N  在当前源文件file.c的第N行设置断点</span><br><span class="line">d N     删掉delete第N行的断点</span><br><span class="line">info break  显示所有断点信息</span><br><span class="line">c   继续(continue)运行程序，一直到下一个断点或程序结束</span><br><span class="line">f   运行直到当前函数(function)结束</span><br><span class="line">s   按step调试1行，会进入函数体</span><br><span class="line">s N     按step调试接下来的N行</span><br><span class="line">n   调试1行，与按s命令不同的是此处不进入函数体</span><br><span class="line">p var   输出(print)变量”var”的值</span><br><span class="line">set var=val     设置变量”var”的值</span><br><span class="line">bt  打印调用堆栈(stack trace)</span><br><span class="line">q   退出gdb</span><br></pre></td></tr></table></figure>



<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>以上为常见的调试命令，若需要更高级的技巧，可以参阅 GDB 官方参考资料：<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">https://sourceware.org/gdb/current/onlinedocs/gdb/</a></p>
<h2 id="GDB-的调试原理"><a href="#GDB-的调试原理" class="headerlink" title="GDB 的调试原理"></a>GDB 的调试原理</h2><p>参见 <a href="GDB%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86.md">GDB 的调试原理</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试原理</title>
    <url>/2026/01/18/C%E8%AF%AD%E8%A8%80/GDB%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章来聊聊大名鼎鼎的 GDB，它的豪门背景咱就不提了，和它的兄弟 GCC 一样是含着金钥匙出生的，在 GNU 的家族中的地位不可撼动。</p>
<p><img src="640.png" alt="图片"></p>
<p>我们都知道，在使用 GCC 编译时，可以使用 -g 选项在可执行文件中嵌入更多的调试信息，那么具体嵌入了哪些调试信息？这些调试信息是如何与二进制的指令之间进行相互交互？在调试的时候，调试信息中是如何获取函数调用栈中的上下文信息？</p>
<h2 id="GDB调试模型"><a href="#GDB调试模型" class="headerlink" title="GDB调试模型"></a>GDB调试模型</h2><p>GDB 调试包括 2 个程序：gdb 程序和被调试程序。根据这 2 个程序是否运行在同一台电脑中，可以把 GDB 的调试模型分为 2 种:</p>
<ol>
<li>本地调试</li>
<li>远程调试</li>
</ol>
<p>本地调试：调试程序和被调试程序运行在同一台电脑中。</p>
<p><img src="640-16586324307171.png" alt="图片"></p>
<p>远程调试：调试程序运行在一台电脑中，被调试程序运行在另一台电脑中。</p>
<p><img src="640-16586324307172.png" alt="图片"></p>
<p>关于可视化调试程序并不是重点，它只是一个用来封装 GDB 的外壳而已。我们既可以用黑乎乎的终端窗口来手动输入调试命令；也可以选择集成开发环境(IDE)，这个 IDE 中已经嵌入了器调试，这样就可以使用各种 button 来代替手动输入调试命令了。</p>
<p>与本地调试相比，远程调试中多了一个 GdbServer 程序，它和目标程序都是运行在目标机中，可能是一台 x86 电脑或者是一个 ARM 板子。图中的红线表示 GDB 与 GdbServer 之间通过网络或者串口进行通讯。既然是通讯，那么肯定需要一套通讯协议：RSP 协议，全称是：GDB Remote Serial Protocol (GDB 远程通信协议)。</p>
<p>关于通讯协议的具体格式和内容，我们不需要关心，只需要知道：它们都是字符串，有固定的开始字符(‘$’)和结束字符(‘#’)，最后还有两个十六进制的 ASCII 字符作为校验和，了解这么多就足够了。!</p>
<h2 id="GDB调试指令"><a href="#GDB调试指令" class="headerlink" title="GDB调试指令"></a>GDB调试指令</h2><p>为了完整性，这里把部分 GDB 调试指令贴一下，有感性认识即可。</p>
<p><img src="640-16586324307173.png" alt="图片"></p>
<p>另外，这里没有列举所有的指令，列出的指令都是常用的，比较容易理解。</p>
<p>每一个调试指令都有很多的命令选项，例如断点相关的就包括：设置断点、删除断点、条件断点、临时停用启用等等。这篇文章的重点是理解 gdb 底层的调试机制，所以应用层的这些指令的使用方法就不再列出了，可以阅读手册。</p>
<h2 id="GDB与被调试程序之间的关系"><a href="#GDB与被调试程序之间的关系" class="headerlink" title="GDB与被调试程序之间的关系"></a>GDB与被调试程序之间的关系</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123; </span><br><span class="line">    int a = 1;    </span><br><span class="line">    int b = 2;    </span><br><span class="line">    int c = a + b;    </span><br><span class="line"></span><br><span class="line">    printf(&quot;c = %d \n&quot;, c);    </span><br><span class="line"></span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>``</p>
<p>编译命令:</p>
<blockquote>
<p>$ gcc -g test.c -o test</p>
</blockquote>
<p>我们对可执行程序 test 进行调试，输入命令：</p>
<blockquote>
<p>$ gdb ./test</p>
</blockquote>
<p>输出如下：<img src="640-16586324307174.png" alt="图片"></p>
<p>在最后一行可以看到光标在闪烁，这是 gdb 程序在等着我们给它下达调试命令呢。</p>
<p>当上面这个黑乎乎的终端窗口在执行 gdb ./test 的时候，在操作系统里发生了很多复杂的事情：</p>
<p>系统首先会启动 gdb 进程，这个进程会调用系统函数 fork() 来创建一个子进程，这个子进程做两件事情：</p>
<ol>
<li>调用系统函数<code>ptrace(PTRACE_TRACEME，[其他参数])</code>；</li>
<li>通过 execc 来加载、执行可执行程序 test，那么 test 程序就在这个子进程中开始执行了。</li>
</ol>
<p><img src="640-16586324307175.png" alt="图片"></p>
<p>补充一点：文中有时称之程序，有时称之进程。“程序”描述的是一个静态的概念，就是一堆数据躺着硬盘上，而“进程”描述的是动态的过程，是这个程序被读取、加载到内存上之后，在操作系统中有一个任务控制块(一个数据结构)，专门用来管理这个进程的。</p>
<p>铺垫了半天，终于轮到主角登场了，那就是系统调用函数 ptrace（其中的参数后面会解释），正是在它的帮助下，gdb 才拥有了强大的调试能力。函数原型是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line"></span><br><span class="line">long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);</span><br></pre></td></tr></table></figure>

<p>我们先来看一下 man 中对这个函数的简介：</p>
<p><img src="640-16586324307176.png" alt="图片"></p>
<p>tracer 就是调试程序，可以理解为 gdb 程序；tracee 就是被调试程序，对应于图中的目标程序 test。一般喜欢用-er 和-ee 来表示主动和被动的关系。</p>
<p>ptrace 系统函数是 Linux 内核提供的一个用于进程跟踪的系统调用，通过它，一个进程(gdb)可以读写另外一个进程(test)的指令空间、数据空间、堆栈和寄存器的值。而且 gdb 进程接管了 test 进程的所有信号，也就是说系统向 test 进程发送的所有信号，都被 gdb 进程接收到，这样一来，test 进程的执行就被 gdb 控制了，从而达到调试的目的。</p>
<p>也就是说，如果没有 gdb 调试，操作系统与目标进程之间是直接交互的；如果使用 gdb 来调试程序，那么操作系统发送给目标进程的信号就会被 gdb 截获，gdb 根据信号的属性来决定：在继续运行目标程序时是否把当前截获的信号转交给目标程序，如此一来，目标程序就在 gdb 发来的信号指挥下进行相应的动作。</p>
<p><img src="640-16586324307187.png" alt="图片"></p>
<h2 id="GDB如何调试已经执行的服务进程"><a href="#GDB如何调试已经执行的服务进程" class="headerlink" title="GDB如何调试已经执行的服务进程"></a>GDB如何调试已经执行的服务进程</h2><p>是否有小伙伴会提出这样一个疑问：上面被调试的程序 test 是从头开始执行的，是否可以用 gdb 来调试一个已经处于执行中的服务进程呢？答曰：可以。这就涉及到 ptrace 系统函数的第一个参数了，这个参数是一个枚举类型的值，其中重要的是 2 个：PTRACE_TRACEME 和 PTRACE_ATTACH。</p>
<p>在上面的讲解中，子进程在调用 ptrace 系统函数时使用的参数是 PTRACE_TRACEME，注意橙色文字：是子进程调用 ptrace，相当于子进程对操作系统说：gdb 进程是我的爸爸，以后你有任何想发给我的信号，请直接发给 gdb 进程吧！</p>
<p>如果想对一个已经执行的进程 B 进行调试，那么就要在 gdb 这个父进程中调用 ptrace(PTRACE_ATTACH,[其他参数])，此时，gdb 进程会 attach(绑定)到已经执行的进程 B，gdb 把进程 B 收养成为自己的子进程，而子进程 B 的行为等同于它进行了一次 PTRACE_TRACEME 操作。此时 gdb 进程会发送 SIGSTO 信号给子进程 B，子进程 B 接收到 SIGSTOP 信号后，就会暂停执行进入 TASK_STOPED 状态，表示自己准备好被调试了。</p>
<p>所以，不论是调试一个新程序，还是调试一个已经处于执行中状态的服务程序，通过 ptrace 系统调用，最终的结果都是：gdb 程序是父进程，被调试程序是子进程，子进程的所有信号都被父进程 gdb 来接管，并且父进程 gdb 可查看、修改子进程的内部信息，包括：堆栈、寄存器等。</p>
<p>关于绑定，有几个限制需要了解一下：不予许自我绑定，不允许多次绑定到同一个进程，不允许绑定 1 号进程。</p>
<h2 id="偷窥GDB如何实现断点指令"><a href="#偷窥GDB如何实现断点指令" class="headerlink" title="偷窥GDB如何实现断点指令"></a>偷窥GDB如何实现断点指令</h2><p>大道理已经讲完了，这里我们通过设置断点(break)这个调试指令，来偷窥一下 gdb 内部的调试机制。还是以上面的代码为例子，这里再重新贴一下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    int c = a + b;</span><br><span class="line"></span><br><span class="line">    printf(&quot;c = %d \n&quot;, c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一下编译出来的反汇编代码是什么样的，编译指令：</p>
<blockquote>
<p>gcc -S test.c; cat test.S)</p>
</blockquote>
<p><img src="640-16586324307188.png" alt="图片"></p>
<p>这里只贴了一部分反汇编代码，只要能说明底层的原理就达到我们的目的了。</p>
<p>上面说到，在执行 gdb ./test 之后，gdb 就会 fork 出一个子进程，这个子进程首先调用 ptrace 然后执 test 程序，这样就准备好调试环境了。</p>
<p>我们把源码和汇编代码放在一起，方便理解：</p>
<p><img src="640-16586324307189.png" alt="图片"></p>
<p>在调试窗口输入设置断点指令“break 5”，此时 gdb 做 2 件事情：</p>
<ol>
<li>对第 5 行源码所对应的第 10 行汇编代码存储到断点链表中。</li>
<li>在汇编代码的第 10 行，插入中断指令 INT3，也就是说：汇编代码中的第 10 行被替换为 INT3。</li>
</ol>
<p><img src="640-165863243071810.png" alt="图片"></p>
<p>然后，在调试窗口继续输入执行指令“run”(一直执行，直到遇到断点就暂停)，汇编代码中 PC 指针(一个内部指针，指向即将执行的那行代码)执行第 10 行时，发现是 INT3 指令，于是操作系统就发送一个 SIGTRAP 信号给 test 进程。</p>
<p>此刻，第 10 行汇编代码被执行过了，PC 指针就指向第 11 行了。</p>
<p><img src="640-165863243071811.png" alt="图片"></p>
<p>上面已经说过，操作系统发给 test 的任何信号，都被 gdb 接管了，也就是说 gdb 会首先接收到这 SIGTRAP 个信号，gdb 发现当前汇编代码执行的是第 10 行，于是到断点链表中查找，发现链表中存储了第 10 行的代码，说明第 10 行被设置了断点。于是 gdb 又做了 2 个操作：</p>
<ol>
<li>把汇编代码中的第 10 行”INT3”替换为断点链表中原来的代码。</li>
<li>把 PC 指针回退一步，也即是设置为指向第 10 行。</li>
</ol>
<p>然后，gdb 继续等待用户的调试指令。</p>
<p><img src="640-165863243071812.png" alt="图片"></p>
<p>此刻，就相当于下一条执行的指令是汇编代码中的第 10 行，也就是源码中的第 5 行。从我们调试者角度看，就是被调试程序在第 5 行断点处暂停了下来，此时我们可以继续输入其他调试指令来 Debug，比如：查看变量值、查看堆栈信息、修改局部变量的值等等。</p>
<h2 id="偷窥GDB如何实现单步指令-next"><a href="#偷窥GDB如何实现单步指令-next" class="headerlink" title="偷窥GDB如何实现单步指令 next"></a>偷窥GDB如何实现单步指令 next</h2><p>还是以刚才的源代码和汇编代码为例，假设此时程序停止在源码的第 6 行，即汇编代码的第 11 行：</p>
<p><img src="640-165863243071813.png" alt="图片"></p>
<p>在调试窗口输入单步执行指令 next，我们的目的是执行一行代码，也就是把源码中第 6 行代码执行完，然后停止在第 7 行。gdb 在接收到 next 执行时，会计算出第 7 行源码，应该对应到汇编代码的第 14 行，于是 gdb 就控制汇编代码中的 PC 指针一直执行，直到第 13 行执行结束，也就是 PC 指向第 14 行时，就停止下来，然后继续等待用户输入调试指令。</p>
<p><img src="640-165863243071814.png" alt="图片"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 break 和 next 这 2 个调试指令，我们已经明白了 gdb 中是如何处理调试指令。当然，gdb 中的调试指令还有很多，包括更复杂的获取堆栈信息、修改变量的值等等，有兴趣的小伙伴可以继续深入跟踪。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 整理</title>
    <url>/2025/02/06/Github/Git%20%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="git-远程库"><a href="#git-远程库" class="headerlink" title="git 远程库"></a>git 远程库</h1><ul>
<li><p>代码推送至远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin HEAD:refs/for/sandbox/zengruihua/master</span><br></pre></td></tr></table></figure></li>
<li><p>远程最新的 commit 以 rebase 的方式同步到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure>
<p>使用命令时必须保持本地目录干净（不能有modified文件，可以存在untracked文件）</p>
</li>
<li><p>拉取远程库<br>要想有远程库信息，需要使用git clone</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 远程库 &amp;&amp; git cherry-pick FETCH_HEAD</span><br><span class="line">git fetch 远程库 &amp;＆ git checkout FETCH_HEAD</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure>

<p>此命令用于交互式添加修改到暂存区的命令。-p 代表 “patch”，允许用户选择要包含在下一次提交中的每个修改</p>
<ul>
<li><code>y</code>：表示将当前的修改添加到暂存区，即标记为要提交；</li>
<li><code>n</code>：表示不添加当前的修改到暂存区，即标记为不需要提交，跳过此次修改；</li>
<li><code>q</code>：表示退出当前的 <code>git add -p</code> 对话框；</li>
<li><code>a</code>: 表示添加当前和所有未列出的修改到暂存区，即全部标记为要提交；</li>
<li><code>d</code>: 表示不添加当前和所有未列出的修改到暂存区，即全部标记为不需要提交，跳过此次修改；</li>
<li><code>e</code>: 表示编辑当前修改，即便更好地确定所要提交的内容；</li>
<li><code>?</code>: 表示查看帮助信息，列出所有可用键和其含义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached &lt;文件路径&gt;</span><br></pre></td></tr></table></figure>

<p>从暂存区中删除 add 后的文件</p>
<h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure>

<p><code>--oneline</code>：表示只输出 git 提交说明的标题 （即提交说明的首行，我们约定，首行标题和正文之间必须空一行，否则 git 会将第二行之后也是为标题的一部分显示出来）</p>
<p><code>--decorate</code>：会连同 git tag 一起显示，这里还没创建 tag，所以加不加效果一样</p>
<p><code>--graph</code>：以分支图的形式显示 log, 这里因为只有一个分支，所以加不加效果一样</p>
<p><code>--all</code>: 是显示所有分支的 log</p>
<p>查找代码在哪个提交中被删除</p>
<ul>
<li>方法一  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -S <span class="string">&quot;代码&quot;</span> <span class="variable">$file_path</span></span><br></pre></td></tr></table></figure></li>
<li>方法二（手动）  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. git <span class="built_in">log</span> --oneline <span class="variable">$filepath</span> 得到所有commit，对所有 commit 执行：</span><br><span class="line">2. git show <span class="variable">$commit</span> <span class="variable">$file_path</span> &gt;&gt; tmp/yx</span><br><span class="line">3. 再在文件中搜索对应代码</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --hard 选项的作用就是保证在移动 HEAD 和分支指向的同事，让暂存区和工作去的内容和版本库（即 HEAD 指向的提交的目录树）一致）</span></span><br><span class="line">git reset --hard commitid(branch)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --soft 选项的效果只是移动 HEAD 和分支的指向，并不会改变暂存区和工作区。相当于直接把版本库回退，用于将多个提交压缩成一个提交</span></span><br><span class="line">git reset --soft commitid(branch)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --mixed 改变暂存区而不改变工作区，gti rsest --mixed commit 可以简写为  git resst commit，其也可以用于将多个提交压缩成一个提交，先 reset 回退若干提交，比 --soft，多了一步，需要先 git add 后才能 commit</span></span><br><span class="line">git reset --mixed commitid(branch)</span><br></pre></td></tr></table></figure>

<h1 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h1><ul>
<li><p>切换分支或者恢复工作树文件</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果是commitid就会使分离头指针</span></span><br><span class="line">git checkout commit(branch)</span><br></pre></td></tr></table></figure>
<p>  该命令在变更HEAD指向之外，同时会将工作区的内容修改成和HEAD指向（直接指向或者间接指向）的提交的树的内容一致）</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里的参数 pathspec 是特定文件，commit(branch)是特定文件所在的分支或提交</span></span><br><span class="line">git checkout commit(branch) pathspec</span><br></pre></td></tr></table></figure>
<p>  此命令带上指定路径，泽 HEAD 就不会移动了，即此操作不影响版本库。在实际工作中，我们使用带上 pathspec 选项的 git checkout 命令检出特定提交的文件到工作区，使用不带 pathspec 选项的 git checkout 命令切换分支。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &lt;start_point&gt; 省略相当于 &lt;start_point&gt;=HEAD?</span></span><br><span class="line">git checkout -b new_branch start_point</span><br></pre></td></tr></table></figure>
<p>  此命令是 git branch new_branch start_point 和 git checkout new_branch 两个命令的组合，相当于新建一个分支，并变更 HEAD 指向，同时会将工作区的内容修改成和HEAD指向一致</p>
</li>
<li><p>放弃修改</p>
<p>  放弃工作区全部的修改</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure>

<p>  放弃工作区中某个文件的修改</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git chekout --filename</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><p>配置 git diff 使用外部工具</p>
<p>…</p>
<p>取消配置 git diff 使用外部工具</p>
<ul>
<li><p>临时禁用外部 diff 工具，通过 –no-ext-diff 禁用外部 diff 工具</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff --no-ext-diff &lt;script.sh&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>永久禁用</p>
<ul>
<li><p>取消 GIT_EXTERNAL_DIFF 环境变量</p>
</li>
<li><p>执行 git config</p>
</li>
<li><p>git config –global –unset diff.external</p>
</li>
</ul>
</li>
</ul>
<p>命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 工作区和暂存区差异</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存区和版本库（HEAD）指向的提交的目录树</span></span><br><span class="line">git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作区和版本库</span></span><br><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure>

<h1 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="git commit –amend"></a>git commit –amend</h1><p>修补式提交</p>
<h1 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h1><p>应用提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick commit</span><br></pre></td></tr></table></figure>

<h1 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h1><p>如果要撤销的提交已经被合入远程版本库，那么就不能被reset或者rebase了，因为这会改变已入库的提交的历史，会改变团队共同工作的基准</p>
<blockquote>
<p>在实际工作中，我们一般使用 git revert 命令来撤销已经入库的提交。在提交未入库前，无必要使用此命令。使用其他的命令整理提交即可，git revert 是在提交已经被入库后而还想撤销时，不得已的做法。</p>
</blockquote>
<h1 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h1><p>可以查看提交的 git log</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show commit</span><br></pre></td></tr></table></figure>

<h1 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h1><p>重命名分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m old_branch new_branch</span><br></pre></td></tr></table></figure>

<p>强制移动分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -f branch_name newcommit</span><br></pre></td></tr></table></figure>

<h1 id="git-format-patch-生成-patch"><a href="#git-format-patch-生成-patch" class="headerlink" title="git format-patch (生成 patch)"></a>git format-patch (生成 patch)</h1><p>生成HEAD和HEAD^之间的patch（最近一次commit的patch）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git format-patch HEAD^ </span><br></pre></td></tr></table></figure>

<p>生成两个commit间的修改的patch（包含两个commit）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git format-patch &lt;commit id1&gt;..&lt;commit id2&gt;</span><br></pre></td></tr></table></figure>

<h1 id="git-apply-应用-patch"><a href="#git-apply-应用-patch" class="headerlink" title="git apply (应用 patch)"></a>git apply (应用 patch)</h1><blockquote>
<p>git apply 并不会将 commit message 等打上去，打完 patch 后需要重新 git add 和 git commit</p>
</blockquote>
<p>检查补丁状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git apply --<span class="built_in">stat</span> patch_name.patch</span><br></pre></td></tr></table></figure>

<p>检查补丁是否可打入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git apply --check patch_name.patch</span><br></pre></td></tr></table></figure>

<p>正式打入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git apply patch_name.patch</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用 diff 打 patch，会提示补丁片段没有有信息：@@-1,5 +1,5@@，需要删除文件路径和 @@-1,5 +1,5@@ 之间的空行</p>
</blockquote>
<p>强制打补丁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git apply --reject patch_name.patch</span><br></pre></td></tr></table></figure>

<p>打补丁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patch -p1 &lt; 26004743.diff/patch</span><br></pre></td></tr></table></figure>
<p>恢复源文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patch -RE -p1 &lt; 26004743.diff/patch</span><br></pre></td></tr></table></figure>

<h1 id="git-am-应用补丁"><a href="#git-am-应用补丁" class="headerlink" title="git am (应用补丁)"></a>git am (应用补丁)</h1><blockquote>
<p>git am 可以一起处理多个 patch，其会直接将 patch 的所有信息打上去，而且不用重新 git add 和 git commit</p>
</blockquote>
<p>打 patch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git am patch_name.patch</span><br></pre></td></tr></table></figure>

<p>停止打 patch（回退所有已打上的patch）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git am --abort </span><br></pre></td></tr></table></figure>

<h1 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h1><p>保存当前工作目录到一个新的 stash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认提交名</span></span><br><span class="line">git stash</span><br><span class="line">git stash save <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure>

<p>查看当前保存的所有 stash 列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>

<p>删除某个 stash， 从 stash 列表中移除，如果不指定 stash，默认会删除最新的 stash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash drop [stash]</span><br></pre></td></tr></table></figure>

<h1 id="others"><a href="#others" class="headerlink" title="others"></a>others</h1><p>查看暂存区内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git ls-files --stage</span><br><span class="line">git cat-file -t commitid  <span class="comment"># 查看 git 对象类型</span></span><br><span class="line">git cat-file -p commitid  <span class="comment"># 查看 git 对象内容</span></span><br></pre></td></tr></table></figure>

<p>撤销将未被纳入版本控制的文件加入暂存区的动作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --cached 选项表示是从暂存区中移除</span></span><br><span class="line">git <span class="built_in">rm</span> --cached readme.txt</span><br></pre></td></tr></table></figure>

<p>查看提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git show = git show head</span></span><br><span class="line">git show commit</span><br></pre></td></tr></table></figure>

<h1 id="组合技"><a href="#组合技" class="headerlink" title="组合技"></a>组合技</h1><p>将 Gerrit 修改的文件拷贝至文件夹中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir yxyx</span><br><span class="line">git show --pretty=&quot;format:&quot; --name-only | xargs -I&#123;&#125; cp &#123;&#125; ./yxyx/</span><br></pre></td></tr></table></figure>

<p>查看机型是否开启某想功能配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /torchlight/product_config</span><br><span class="line">find . -name <span class="string">&quot;*.config&quot;</span> | xargs grep CONFIG_XX | grep y</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Github/Git 相关问题</title>
    <url>/2021/07/22/Github/Github-Q&amp;A/</url>
    <content><![CDATA[<h1 id="解决git-clone-速度慢的问题"><a href="#解决git-clone-速度慢的问题" class="headerlink" title="解决git clone 速度慢的问题"></a>解决git clone 速度慢的问题</h1><p>利用国内镜像替换</p>
<blockquote>
<p>github.com.cnpmjs.org<br>git.sdut.me</p>
</blockquote>
<p>方法</p>
<blockquote>
<p>#我们准备clone的链接<br><code>git clone https://github.com/example</code><br>#使用镜像<br><code>git clone https://github.com.cnpmjs.org/example</code></p>
</blockquote>
<h1 id="git-push时登录显示密码错误"><a href="#git-push时登录显示密码错误" class="headerlink" title="git push时登录显示密码错误"></a>git push时登录显示密码错误</h1><p>依次进入界面<br><img src="https://i.loli.net/2021/08/02/o7sMXVbxkpQiSlG.png" alt="image.png"><br><img src="https://i.loli.net/2021/08/02/kMGWqlyPZtEHb6a.png" alt="image.png"><br><img src="https://i.loli.net/2021/08/02/MjGeZpFLdTb12BS.png" alt="image.png"></p>
<p>全部勾选并生成token，token便是git push登录时需要输入的密码（只会出现一次，记得复制！</p>
<h1 id="pip-install-git报错"><a href="#pip-install-git报错" class="headerlink" title="pip install git报错"></a>pip install git报错</h1><p>利用git安装github上的项目报错<br><code>ERROR: Command errored out with exit status 128: git clone -q https://github.com/xxx/xxx.git /tmp/pip-req-build-88ue_mql Check the logs for full command output.</code></p>
<p>解决方法<br>将github网页中的http://换成git://</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本来是</span></span><br><span class="line">pip install git+http://github.com/xxx/xxx.git</span><br><span class="line"><span class="comment"># 改为</span></span><br><span class="line">pip install git+git://github.com/xxx/xxx.git</span><br></pre></td></tr></table></figure>

<h1 id="解决-git-访问错误"><a href="#解决-git-访问错误" class="headerlink" title="解决 git 访问错误"></a>解决 git 访问错误</h1><p>参考链接：<a href="https://blog.csdn.net/aaaa_aaab/article/details/144281660">解决 git 报错</a></p>
<p>在国内访问 git 经常遇到访问报错，或者即使开了全局代理仍然访问失败，解决方法如下</p>
<p><strong>方法一：取消代理设置</strong></p>
<p>这是最常见的解决方法之一，通过在终端执行以下命令，可以取消 Git 的代理设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy </span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>

<p><strong>方法二：设置系统代理</strong></p>
<p>有时候取消代理设置仍然会出现报错，这时可以通过设置系统代理来解决。具体步骤如下：</p>
<ol>
<li><p>在 win10/11 中的设置中搜索代理服务器</p>
</li>
<li><p>打开代理服务器，获取代理服务器的 ip 地址和端口（127.0.0.1:7890）</p>
</li>
<li><p>在终端输入以下命令，设置 Git 使用本地代理</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure></li>
<li><p>设置完成后，可以通过以下命令检验是否设置成功：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global -l</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Github-stars</title>
    <url>/2021/08/09/Github/Github-stars/</url>
    <content><![CDATA[<h1 id="Github上star的项目分类"><a href="#Github上star的项目分类" class="headerlink" title="Github上star的项目分类"></a>Github上star的项目分类</h1><h2 id="StyleGan"><a href="#StyleGan" class="headerlink" title="StyleGan"></a>StyleGan</h2><h3 id="Desinging-an-Encoder-for-StyleGAN-Image-Manipulation"><a href="#Desinging-an-Encoder-for-StyleGAN-Image-Manipulation" class="headerlink" title="Desinging an Encoder for StyleGAN Image Manipulation"></a><a href="https://github.com/omertov/encoder4editing">Desinging an Encoder for StyleGAN Image Manipulation</a></h3><h3 id="Encoding-in-Style-a-StyleGAN-Encoder-for-Image-to-Image-Translation"><a href="#Encoding-in-Style-a-StyleGAN-Encoder-for-Image-to-Image-Translation" class="headerlink" title="Encoding in Style: a StyleGAN Encoder for Image-to-Image Translation"></a><a href="https://github.com/eladrich/pixel2style2pixel">Encoding in Style: a StyleGAN Encoder for Image-to-Image Translation</a></h3><h3 id="Face-Identity-Disentanglement-via-Latent-Space-Mapping"><a href="#Face-Identity-Disentanglement-via-Latent-Space-Mapping" class="headerlink" title="Face Identity Disentanglement via Latent Space Mapping"></a><a href="https://github.com/YotamNitzan/ID-disentanglement">Face Identity Disentanglement via Latent Space Mapping</a></h3><h3 id="Only-a-Matter-of-Style-Age-Transformation-Using-a-Style-Based-Regression-Model"><a href="#Only-a-Matter-of-Style-Age-Transformation-Using-a-Style-Based-Regression-Model" class="headerlink" title="Only a Matter of Style: Age Transformation Using a Style-Based Regression Model"></a><a href="https://github.com/yuval-alaluf/SAM">Only a Matter of Style: Age Transformation Using a Style-Based Regression Model</a></h3><h2 id="Face-Aging"><a href="#Face-Aging" class="headerlink" title="Face Aging"></a>Face Aging</h2><h3 id="Lifespan-Age-Transformation-Synthesis-code"><a href="#Lifespan-Age-Transformation-Synthesis-code" class="headerlink" title="Lifespan Age Transformation Synthesis code"></a><a href="https://github.com/royorel/Lifespan_Age_Transformation_Synthesis">Lifespan Age Transformation Synthesis code</a></h3><h3 id="Only-a-Matter-of-Style-Age-Transformation-Using-a-Style-Based-Regression-Model-1"><a href="#Only-a-Matter-of-Style-Age-Transformation-Using-a-Style-Based-Regression-Model-1" class="headerlink" title="Only a Matter of Style: Age Transformation Using a Style-Based Regression Model"></a><a href="https://github.com/yuval-alaluf/SAM">Only a Matter of Style: Age Transformation Using a Style-Based Regression Model</a></h3><h3 id="Face-Aging-with-Identity-Preserved-Conditional-Generative-Adversarial-Networks"><a href="#Face-Aging-with-Identity-Preserved-Conditional-Generative-Adversarial-Networks" class="headerlink" title="Face Aging with Identity-Preserved Conditional Generative Adversarial Networks"></a><a href="https://github.com/guyuchao/IPCGANs-Pytorch">Face Aging with Identity-Preserved Conditional Generative Adversarial Networks</a></h3><h3 id="Age-Progression-Regression-by-Conditional-Adversarial-Autoencoder"><a href="#Age-Progression-Regression-by-Conditional-Adversarial-Autoencoder" class="headerlink" title="Age Progression/Regression by Conditional Adversarial Autoencoder"></a><a href="https://github.com/ZZUTK/Face-Aging-CAAE">Age Progression/Regression by Conditional Adversarial Autoencoder</a></h3><h2 id="INN"><a href="#INN" class="headerlink" title="INN"></a>INN</h2><h3 id="Invertible-Residual-Networks"><a href="#Invertible-Residual-Networks" class="headerlink" title="Invertible Residual Networks"></a><a href="https://github.com/jhjacobsen/invertible-resnet">Invertible Residual Networks</a></h3><h3 id="FFJORD-Free-form-Continuous-Dynamics-for-Scalable-Reversible-Generative-Models"><a href="#FFJORD-Free-form-Continuous-Dynamics-for-Scalable-Reversible-Generative-Models" class="headerlink" title="FFJORD: Free-form Continuous Dynamics for Scalable Reversible Generative Models"></a><a href="https://github.com/rtqichen/ffjord">FFJORD: Free-form Continuous Dynamics for Scalable Reversible Generative Models</a></h3><h3 id="PyTorch-Framework-for-Developing-Memory-Efficient-Deep-Invertible-Networks"><a href="#PyTorch-Framework-for-Developing-Memory-Efficient-Deep-Invertible-Networks" class="headerlink" title="PyTorch Framework for Developing Memory Efficient Deep Invertible Networks"></a><a href="https://github.com/silvandeleemput/memcnn">PyTorch Framework for Developing Memory Efficient Deep Invertible Networks</a></h3><h2 id="Traffic"><a href="#Traffic" class="headerlink" title="Traffic"></a>Traffic</h2><h3 id="Pytorch-Implementation-For-LPRNet-A-High-Performance-And-Lightweight-License-Plate-Recognition-Framework"><a href="#Pytorch-Implementation-For-LPRNet-A-High-Performance-And-Lightweight-License-Plate-Recognition-Framework" class="headerlink" title="Pytorch Implementation For LPRNet, A High Performance And Lightweight License Plate Recognition Framework"></a><a href="https://github.com/sirius-ai/LPRNet_Pytorch">Pytorch Implementation For LPRNet, A High Performance And Lightweight License Plate Recognition Framework</a></h3><h2 id="Landmark检测"><a href="#Landmark检测" class="headerlink" title="Landmark检测"></a>Landmark检测</h2><h3 id="face-alignment"><a href="#face-alignment" class="headerlink" title="face-alignment"></a><a href="https://github.com/1adrianb/face-alignment">face-alignment</a></h3><h2 id="Package-amp-Tool-amp-Study"><a href="#Package-amp-Tool-amp-Study" class="headerlink" title="Package&amp;Tool&amp;Study"></a>Package&amp;Tool&amp;Study</h2><h3 id="pytorch-structural-similarity-SSIM-loss"><a href="#pytorch-structural-similarity-SSIM-loss" class="headerlink" title="pytorch structural similarity (SSIM) loss"></a><a href="https://github.com/Po-Hsun-Su/pytorch-ssim">pytorch structural similarity (SSIM) loss</a></h3><h3 id="PyTorch-tutorials-and-fun-projects-including-neural-talk-neural-style-poem-writing-anime-generation"><a href="#PyTorch-tutorials-and-fun-projects-including-neural-talk-neural-style-poem-writing-anime-generation" class="headerlink" title="PyTorch tutorials and fun projects including neural talk, neural style, poem writing, anime generation"></a><a href="https://github.com/chenyuntc/pytorch-book">PyTorch tutorials and fun projects including neural talk, neural style, poem writing, anime generation</a></h3>]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Github Actions实现自动部署</title>
    <url>/2021/09/22/Hexo/Hexo-GithubAction/</url>
    <content><![CDATA[<p><strong>本文参考</strong></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/170563000">GitHub Actions 来自动部署 Hexo</a></li>
<li><a href="https://xin520.xyz/githubactions/">用GitHub Actions 自动部署 Hexo博客</a></li>
</ul>
<h1 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h1><p>在Hexo中，以往的部署通常都需要通过命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清空静态页面(public文件夹)</span></span><br><span class="line">hexo g <span class="comment"># 创建静态页面</span></span><br><span class="line">hexo d <span class="comment"># 发布页面：清空.deploy_git/里文件，从public/复制新生成的文件</span></span><br></pre></td></tr></table></figure>
<p>在实现自动部署之前，hexo博客必须能够成功运行以上代码并成功部署</p>
<h1 id="实现自动部署"><a href="#实现自动部署" class="headerlink" title="实现自动部署"></a>实现自动部署</h1><h2 id="生成ssh密钥文件"><a href="#生成ssh密钥文件" class="headerlink" title="生成ssh密钥文件"></a>生成ssh密钥文件</h2><p>在任何位置的git bash窗口中运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;Hexo Deploy Key&quot;</span> -f github-deploy-key -N <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>会在当前目录生成两个文件</p>
<ul>
<li>github-deploy-key —— 私钥</li>
<li>github-deploy-key.pub —— 公钥</li>
</ul>
<h2 id="创建私人仓库-用于部署"><a href="#创建私人仓库-用于部署" class="headerlink" title="创建私人仓库(用于部署)"></a>创建私人仓库(用于部署)</h2><p>在GitHub中创建repositories，名字随意取，选private，其他勾不勾无所谓<br>然后在你的博客文件夹根目录(不是themes目录)运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>将整个博客文件夹变成一个git管理的仓库<br>依次运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add . <span class="comment"># 将所有文件夹加入到暂存区(这里需要删除themes中的.git文件夹，否则themes文件夹不会被加入暂存区)</span></span><br><span class="line">git commit -m <span class="string">&#x27;the initial edition&#x27;</span> <span class="comment"># 提交暂存区</span></span><br><span class="line">git remote add origin https://github.com/usrname/usrname.git <span class="comment"># 与仓库关联</span></span><br><span class="line">git pull <span class="comment">#拉取仓库比较内容，放心不会覆盖本地文件</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>现在看你的私人仓库，文件内容应该和你的工作区(本地博客文件夹)是一致的(本地的.deploy_git可以直接删除)</p>
<blockquote>
<p>注意在删除 .git 文件夹之后，主题就没办法通过 git pull 进行更新，但是可以通过本地替换的方式来更新主题</p>
</blockquote>
<h2 id="配置密钥"><a href="#配置密钥" class="headerlink" title="配置密钥"></a>配置密钥</h2><h3 id="配置私钥"><a href="#配置私钥" class="headerlink" title="配置私钥"></a>配置私钥</h3><ul>
<li>在上面的创建的私人仓库中访问<code>Settings -&gt; Secrets,New secret</code>  </li>
<li>在name中填写<code>HEXO_DEPLOY_KEY</code>，将私钥文件<code>github-deploy-key</code>中的内容全部复制进来</li>
</ul>
<h3 id="配置公钥"><a href="#配置公钥" class="headerlink" title="配置公钥"></a>配置公钥</h3><ul>
<li>在你的博客仓库(存放html静态页面的仓库)，一般为<code>name.github.io</code>中访问<code>Settings -&gt; Deploy keys,Add deploy key</code></li>
<li>在name中填写<code>HEXO_DEPLOY_PUB</code>，将公钥文件<code>github-deploy-key.pub</code>中的内容全部复制进来</li>
<li>勾选<code>Allow write access</code></li>
</ul>
<h2 id="创建触发自动部署的脚本"><a href="#创建触发自动部署的脚本" class="headerlink" title="创建触发自动部署的脚本"></a>创建触发自动部署的脚本</h2><p>两种方法</p>
<ul>
<li>直接在私人仓库中添加文件(路径为.github/workflows/deploy.yml)，然后再pull到本地；</li>
<li>直接在本地工作区添加文件(路径为.github/workflows/deploy.yml)，然后再push到仓库；</li>
</ul>
<p>我这里选用了方法一</p>
<ul>
<li><p>在私人仓库添加文件(路径为.github/workflows/deploy.yml)，内容为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name: Hexo Deploy</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - master</span><br><span class="line"></span><br><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-18.04</span><br><span class="line">    <span class="keyword">if</span>: github.event.repository.owner.id == github.event.sender.id</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout <span class="built_in">source</span></span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line">        with:</span><br><span class="line">          ref: master</span><br><span class="line"></span><br><span class="line">      - name: Setup Node.js</span><br><span class="line">        uses: actions/setup-node@v1</span><br><span class="line">        with:</span><br><span class="line">          node-version: <span class="string">&#x27;12&#x27;</span></span><br><span class="line"></span><br><span class="line">      - name: Setup Hexo</span><br><span class="line">        <span class="built_in">env</span>:</span><br><span class="line">          ACTION_DEPLOY_KEY: <span class="variable">$&#123;&#123; secrets.HEXO_DEPLOY_KEY &#125;</span>&#125;</span><br><span class="line">        run: |</span><br><span class="line">          <span class="built_in">mkdir</span> -p ~/.ssh/</span><br><span class="line">          <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$ACTION_DEPLOY_KEY</span>&quot;</span> &gt; ~/.ssh/id_rsa</span><br><span class="line">          <span class="built_in">chmod</span> 700 ~/.ssh</span><br><span class="line">          <span class="built_in">chmod</span> 600 ~/.ssh/id_rsa</span><br><span class="line">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="line">          git config --global user.email <span class="string">&quot;email@xx.com&quot;</span></span><br><span class="line">          git config --global user.name <span class="string">&quot;usrname&quot;</span></span><br><span class="line">          npm install hexo-cli -g</span><br><span class="line">          npm install</span><br><span class="line"></span><br><span class="line">      - name: Deploy</span><br><span class="line">        run: |</span><br><span class="line">          hexo clean</span><br><span class="line">          hexo deploy</span><br></pre></td></tr></table></figure>
<p>将上面的email和usrname改为你自己的邮件路径和名字<br>上面的推送脚本就是说只要本地的工作区有内容push到私人仓库中，就会执行hexo clean和hexo deploy</p>
</li>
<li><p>然后将这个文件夹pull到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<p>如果没有成功把workflow文件夹pull到本地，可以尝试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull -f origin master <span class="comment"># 强制拉取</span></span><br></pre></td></tr></table></figure>
<p>如果不进行拉取同步，那么在后续push的时候也会报错，因为你私人仓库和本地仓库内容不同步。</p>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>知道了原理，你可以在本地中修改任意文件，然后执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>成功push之后，就是自动触发GitHub Actions中的脚本，执行编译和部署(如果失败的话)，GitHub就会给你发邮件。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法记录</title>
    <url>/2021/08/01/Hexo/Hexo-Markdown/</url>
    <content><![CDATA[<p><strong>只记录自己在写的时候会发问的语法（以防忘记</strong></p>
<h2 id="加粗-斜体-删除线"><a href="#加粗-斜体-删除线" class="headerlink" title="加粗,斜体,删除线"></a>加粗,斜体,删除线</h2><table>
<thead>
<tr>
<th>语法</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>**加粗**</td>
<td><strong>加粗</strong></td>
</tr>
<tr>
<td>*斜体*</td>
<td><em>斜体</em></td>
</tr>
<tr>
<td>***粗斜体文本***</td>
<td><em><strong>粗斜体文本</strong></em></td>
</tr>
<tr>
<td>~~删除线~~</td>
<td><del>删除线</del></td>
</tr>
</tbody></table>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>语法</p>
<p>``` language</p>
<p>```</p>
<p>效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="csdn或者hexo上显示连续中划线-zwnj"><a href="#csdn或者hexo上显示连续中划线-zwnj" class="headerlink" title="csdn或者hexo上显示连续中划线-&zwnj;-"></a>csdn或者hexo上显示连续中划线-&zwnj;-</h2><ul>
<li><p>在连续中划线之间使用零宽不连字 <code>&amp;zwnj;</code>  </p>
<table>
<thead>
<tr>
<th>语法</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>-&amp;zwnj;-</code></td>
<td>-&zwnj;-</td>
</tr>
</tbody></table>
</li>
<li><p>直接用``进行包裹  </p>
<table>
<thead>
<tr>
<th>语法</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>`–`</td>
<td><code>--</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="添加分割线"><a href="#添加分割线" class="headerlink" title="添加分割线"></a>添加分割线</h2><p>语法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">***  </span><br><span class="line">* * *  </span><br><span class="line">*****  </span><br><span class="line">- - -  </span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p>效果</p>
<hr>
<h2 id="添加待办事项"><a href="#添加待办事项" class="headerlink" title="添加待办事项"></a>添加待办事项</h2><p>语法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- [ ] 准备做</span><br><span class="line">- [x] 已经完成</span><br></pre></td></tr></table></figure>

<p>效果</p>
<ul>
<li><input disabled="" type="checkbox"> 准备做</li>
<li><input checked="" disabled="" type="checkbox"> 已经完成</li>
</ul>
<h2 id="Markdown添加参考文献"><a href="#Markdown添加参考文献" class="headerlink" title="Markdown添加参考文献"></a>Markdown添加参考文献</h2><p><a href="https://www.abner.run/posts/markdown%E6%B7%BB%E5%8A%A0%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE/">参考资料</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo搭建博客+更换主题以及后续问题记录</title>
    <url>/2021/07/20/Hexo/Hexo_buildweb/</url>
    <content><![CDATA[<h1 id="利用Hexo搭建博客"><a href="#利用Hexo搭建博客" class="headerlink" title="利用Hexo搭建博客"></a>利用Hexo搭建博客</h1><p><strong>参考文章</strong></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/22498474">Hexo(2)-部署博客及更新博文</a></li>
</ul>
<p>算是一次自己成功尝试的记录</p>
<h2 id="Github创建个人仓库"><a href="#Github创建个人仓库" class="headerlink" title="Github创建个人仓库"></a>Github创建个人仓库</h2><p>点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.github.io 这个用户名使用自己的GitHub帐号名称代替</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>任意位置右键选择Git Bash Here<br> <img src="https://i.loli.net/2021/07/21/ZWYFpob54ndehJS.png" width = "30%" alt="图片名称" lign='center' /><br> <!-- <img src='https://i.loli.net/2021/07/21/ZWYFpob54ndehJS.png' style='float:left'/> --></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name xuedue  <span class="comment">#改成你的GitHub用户名  </span></span><br><span class="line">git config --global user.email 1515****06@qq.com  <span class="comment">#改成你自己的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p>生成ssh密钥文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 1515****06@qq.com <span class="comment">#改成你自己的GitHub注册邮箱</span></span><br></pre></td></tr></table></figure>

<p>然后直接三个回车即可，默认不需要设置密码<br>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，打开文件并复制内容<br> <img src="https://i.loli.net/2021/07/21/ptdnSA1becZgNRH.png" width="80%"><br>打开<a href="https://github.com/settings/keys">GitHub_Settings_keys</a> 页面，新建new SSH Key<br> <img src="https://i.loli.net/2021/07/21/LMgYGFX5J87s6lu.png" width="80%"><br>Title为标题，随便填，将上面复制的id_rsa.pub的内容粘贴进去，最后点击Add SSH key。<br>在Git Bash中检测GitHub公钥设置是否成功，输入 ssh <a href="mailto:&#x67;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#111;&#x6d;">&#x67;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#111;&#x6d;</a> ，有如下显示就算成功<br><img src="https://i.loli.net/2021/07/21/TJYHQxPILw8lM3S.png" alt="1626879148_1_.jpg"></p>
<h2 id="安装Node-js和npm"><a href="#安装Node-js和npm" class="headerlink" title="安装Node.js和npm"></a>安装Node.js和npm</h2><p>安装完Node.js会自动安装npm,并填入系统路径，在cmd中查看版本验证是否安装正确</p>
<p><img src="https://i.loli.net/2021/07/21/FpWHbLXk3B1c95T.png" alt="image.png"></p>
<h2 id="安装Hexo并初始化博客文件夹"><a href="#安装Hexo并初始化博客文件夹" class="headerlink" title="安装Hexo并初始化博客文件夹"></a>安装Hexo并初始化博客文件夹</h2><ul>
<li>安装Hexo<br>打开cmd窗口，输入下面命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure></li>
<li>初始化博客文件夹<br>在cmd窗口进入你想要创建博客文件夹的位置，并输入下面命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog(博客文件夹的名字)  </span><br></pre></td></tr></table></figure></li>
</ul>
<p>进入博客文件夹中，如果用上述命令，则cd blog<br>网站这时候已经建立好，可以通过命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g  </span><br><span class="line">hexo s  </span><br></pre></td></tr></table></figure>

<p>这时候访问 localhost:4000，就可以看到自己的网页了</p>
<h3 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo -g <span class="comment">#安装Hexo  </span></span><br><span class="line">npm update hexo -g <span class="comment">#升级  </span></span><br><span class="line">hexo init <span class="comment">#初始化博客  </span></span><br></pre></td></tr></table></figure>

<p>命令简写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n article_name == hexo new article_name <span class="comment">#新建文章  </span></span><br><span class="line">hexo new page page_name <span class="comment">#新建页面</span></span><br><span class="line">hexo g == hexo generate <span class="comment">#生成  </span></span><br><span class="line">hexo s == hexo server <span class="comment">#启动服务预览  </span></span><br><span class="line">hexo d == hexo deploy <span class="comment">#部署  </span></span><br><span class="line">hexo server <span class="comment">#Hexo会监视文件变动并自动更新，无须重启服务器  </span></span><br><span class="line">hexo server -s <span class="comment">#静态模式  </span></span><br><span class="line">hexo server -p 5000 <span class="comment">#更改端口  </span></span><br><span class="line">hexo server -i 192.168.1.1 <span class="comment">#自定义 IP  </span></span><br><span class="line">hexo clean <span class="comment">#清除缓存，若是网页正常情况下可以忽略这条命令</span></span><br></pre></td></tr></table></figure>

<h2 id="发布网站"><a href="#发布网站" class="headerlink" title="发布网站"></a>发布网站</h2><p>打开博客文件夹根目录的_config.yml文件，修改最后的Deployment，把repo改为自己的仓库路径<br><img src="https://i.loli.net/2021/07/21/LPfMQYOTDhozH9r.png" alt="image.png"><br>保存文件，然后安装Git部署插件  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save </span><br></pre></td></tr></table></figure>

<p>然后输入hexo命令将网站部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean  </span><br><span class="line">hexo g  </span><br><span class="line">hexo d </span><br></pre></td></tr></table></figure>

<h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><p>这里可能会出现  OpenSSL SSL_read: Connection was reset, errno 10054 的问题<br>打开Git执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify <span class="string">&quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p>之后浏览器访问 <code>XXX.github.io</code> 就能访问到我们的网站了</p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>找到喜欢的主题的github界面，执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>

<p>上面的链接就是你自己找的主题的GitHub链接，后面就是git clone到当前目录的什么文件夹下，注意这里要在博客的根目录下执行，因为命令中已经加了themes/</p>
<p>然后打开根目录下的_config.yml文件，修改其中的Themes<br><img src="https://i.loli.net/2021/07/21/AbON5qZYeKnI8Ct.png" alt="image.png"></p>
<p>修改保存后，再次进行部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g  </span><br><span class="line">hexo d </span><br></pre></td></tr></table></figure>
<p>进入网站查看部署效果。</p>
<h1 id="Hexo-报错"><a href="#Hexo-报错" class="headerlink" title="Hexo 报错"></a>Hexo 报错</h1><h2 id="type-39-expected-variable-end-39"><a href="#type-39-expected-variable-end-39" class="headerlink" title="type: &#39;expected variable end&#39;"></a><code>type: &#39;expected variable end&#39;</code></h2><p>hexo s调试时报上述错误<br>原因是文中内容存在连续的大括号(通常是由于公式内容)，导致hexo解析失败，只需要在连续的中括号(左右都要)中间加上一个空格号。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客迁移至新设备</title>
    <url>/2023/10/03/Hexo/Hexo_newDevice/</url>
    <content><![CDATA[<p>由于hexo是静态页面，所有文档都是保存在本地的（可以通过Github Action将整个博客放在Github中），所以在换新电脑的时候需要把博客迁移到新电脑上，这个过程也踩了一些坑，所以特此写个文档记录一下，这样下次再换设备的时候就可以快速进行迁移。</p>
<p>另外需要说明的是，本文档只用于已使用GitHub Action进行自动部署的迁移。</p>
<h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><p>具体的安装流程这里就不说明。安装完git之后，新建一个git本地仓库，例如新建一个xuedue文件夹，然后输入。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>之后可以直接使用 <code>git clone</code> 或者 <code>git pull</code> 将仓库拉至本地，此时需要确保本地仓库和远程仓库是同步的。</p>
<blockquote>
<p>这一步需不需要之前的公钥和密钥？下次迁移时验证一下。</p>
</blockquote>
<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>在本地的仓库安装完hexo之后，需要确保本地的hexo是可以正常进行部署的，如果在部署的过程中遇到下面的错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR Cannot find module ‘hexo’ from ‘D:\blog’</span><br><span class="line">ERROR Local hexo loading failed <span class="keyword">in</span> D:\blog</span><br><span class="line">ERROR Try running: ‘<span class="built_in">rm</span> -rf node_modules &amp;&amp; npm install --force’</span><br></pre></td></tr></table></figure>

<p>可以使用命令补全丢失的环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h1 id="Github-Action部署"><a href="#Github-Action部署" class="headerlink" title="Github Action部署"></a>Github Action部署</h1><p>前面两部已经确保了本地是可以正常进行部署的，然后这里就可以参考之前写的文档进行远程自动部署。</p>
<p>实际迁移中自动部署失败。遇到两个问题：</p>
<ol>
<li><p>GitHub Actions Error “Waiting for a runner to pick up this job”</p>
<p> 在推送代码触发GitHub Actions时，一直没有成功运行，控制台显示一直等待：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">waiting <span class="keyword">for</span> a runner to pick up this job</span><br></pre></td></tr></table></figure>

<p> 查阅资料后，似乎时部署配置文件中的runner版本太低，我之前写的是<code>Ubuntu-18.04</code>,后续改为<code>ubuntu-latest</code>,此问题得到解决。</p>
</li>
<li><p>在远程自动执行hexo deploy时失败，显示没有访问权限</p>
<p> 后续发现是远程仓库密钥丢失问题。直接在本地生成新的密钥，然后参考Github Action文档生成密钥，然后复制到文档中提到的相应位置。</p>
</li>
</ol>
<p>至此，就完成了hexo从旧电脑迁移到新电脑的过程了。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex</title>
    <url>/2022/06/25/Latex/Latex/</url>
    <content><![CDATA[<p><strong>相关链接</strong>  </p>
<ul>
<li><a href="http://www.ctex.org/documents/latex/graphics/">Latex插图指南</a></li>
<li><a href="https://www.techwalla.com/articles/horizontal-line-options-in-latex">Horizontal Line Options in LaTeX</a></li>
<li><a href="https://mathpretty.com/?s=latex">文艺数字君</a></li>
</ul>
<h2 id="LaTex中输入空格以及换行"><a href="#LaTex中输入空格以及换行" class="headerlink" title="LaTex中输入空格以及换行"></a>LaTex中输入空格以及换行</h2><p><strong>参考链接</strong>  </p>
<ul>
<li><p><a href="https://blog.csdn.net/luolang_103/article/details/81289529">LaTex中输入空格以及换行</a></p>
</li>
<li><p>使用\表示空格</p>
<table>
<thead>
<tr>
<th align="left">空格</th>
<th align="left">代码</th>
<th align="left">效果</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">quad空格</td>
<td align="left">a \qquad b</td>
<td align="left">$a \qquad b$</td>
<td align="left">两个m的宽度</td>
</tr>
<tr>
<td align="left">quad空格</td>
<td align="left">a \quad b</td>
<td align="left">$a \quad b$</td>
<td align="left">一个m的宽度</td>
</tr>
<tr>
<td align="left">大空格</td>
<td align="left">a\ b</td>
<td align="left">$a \  b$</td>
<td align="left">1/3m宽度</td>
</tr>
<tr>
<td align="left">中等空格</td>
<td align="left">a\;b</td>
<td align="left">$a ; b$</td>
<td align="left">2/7m宽度</td>
</tr>
<tr>
<td align="left">小空格</td>
<td align="left">a\,b</td>
<td align="left">$a , b$</td>
<td align="left">1/6m宽度</td>
</tr>
<tr>
<td align="left">没有空格</td>
<td align="left">ab</td>
<td align="left">$ab$</td>
<td align="left">无空格</td>
</tr>
<tr>
<td align="left">紧贴</td>
<td align="left">a\!b</td>
<td align="left">$a ! b$</td>
<td align="left">缩进1/6m宽度</td>
</tr>
</tbody></table>
<p>  \quad、1em、em、m代表当前字体下接近字符‘M’的宽度。</p>
</li>
<li><p>使用\\表示换行</p>
</li>
</ul>
<h2 id="Latex声调输入"><a href="#Latex声调输入" class="headerlink" title="Latex声调输入"></a>Latex声调输入</h2><p><strong>参考链接</strong>  </p>
<ul>
<li><p><a href="https://blog.csdn.net/qq_43511299/article/details/113844504">Latex texstudio法国人名字上面的一撇，声调输入</a>(文章出错，下面已经改正四声)</p>
</li>
<li><p>声调表格</p>
<table>
<thead>
<tr>
<th align="left">声调</th>
<th align="left">代码</th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">一声</td>
<td align="left">\={a}</td>
<td align="left">$={a}$</td>
</tr>
<tr>
<td align="left">二声</td>
<td align="left">\‘{a}</td>
<td align="left">$&#39;{a}$</td>
</tr>
<tr>
<td align="left">三声</td>
<td align="left">\v{a}</td>
<td align="left">$\v{a}$</td>
</tr>
<tr>
<td align="left">四声</td>
<td align="left">\`{a}</td>
<td align="left">$`{a}$</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="Latex长度单位"><a href="#Latex长度单位" class="headerlink" title="Latex长度单位"></a>Latex长度单位</h2><p><strong>参考链接</strong>  </p>
<ul>
<li><p><a href="https://blog.csdn.net/robert_chen1988/article/details/52739825">latex 中的长度单位，尺寸</a></p>
</li>
<li><p>latex中的通用长度单位如下：</p>
<table>
<thead>
<tr>
<th align="center">单位</th>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mm</td>
<td align="left">毫米</td>
<td align="left">1 mm = 2.845 pt</td>
</tr>
<tr>
<td align="center">pt</td>
<td align="left">点</td>
<td align="left">1 pt = 0.351 mm</td>
</tr>
<tr>
<td align="center">bp</td>
<td align="left">大点</td>
<td align="left">1 bp = 0.353 mm &gt; 1 pt</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="left">迪多</td>
<td align="left">1 dd = 0.376 mm = 1.07 p</td>
</tr>
<tr>
<td align="center">pc</td>
<td align="left">排卡</td>
<td align="left">1 pc = 4.218 mm = 12 pt</td>
</tr>
<tr>
<td align="center">sp</td>
<td align="left">定标点</td>
<td align="left">65536 sp = 1 pt</td>
</tr>
<tr>
<td align="center">cm</td>
<td align="left">厘米</td>
<td align="left">1 cm= 10 mm= 28.453 pt</td>
</tr>
<tr>
<td align="center">cc</td>
<td align="left">西塞罗</td>
<td align="left">1 cc= 4.513 mm= 12 dd = 12.84 pt</td>
</tr>
<tr>
<td align="center">in</td>
<td align="left">英寸</td>
<td align="left">1 in = 25.4 mm = 72.27 pt</td>
</tr>
<tr>
<td align="center">ex</td>
<td align="left">ex</td>
<td align="left">1 ex = 当前字体尺寸中 x 的高度</td>
</tr>
<tr>
<td align="center">em</td>
<td align="left">em</td>
<td align="left">1 em = 当前字体尺寸中 M 的宽度</td>
</tr>
</tbody></table>
<p>  对水平距离的设置常用 em ，而对垂直距离的设置，如行距，常用 ex。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令和问题</title>
    <url>/2021/07/22/OS/OS-Linux-Q&amp;A/</url>
    <content><![CDATA[<h2 id="解决ubuntu-16-4解压后中文乱码"><a href="#解决ubuntu-16-4解压后中文乱码" class="headerlink" title="解决ubuntu 16.4解压后中文乱码"></a>解决ubuntu 16.4解压后中文乱码</h2><p>zip格式没有指定编码格式，window下的zip编码是GBK/GB2312等</p>
<p>使用命令进行解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip -O CP936  xxx.zip</span><br></pre></td></tr></table></figure>

<p>其中字符可以是CP936、GBK、GB18030三种中的任一一种</p>
<h2 id="Linux查看占用GPU的进程"><a href="#Linux查看占用GPU的进程" class="headerlink" title="Linux查看占用GPU的进程"></a>Linux查看占用GPU的进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fuser -v /dev/nvidia*</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Operating System</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>解压</tag>
      </tags>
  </entry>
  <entry>
    <title>OS-Linux-Ubuntu换驱动</title>
    <url>/2021/08/14/OS/OS-Linux-Ubuntu%E6%8D%A2%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<p><strong>参考文章</strong></p>
<ul>
<li><a href="https://blog.csdn.net/Rookie_tong/article/details/83989969">ubuntu16.04更换nvidia驱动极简教程 </a></li>
<li><a href="https://www.nvidia.com/en-us/drivers/unix/linux-amd64-display-archive/">驱动下载网址</a></li>
</ul>
<ol>
<li>禁用nouveau<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;blacklist nouveau&quot;</span> &gt;&gt; /etc/modprobe.d/blacklist.conf</span><br><span class="line"><span class="built_in">sudo</span> update-initramfs -u</span><br><span class="line">reboot </span><br></pre></td></tr></table></figure>
可使用以下命令查询是否禁用成功。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure></li>
<li>安装nvidia驱动<br>nvidia官网下载显卡对应驱动，更改文件权限。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 777 NVIDIA-Linux-XXX.run</span><br></pre></td></tr></table></figure>
Ctrl + Alt + F1 进入命令行模式。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service lightdm stop</span><br><span class="line"><span class="built_in">sudo</span> ./NVIDIA-Linux-XXX.run</span><br></pre></td></tr></table></figure>
一直确定即可。最后重启。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
可使用以下命令查看驱动是否安装成功。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nvidia驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>OS-Linux-screen</title>
    <url>/2021/08/09/OS/OS-Linux-screen/</url>
    <content><![CDATA[<h1 id="screen-使用"><a href="#screen-使用" class="headerlink" title="screen 使用"></a>screen 使用</h1><h2 id="命令行下的screen命令"><a href="#命令行下的screen命令" class="headerlink" title="命令行下的screen命令"></a>命令行下的screen命令</h2><p>创建名为xuedue的session</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -S xuedue</span><br></pre></td></tr></table></figure>

<p>列出当前所有session</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -<span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>远程离线(detach)名为xuedue的session(如果有多个同名记得带编号)  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -d name</span><br></pre></td></tr></table></figure>

<p>回到名为xuedue的session</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -r xuedue</span><br></pre></td></tr></table></figure>

<p>删除名为xuedue的session</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -X -S xuedue quit</span><br></pre></td></tr></table></figure>

<h2 id="session中使用Ctrl-a的命令"><a href="#session中使用Ctrl-a的命令" class="headerlink" title="session中使用Ctrl+a的命令"></a>session中使用Ctrl+a的命令</h2><p>只记录一些最常用的<br>离线当前session</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl+a+d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Operating System</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>screen</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘打不开，提示需要格式化</title>
    <url>/2024/10/16/OS/OS-Win-%E7%A3%81%E7%9B%98%E6%89%93%E4%B8%8D%E5%BC%80/</url>
    <content><![CDATA[<p>参考文献：<a href="https://ask.zol.com.cn/x/4477469.html">磁盘格式化修复</a></p>
<p>遇到过一次，格式化是不可能格式化的，最终通过</p>
<p>开始——运行——CMD——chkdsk d:/f ——回车 解决</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意其中“D”代表那个无法打开磁盘的盘符，比如你F盘打不开了就运行chkdsk f:/f然后回车，然后重启电脑</span></span><br><span class="line">chkdsk d:/f </span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Operating System</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Paper-FaceAging-Survey</title>
    <url>/2021/09/19/Paper/Paper-FaceAging-Survey/</url>
    <content><![CDATA[<h1 id="Age-simulation-for-face-recognition"><a href="#Age-simulation-for-face-recognition" class="headerlink" title="Age simulation for face recognition"></a>Age simulation for face recognition</h1><p>Accept:2006ICPR<br>首先使用形状和纹理矢量通过在形状或纹理的本征空间中投影面部图像来表示面部图像。 然后结合年龄函数和年龄分类法对年龄进行估计。 并且我们使用估计的年龄，典型的向量创建函数和原始测试图像的特征向量来生成目标年龄的合成特征向量。 最后，我们重建了特征空间中的形状和纹理，并结合起来以在目标年龄合成面部图像。</p>
<h1 id="A-Compositional-and-Dynamic-Model-for-Face-Aging"><a href="#A-Compositional-and-Dynamic-Model-for-Face-Aging" class="headerlink" title="A Compositional and Dynamic Model for Face Aging"></a>A Compositional and Dynamic Model for Face Aging</h1><p>Accept:2009IEEE Transactions on Pattern Analysis and Machine Intelligence<br>组成模型通过分层的“或”图表示每个年龄组中的面孔，其中“与”节点将面孔分解成描述对年龄感知至关重要的细节（例如头发，皱纹等）的部分</p>
<h1 id="Age-Synthesis-and-Estimation-via-Faces-A-Survey"><a href="#Age-Synthesis-and-Estimation-via-Faces-A-Survey" class="headerlink" title="Age Synthesis and Estimation via Faces: A Survey"></a>Age Synthesis and Estimation via Faces: A Survey</h1><p>Accept:2010IEEE transactions on pattern analysis and machine intelligence<br>综述</p>
<h1 id="A-concatenational-graph-evolution-aging-model"><a href="#A-concatenational-graph-evolution-aging-model" class="headerlink" title="A concatenational graph evolution aging model"></a>A concatenational graph evolution aging model</h1><p>Accept:2012 IEEE transactions on pattern analysis and machine intelligence<br>传统建模</p>
<h1 id="Illumination-Aware-Age-Progression"><a href="#Illumination-Aware-Age-Progression" class="headerlink" title="Illumination-Aware Age Progression"></a>Illumination-Aware Age Progression</h1><p>Accept:2014CVPR  </p>
<ul>
<li>问题  <ol>
<li>首先，老化过程是不确定的，具体取决于输入照片中可能不明显的环境和遗传因素。</li>
<li>其次，面部表情和可识别性受发型，眼镜，表情和照明的强烈影响，这些因素是可变且不可预测的。</li>
<li>最后，由于现有的年龄分析数据库相对较小，分辨率较低和/或年龄范围有限，因此可用于构建有效模型的数据相对较少。</li>
<li>从一张照片中老化非常小的孩子的照片被认为是所有情况中最困难的情况，超过几岁的年龄被认为是不切实际的。我们专门针对这个极具挑战性的案例。</li>
</ol>
</li>
<li>贡献<ol>
<li>我们介绍了第一种完全自动化的年龄发展方法，该方法在“野外”运行，即在光照，表情或姿势上没有严格的限制。（在这之前的做法需要手动对齐）</li>
<li>我们提出了一些关于成年婴儿成年的令人信服的（也是最广泛的）结果。</li>
<li>我们引入了一种新颖的照明感知年龄发展技术，利用照明建模结果[1，31]，可以在不重建3D模型或光源方向的情况下正确考虑场景照明并纠正表面阴影。</li>
</ol>
</li>
<li>相关工作<ul>
<li>Facial analysis and synthesis using image-based models.提出了使用基于图像的模型来合成新人脸的方法，但并没有关注老化和未校准的条件；</li>
<li>现在有一些商业程序可以老化使用网络摄像头或手机拍摄的照片。但是，通常这些程序仅对成人或较大的孩子的照片有效；</li>
</ul>
</li>
<li>方法<br><img src="https://z3.ax1x.com/2021/09/19/48GGFA.png" alt="48GGFA"><br>不同年龄段的人的平均图像。 每个图像代表大约1500个人。 最上面一行的结果仅对齐以使眼睛，鼻子和嘴巴大致对应。 第二行显示像素间对齐后的平均值。 这些要清晰得多，但是色调是可变的，照明是不自然的，并且细微的形状差异（例如皱纹）被平均化了（以放大至最后一列）。 最下面的两行显示重新照明的平均值，与具有相反照明方向的两个参考帧（最左侧）匹配。 重新照明的结果具有适当的阴影，经过色调匹配，可以跨年龄比较，并显示3D形状变化（注意鼻子和额头）。<br><img src="https://z3.ax1x.com/2021/09/19/48G6Wq.png" alt="48G6Wq"><br>得到可用的low-rank平均图片，就可以按照上图的方法进行叠加</li>
</ul>
<h1 id="Personalized-Age-Progression-with-Aging-Dictionary-CDL"><a href="#Personalized-Age-Progression-with-Aging-Dictionary-CDL" class="headerlink" title="Personalized Age Progression with Aging Dictionary(CDL)"></a>Personalized Age Progression with Aging Dictionary(CDL)</h1><p>Accept: 2015ICCV</p>
<ul>
<li>问题<ol>
<li>基于原型的年龄发展会将预先划分的来源年龄组和目标年龄组的两个原型（例如，平均面孔）之间的差异转移到输入的个人面孔中，其年龄属于来源年龄组。基于原型的年龄发展方法不能很好地保留单个人脸的这种个性，因为它们是基于相对较大人群的人类衰老过程中的一般规则。</li>
<li>基于建模的年龄进程使用实际年龄（范围）对形状/纹理合成的面部参数建模。基于建模的年龄发展方法不会特别考虑这些个性化细节。而且，它们需要密集的长期（例如年龄跨度超过20岁）面部老化序列来构建复杂模型。但是，在现实世界中收集这些密集的长期面部序列非常困难，甚至不可能。</li>
</ol>
</li>
<li>贡献<ol>
<li>我们提出了一种个性化的年龄发展方法来渲染衰老的面孔，该方法可以保留个性化的面部特征； </li>
<li>由于收集所有年龄段的人的面部序列是具有挑战性的甚至是不可能的，因此所提出的方法仅需要可用的短期面部老化对来学习人类衰老的所有老化字典基础，这是更可行的。 广泛的实验很好地证明了我们提出的解决方案相对于其他最新技术的优势 个性化的衰老进程，以及通过合成衰老面孔进行跨时代面孔验证的性能提升。</li>
</ol>
</li>
</ul>
<h1 id="Recurrent-Face-Aging（RFA）"><a href="#Recurrent-Face-Aging（RFA）" class="headerlink" title="Recurrent Face Aging（RFA）"></a>Recurrent Face Aging（RFA）</h1><p>Accept: 2016CVPR</p>
<ul>
<li>问题<ol>
<li>首先，面部可能具有许多不同的表情和光照条件，这对建模老化模式提出了巨大挑战。</li>
<li>此外，训练数据通常非常有限，并且同一人的面部图像仅覆盖狭窄的年龄范围。</li>
<li>此外，面部衰老过程还取决于环境和难以建模的基因。</li>
<li>物理模型方法采用参数模型，通过对肌肉，皮肤或颅骨的衰老机制进行建模来模拟面部衰老。但是，这些方法非常复杂且计算量很大，并且它们需要具有不同年龄范围的同一个人的大量面部序列。但是，当前很少有面部衰老数据集可以提供足够的数据。</li>
<li>原型方法不需要具有连续年龄的同一个人的脸部序列。原型方法使用非参数模型对老化进行建模。首先，将所有可用的面部分为离散的年龄组，并计算每个年龄组内的平均面部作为先验。平均面之间的差异被视为老化图案，并且该图案被转移到每个单独的面上以产生老化面。但是，==原型方法完全丢弃了个性化信息，所有人共享相同的老化模式。==而且，无论模型类型如何，所有这些方法都通过学习单个映射函数来执行从一个年龄组到另一年龄组的一步转换。因此，单步映射功能通常无法捕获相邻年龄组之间的面部中间序列的动态。</li>
</ol>
</li>
<li>贡献<ol>
<li>提出了使用RNN网络的每个相邻群体之间的平滑面部老化过程； （解决问题2，）</li>
<li>我们的方法可以生成平滑的中间面，并且可以正确处理重影伪影。</li>
</ol>
</li>
<li>缺点<ol>
<li>需要配对数据（需要较长年龄的面部图像序列</li>
<li>只能老化，不能年轻化</li>
<li>关注老化，没有重视身份保持</li>
<li>基于组的学习，这需要测试面孔的真实年龄来定位过渡状态</li>
<li>需要繁琐的预处理（Face Aging with Improved Invertible Conditional GANs）</li>
</ol>
</li>
</ul>
<h1 id="Face-Aging-Effect-Simulation-using-Hidden-Factor-Analysis-Joint-Sparse-Representation"><a href="#Face-Aging-Effect-Simulation-using-Hidden-Factor-Analysis-Joint-Sparse-Representation" class="headerlink" title="Face Aging Effect Simulation using Hidden Factor Analysis Joint Sparse Representation"></a>Face Aging Effect Simulation using Hidden Factor Analysis Joint Sparse Representation</h1><p>Accept: 2016IEEE Transactions on Image Processing</p>
<ul>
<li>问题<ol>
<li>衰老的复杂性：人脸衰老涉及共同的规则和独特的模式。人们有着与年龄相关的相似变化，其中包括皱纹的加剧和轮廓的增长；而不同的遗传因素为不同的个体引入了随机性和多样性，使衰老过程彼此不同。此外，许多外部因素也对其产生影响。例如，生活方式会延迟或加速一个人的衰老速度，而化妆品与配饰一起会导致面部外观与其实际年龄之间出现偏差。所有这些原因增加了年龄发展过程中的不确定性和外观预测的难度。</li>
<li>数据收集：最近的大多数年龄发展方法都是以数据为驱动力的，其中从训练样本中了解衰老模式和与年龄相关的特征。因此，数据收集对于生成此类统计模型至关重要。只有在训练阶段涵盖足够的老化变化和皮肤细节的前提下，合成结果才有意义且可信。由于缺乏老年人的图像，或者迫于需求一个人长期衰老图片，现有的公开可用的面部衰老数据库远远不够。</li>
<li>其他干扰：使老化合成成为一项具有挑战性的任务的另一个原因是，实际的探针面通常会在表情，姿势和光照方面发生变化；因此，应该考虑使用健壮的老化模型。  </li>
</ol>
<ul>
<li>由于上述的复杂老化模型未解决问题的存在，在当前的老化模拟研究中，大多数其他干扰仍然受到严格限制。</li>
</ul>
</li>
<li>贡献<ol>
<li>为了解决常见的数据短缺问题，我们收集了一个数据库，该数据库包含来自Internet的2,000多个面部图像，年龄从1到70岁，并且在每个面部上手动标记了68个地标</li>
<li>我们提出了一种新颖且通用的方法来进行面部衰老效果模拟，分别对在较长时期内趋于稳定的个人特定属性和随时间逐渐变化的提示进行建模。 </li>
<li>我们将稀疏表示应用于面部衰老效果综合问题，该问题通过考虑与输入面部的一致性来更好地重建与年龄相关的分量，从而使合成的纹理更加自然。</li>
</ol>
</li>
<li>属于原型方法</li>
</ul>
<h1 id="Face-Aging-With-Conditional-Generative-Adversarial-Networks（AC-GAN）"><a href="#Face-Aging-With-Conditional-Generative-Adversarial-Networks（AC-GAN）" class="headerlink" title="Face Aging With Conditional Generative Adversarial Networks（AC-GAN）"></a>Face Aging With Conditional Generative Adversarial Networks（AC-GAN）</h1><p>Accept: 2017ICIP</p>
<ul>
<li>问题<ol>
<li>原型制作方法可估计预定义年龄组内的平均面孔。这些面部之间的差异构成了老化模式，该老化模式进一步用于将输入的面部图像转换为目标年龄组。原型方法既简单又快速，但是由于它们基于通用规则，因此它们完全丢弃了个性化信息，从而导致图像不真实。</li>
<li>建模方法采用参数模型来模拟特定个体的肌肉，皮肤和头骨的衰老机制。然而，这些方法通常需要具有很大年龄范围的同一人的面部老化序列，这非常昂贵。提出的传统人脸老化方法仅限于对人脸的整体理解（其人格特征，面部表情，可能的面部配件等）缺失的衰老模式的建模。</li>
<li>在许多实际使用案例中，必须进行人脸老化结合其他面部更改，例如添加太阳镜或胡须。</li>
<li>以前基于GAN的人脸修改方法的一个普遍问题，即原始人的身份经常在修改后的图像中丢失。因此，在本研究中，我们着重于保持身份的面部老化。</li>
</ol>
</li>
<li>贡献<ol>
<li>我们设计了Age-cGAN（年龄条件生成对抗网络），这是<strong>第一个生成所需年龄类别内高质量合成图像的GAN</strong>。</li>
<li>我们提出了一种新颖的潜在向量优化方法，该方法允许Age-cGAN重建输入的人脸图像，以保留原始人的身份。（这种方法具有通用性，意味着它不仅可以用于保留脸部衰老的身份，还可以用于其他脸部更改（例如添加胡须，太阳镜等）的身份。）</li>
</ol>
</li>
<li>缺点<ol>
<li>图像重构损失函数错误（DualGAN，在训练过程中使用一个年龄label，但是测试过程中使用图像和不同的年龄label来进行测试）</li>
<li>强制执行身份一致性，不足以消除未配对训练数据中的匹配歧义（Attribute-aware Face Aging with Wavelet-based Generative Adversarial Networks）</li>
<li>尽管保留了身份，但对于年龄而言，这些方法仅考虑了年龄组之间的人口到人口的过渡，而没有明确考虑不同年龄之间的每个人的个性化过渡模式（S2GAN）</li>
</ol>
</li>
<li>方法<br><img src="https://z3.ax1x.com/2021/09/19/48Yi59.png" alt="48Yi59"></li>
</ul>
<p>后续再继续搬…（咕咕咕</p>
]]></content>
      <categories>
        <category>PAPER</category>
      </categories>
      <tags>
        <tag>gan</tag>
        <tag>aging</tag>
      </tags>
  </entry>
  <entry>
    <title>可逆神经网络flow的理解</title>
    <url>/2021/10/04/Paper/Paper-INN-Theory/</url>
    <content><![CDATA[<p><strong>本文参考</strong></p>
<ul>
<li><a href="https://spaces.ac.cn/archives/5776/comment-page-3#comments">苏神博客-细水长flow之NICE：流模型的基本概念与实现</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/43157737">flow-based生成模型</a></li>
</ul>
<h1 id="分布问题"><a href="#分布问题" class="headerlink" title="分布问题"></a>分布问题</h1><p>在生成网络中，我们知道的是样本x，即训练数据，我们希望通过概率模型$q_θ(x)$来拟合真实样本$x$，其中$θ$即模型中的参数。</p>
<p>由于我们是不知道真实数据的分布(只有真实数据)，想直接用KL Loss去拟合样本数据和真实数据是不可能的。对于连续型分布，我们可以将样本分布改为<br>$$<br>q(x) = ∫q(z)q(x|z)dz<br>$$<br>其中$q(x|z)$描述了一个由$z$来生成$x$的模型，其中$q(z)$一般是标准高斯分布。</p>
<details>
<summary>最大似然：</summary>
给定一个概率分布函数$f_D$，以及一个分布参数$θ$，我们可以从这个分布中抽出一个具有n个值的采样$X1,X2,...,Xn$，通过利用$f_D$，我们就能计算出其概率：
$$
P=(x_1,x_2,...,x_n)=f_D(x_1,x_2,...,x_n|θ)
$$
最大似然就是我们寻找参数$θ$，使得这个采样的可能性最大(最大化拟合分布)，定义可能性为
$$
lik(θ)=f_D(x_1,x_2,...,x_n|θ)
$$
在θ的所有取值上，使这个函数最大化。这个使可能性最大的值即被称为$θ$的最大似然估计。
</details>


<p>已知分布形式，要想求出参数$θ$，我们可以利用最大似然(求出网络中的参数)。<br>$$<br>E_{x{\sim}p(x)}[log q(x)]<br>$$<br>只要我们能够最大化上面的似然值，那么我们找到的$θ$就是最能够拟合真实分布的网络参数。</p>
<ul>
<li><p>VAE<br>在VAE中，其通过优化$z$和标准正太分布靠近，且$z$又是通过encoder来进行采样的，即假设后验分布$p(z|x)$是正太分布，从而对于正太分布中的一个$z$，能找到一个相应的$x$。VAE是优化一个更强的上界，这使得它只能是一个近似模型，无法达到良好的生成效果。</p>
</li>
<li><p>GAN<br>利用对抗学习的方式，和求这个最大似然估计参数无关，用交替训练来使得模型精度不断提升。</p>
</li>
</ul>
<h1 id="可逆神经网络"><a href="#可逆神经网络" class="headerlink" title="可逆神经网络"></a>可逆神经网络</h1><p>在flow模型中，则是直接求取这个最大似然的值。<br>$$<br>E_{x{\sim}p(x)}[log q(x)]=log\prod_{i=1}^nq(x_i)<br>$$</p>
<p>假设我们寻找变换$z=f(x)$，使得数据映射到新空间，且各个维度相互独立。<br>$$<br>q(z)=\prod_{i=1}^nq(z_i)<br>$$<br>假设$f(x)$是可逆的，并且$z$的维度与$x$的维度相同。由概率密度的变量代换我们有:</p>
<p>$$<br>q(x)=\prod_{i=1}^nq(f(x_i)){\begin{matrix}|det\frac{ {\partial}f}{x}| \end{matrix} }<br>$$<br>其中${\begin{matrix}|det\frac{ {\partial}f}{x}| \end{matrix} }$为“雅可比行列式”的绝对值，在空间转换中，雅可比矩阵描述了向量空间中的运行变换，从$n$维空间转换到$m$维空间，当$m=n$，即雅可比行列式，代表了两个空间中体积比率。</p>
<p>在这里，对于flow模型，就需要有两个要求</p>
<ol>
<li>可逆，并且易于求逆函数（它的逆g就是我们希望的生成模型）；</li>
<li>对应的雅可比行列式容易计算。</li>
</ol>
<p>这样，需要要最大化最大似然，就能优化模型求得真实分布：<br>$$<br>E_{x{\sim}p(x)}[log q(x)]=log\prod_{i=1}^nq(x_i)=log\prod_{i=1}^nq(f(x_i)){\begin{matrix}|det\frac{ {\partial}f}{x}| \end{matrix} }<br>$$<br>当$f(x)$为标准高斯分布时<br>$$<br>E_{x{\sim}p(x)}[log q(x)]=logq(x)=\sum_{i=0}^n{-\frac{D}{2}log(2{\pi})-\frac{1}{2}\begin{Vmatrix}f(x_i)\end{Vmatrix}^2+log{\begin{matrix}|det\frac{ {\partial}f}{x}| \end{matrix} } }<br>$$<br>在实际的网络训练中，为了最小化loss，通常使用负对数似然损失，即在上面的公式中加上一个符号，同时去掉第一个常数。通过优化这个损失，当训练完成，我们就可以随机采样一个$z$，然后通过$f$的逆来生成一个样本$f^{−1}(z)=g(z)$，这就得到了生成模型。</p>
]]></content>
      <categories>
        <category>PAPER</category>
      </categories>
      <tags>
        <tag>INN</tag>
      </tags>
  </entry>
  <entry>
    <title>Paper-StyleGAN-V1</title>
    <url>/2021/09/19/Paper/Paper-StyleGAN-V1/</url>
    <content><![CDATA[<h1 id="A-Style-Based-Generator-Architecture-for-Generative-Adversarial-Networks"><a href="#A-Style-Based-Generator-Architecture-for-Generative-Adversarial-Networks" class="headerlink" title="A Style-Based Generator Architecture for Generative Adversarial Networks"></a>A Style-Based Generator Architecture for Generative Adversarial Networks</h1><p>Accept:CVPR2019<br>code：github上一搜一大把(官方非官方，tf或者pytorch)</p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h2><p>生成更加真实多样且高清的图像</p>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p><img src="https://z3.ax1x.com/2021/09/19/48QdpT.png" alt="48QdpT"></p>
<ul>
<li>上图(a)为ProgressiveGAN(Progressive growing of GANs for improved quality, stability, and variation)，作者就是在这篇的基础上进行改进；  </li>
<li>上图(b)为StyleGAN的框架。</li>
</ul>
<ol>
<li>隐空间变换<br>首先通过8层的FC将随机采样的z改为了w，这样做的好处就是一般z都是从高斯分布进行采样，但是实际上高斯分布和真实数据的分布是不同的，因此将z变换到w空间能更好的对生成网络进行一个控制(个人觉得就是一个hard变为soft的过程，原先的先验采样z太hard了，如果转换到w空间，就能更好地拟合出真实样本的部分)</li>
<li>生成网络<br>生成网络的输入不再是z，而是三部分，分别为上图(b)的Const 4×4×512，AdaIN变换的参数A(由w得到)以及随机噪声B。生成网络一共有9个块[4×4, 8×8, .., 1024×1024]，每个块中有两层卷积(除了第一层)，最后一层使用1×1卷积来转换通道数。</li>
</ol>
<h2 id="Style-Mixing"><a href="#Style-Mixing" class="headerlink" title="Style Mixing"></a>Style Mixing</h2><p><img src="https://z3.ax1x.com/2021/09/19/481AII.png" alt="481AII"><br>采样两个z，z1和z2，再经过Mapping网络得到w1和w2</p>
<ol>
<li>(4×4-8×8)两个块使用SourceB的w，其余块使用SouceA的w</li>
</ol>
<p>修改高级语义，比如姿势，发型，脸型和眼镜等，而像一些眼睛，头发光线等则保持不变</p>
<ol start="2">
<li>(16×16-32×32)两个块使用SourceB的w，其余块使用SouceA的w</li>
</ol>
<p>继承了B的较小比例的面部特征，比如发型，睁开/闭上的眼睛，而A的姿势，脸型和眼镜则保留下来</p>
<ol start="3">
<li>(64×64-1024×1024)两个块使用SourceB的w，其余块使用SouceA的w</li>
</ol>
<p>主要是一些颜色和细微结构的变化，整体的语义保持不变</p>
<embed src="https://openaccess.thecvf.com/content_CVPR_2019/papers/Karras_A_Style-Based_Generator_Architecture_for_Generative_Adversarial_Networks_CVPR_2019_paper.pdf" width="100%" height="1000" type="application/pdf">]]></content>
      <categories>
        <category>PAPER</category>
      </categories>
      <tags>
        <tag>gan</tag>
        <tag>stylegan</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN Prior Embedded Network for Blind Face Restoration in the Wild</title>
    <url>/2021/09/12/Paper/Paper-Stylegan-GPEN/</url>
    <content><![CDATA[<h1 id="Paper-GAN-Prior-Embedded-Network-for-Blind-Face-Restoration-in-the-Wild"><a href="#Paper-GAN-Prior-Embedded-Network-for-Blind-Face-Restoration-in-the-Wild" class="headerlink" title="Paper:GAN Prior Embedded Network for Blind Face Restoration in the Wild"></a>Paper:GAN Prior Embedded Network for Blind Face Restoration in the Wild</h1><p>Accept:CVPR2021<br><a href="https://github.com/yangxy/GPEN">Code</a></p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h2><p>野外人脸复原(Blind face restoration)，属于人脸复原任务中的一种，类似于超分，inpainting等工作。文章为了解决野外人脸的退化复杂性(噪声，缺损，分辨率低等)，提出了解决方法。</p>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p><img src="https://z3.ax1x.com/2021/09/12/49IYlD.png" alt="49IYlD"><br>在原先的styelgan中，需要W和noise，也就是调制模块中的A和B。  </p>
<ul>
<li>w：<br>将W修改为encoder得到的z，再经过mapping网络得到W。</li>
<li>noise:<br>使用encoder中的浅层空间信息，同时这里作者将原先直接add的方式修改为concat，并在后续的实验中验证这两种方式的优劣。<br>通过这种方法，作者认为可以比较好地结合全局信息(w,也就是z,感受野更大)和局部信息(noise,感受野更小)，从而使得生成图像的质量更好。<br>和之前基于stylegan的方法不同的是，作者这里对stylegan进行了finetune。</li>
</ul>
<embed src="https://arxiv.org/pdf/2105.06070.pdf#toolbar=1&navpanes=1&scrollbar=1" width="100%" height="1000" type="application/pdf">]]></content>
      <categories>
        <category>PAPER</category>
      </categories>
      <tags>
        <tag>stylegan</tag>
        <tag>blind face restoratio</tag>
      </tags>
  </entry>
  <entry>
    <title>Paper-Stylegan-Image2StylegGAN</title>
    <url>/2021/09/19/Paper/Paper-Stylegan-Image2Stylegan/</url>
    <content><![CDATA[<h1 id="Image2StyleGAN-How-to-Embed-Images-Into-the-StyleGAN-Latent-Space"><a href="#Image2StyleGAN-How-to-Embed-Images-Into-the-StyleGAN-Latent-Space" class="headerlink" title="Image2StyleGAN: How to Embed Images Into the StyleGAN Latent Space?"></a>Image2StyleGAN: How to Embed Images Into the StyleGAN Latent Space?</h1><p>Accept: 2019ICCV</p>
<h2 id="Problem："><a href="#Problem：" class="headerlink" title="Problem："></a>Problem：</h2><p>基于优化(optimized-based)的StyleGAN反转</p>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p>提出w+空间。即优化的latent code由原先stylegan的w变为w+(原先stylegan的w空间是通过复制然后送入styleblock进行调制，即18个w是完全相同的)</p>
<ul>
<li><strong>LOSS</strong></li>
<li>perceptual loss and pixel-wise MSE loss<br>$$<br>w^∗ = \min_{w}L_percept(G(w), I) + \frac{λ_{mse}}{N}{\begin{Vmatrix}G(w) −I\end{Vmatrix}}_2^2<br>$$</li>
<li>perceptual loss<br>$$<br>L_{percept}(I_1, I_2) = \sum_{j=1}^4\frac{λ_j}{N_j}{\begin{Vmatrix}F_j (I_1) −F_j (I_2)\end{Vmatrix}}_2^2<br>$$<br>perceptual loss的计算分别使用 VGG-16的$conv$1_1, $conv$1_2, $conv$3_2, $conv$4_2</li>
</ul>
<embed src="https://openaccess.thecvf.com/content_ICCV_2019/papers/Abdal_Image2StyleGAN_How_to_Embed_Images_Into_the_StyleGAN_Latent_Space_ICCV_2019_paper.pdf" width="100%" height="1000" type="application/pdf">
]]></content>
      <categories>
        <category>PAPER</category>
      </categories>
      <tags>
        <tag>stylegan</tag>
        <tag>inversion</tag>
      </tags>
  </entry>
  <entry>
    <title>Telegram需要旧手机验证/收不到验证码100%可用解决方法</title>
    <url>/2026/01/20/Proxy/telegram%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p><a href="https://071400.xyz/2025/06/telegram-code/">参考文章</a></p>
<p>新版本 telegram 登录会有收不到短信验证码以及需要缴费的情况</p>
<p>之前可以使用 telegramX 进行登录，但是最新版本也不行</p>
<p>所以解决方法就是下载旧的 telegramX，登录后通过 QR code 登录 PC 的 telegram 就行了</p>
<p>这里主要记录可用的 telegramX 版本（<a href="https://github.com/TGX-Android/Telegram-X/tree/v0.27.10.1752">v0.27.10.1752</a>）</p>
<p>如果需要汉化，直接在你的设备上点开这串网址即可：<a href="https://t.me/setlanguage/zhcncc">https://t.me/setlanguage/zhcncc</a></p>
]]></content>
      <categories>
        <category>PROXY</category>
        <category>Telegram</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>v2rayN</title>
    <url>/2021/09/10/Proxy/v2rayN/</url>
    <content><![CDATA[<h1 id="解决最新版本v2rayN绕过大陆-PAC-设置问题"><a href="#解决最新版本v2rayN绕过大陆-PAC-设置问题" class="headerlink" title="解决最新版本v2rayN绕过大陆(PAC)设置问题"></a>解决最新版本v2rayN绕过大陆(PAC)设置问题</h1><ul>
<li><p>GitHub上的<a href="https://github.com/2dust/v2rayN/wiki">Wiki</a>对代理模式进行了解释</p>
<ol>
<li>清除系统代理: 每次启动/重启服务的时候,强制把windows系统(ie)的代理清除掉</li>
<li>自动配置系统代理: 每次启动/重启服务的时候,强制设定windows系统(ie)的代理</li>
<li>不改变系统代理: 每次启动/重启服务的时候,什么都不做.作用就是保留其他软件设定的代理</li>
</ol>
</li>
<li><p>解决方法</p>
<ol>
<li>v2rayN版本:<strong>4.20</strong><br>v2ray版本:<strong>4.25</strong></li>
<li>在检查更新中更新 <strong>geoip</strong> 和 <strong>geosite</strong> 文件，这两个文件包含一些含一些国内IP和域名</li>
<li>依次点击<strong>设置-路由设置-基础功能-一键导入基础规则</strong></li>
<li>选择<strong>启用高级路由</strong>，然后选择<strong>全局</strong>或者<strong>绕过大陆</strong></li>
<li>在绕过大陆的规则中，可以自定义白名单，在<strong>规则功能</strong>中<strong>添加规则</strong>，选择代理或者直连，并填上你想要添加的网站，左边填域名，右边填IP</li>
<li>系统代理 选择 <strong>自动配置系统代理</strong><br>路由高级功能 选择 <strong>绕过大陆</strong></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>PROXY</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>python-plt</title>
    <url>/2021/08/01/Python/Python-Plt/</url>
    <content><![CDATA[<h1 id="python中Plt库相关函数"><a href="#python中Plt库相关函数" class="headerlink" title="python中Plt库相关函数"></a>python中Plt库相关函数</h1><p><strong>只讲使用，不讲参数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建画布，画布大小（长，高），提供了顶层Artist</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">16</span>, <span class="number">8</span>))</span><br><span class="line"><span class="comment"># 将画布分割为2*4的8个子块，控制所有图元的子图和顶层容器的默认间距</span></span><br><span class="line">gs = fig.add_gridspec(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 创建一个子图[行位置，列位置]</span></span><br><span class="line">fig.add_subplot(gs[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># 自动调整子图参数，使之填充整个图像区域</span></span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Plt</tag>
      </tags>
  </entry>
  <entry>
    <title>python-二维码</title>
    <url>/2021/08/01/Python/Python-%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
    <content><![CDATA[<h1 id="python-压缩文本内容并生成二维码"><a href="#python-压缩文本内容并生成二维码" class="headerlink" title="python 压缩文本内容并生成二维码"></a>python 压缩文本内容并生成二维码</h1><h2 id="单文本压缩并生成二维码"><a href="#单文本压缩并生成二维码" class="headerlink" title="单文本压缩并生成二维码"></a>单文本压缩并生成二维码</h2><p><strong>需求：</strong> 对文本内容进行压缩，并生成二维码，二维码中包含压缩后的文本内容。解码时，对二维码中的内容进行解压缩，还原文本内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> qrcode</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compress_text</span>():</span><br><span class="line">    <span class="comment"># 要压缩的文本</span></span><br><span class="line">    text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这是一个需要压缩并生成二维码的文本内容。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 压缩文本</span></span><br><span class="line">    compressed_data = zlib.compress(text.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将压缩后的二进制数据编码为 Base64 字符串（方便二维码存储）</span></span><br><span class="line">    compressed_base64 = base64.b64encode(compressed_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成二维码</span></span><br><span class="line">    qr = qrcode.QRCode(</span><br><span class="line">        version=<span class="number">1</span>, <span class="comment"># 控制二维码的大小，范围是 1 到 40。值越大，二维码的尺寸越大。</span></span><br><span class="line">        error_correction=qrcode.constants.ERROR_CORRECT_L, <span class="comment">#</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        error_correction: 容错率，支持 4 个级别：</span></span><br><span class="line"><span class="string">        ERROR_CORRECT_L: 约 7% 的错误可以纠正。</span></span><br><span class="line"><span class="string">        ERROR_CORRECT_M: 约 15% 的错误可以纠正（默认）。</span></span><br><span class="line"><span class="string">        ERROR_CORRECT_Q: 约 25% 的错误可以纠正。</span></span><br><span class="line"><span class="string">        ERROR_CORRECT_H: 约 30% 的错误可以纠正。</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        box_size=<span class="number">10</span>, <span class="comment"># 每个“盒子”的像素大小</span></span><br><span class="line">        border=<span class="number">4</span>, <span class="comment"># 二维码边框的宽度（单位为盒子数</span></span><br><span class="line">    )</span><br><span class="line">    qr.add_data(compressed_base64)  <span class="comment"># 将 Base64 字符串添加到二维码</span></span><br><span class="line">    qr.make(fit=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建二维码图像</span></span><br><span class="line">    img = qr.make_image(fill_color=<span class="string">&quot;black&quot;</span>, back_color=<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存二维码图像</span></span><br><span class="line">    img.save(<span class="string">&quot;compressed_qr.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示二维码图像</span></span><br><span class="line">    img.show()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;二维码已生成并保存为 compressed_qr.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decompress_text</span>():</span><br><span class="line">    <span class="comment"># 假设这是从二维码中扫描得到的 Base64 字符串</span></span><br><span class="line">    scanned_base64 = <span class="string">&quot;eJyNVMlO20AYvvsprPQQR6GmSClFSD6wqaJFMg1UUU/WxJk408R2MnYAcaOtSigQOFCWplWR2lKqAkUIsSVKXsZLeuIVOl6SQBapPo2/mf//vn+lkJxVsU4vZlCc8s9xoMHBSOMvh0U1AakkVmV6enKK9uFJGUiQoqgETNKiKmcx1DRBhws6ExqmaPI9oOsHS2Zx1a78sj+9s7aXrc9HlH/jwT7mQA0PMCEkgA5ozhXENmDGccxCxVHCBPN68uFQMBRqejt97zk0N4uEyrhZq9dKZuHC+nhqrZ/YlW17f8m4uqFH3bho83jHPjowrs5uKwVr+9qo1oiFXT4nr8zjXfPN4W1lpV2UlxIiyzuw8cGIr6ZNeYhNwHsqGyLtra9WYbPJ5KI5TDx6+WVfRMccMxd3vjmINaQq3EBfE4IYq1gQVYyhqDt3vqmoKpoOFF1jJ6JRPiqM8dHoxNisMNUyjasLgoYWITfw6C6IExBzEQ8J+ZJYkPBCYTriD/nZ7sikdVk2P+ybhdP2+FgZpCGTRDo3i/OwVbFCySzftNJeqppvN9w7JEtuTlxDATlNRswzGRJ2RsVcIJ4BYjrQR+ogphvYfArpMNB0btS+kDr2cM5qYA4ygTuhEa6sIrXMrd2q/b2XNlZLqfOM/zaLkaIzgdbTyzOvyub1hS+CdF1XKndsnE7pOjjm0nL9pFqv7Vm7f4xysUlgXB1bK7+tjQ2zukOSTXq9oxKuB00EinK3awPw2fzo9Mj4eH8Y9csQvMLhmYjEz0RyeVmUeBIYjPEoDIdyMPZYz8OXShhMpvmZwdc8fKLzUJIgBCkexFJhIGI+9jQFY/k85EckxMPnSpoLuPNe2/u7vGaXzq3iD3vr0LheNVfWvYx0ldpYEz+/kdg6rknu2ia5x6ZojaQ/evfD77k2CK+3NrrRqBhJSAEZtzKNddQq2H+Ovd8hTSZvQXl7b5h08T0Wpy1QkhYEBchQEGiOo4OCIAOkCELQa42OjvFo/gEUIGjR&quot;</span>  <span class="comment"># 这里直接用之前生成的 Base64 字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解码 Base64 字符串为二进制数据</span></span><br><span class="line">    compressed_data = base64.b64decode(scanned_base64.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解压缩二进制数据</span></span><br><span class="line">    original_text = zlib.decompress(compressed_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;解压缩后的文本:&quot;</span>, original_text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    compress_text()</span><br><span class="line">    decompress_text()</span><br></pre></td></tr></table></figure>

<h2 id="长文本分片压缩并生成二维码"><a href="#长文本分片压缩并生成二维码" class="headerlink" title="长文本分片压缩并生成二维码"></a>长文本分片压缩并生成二维码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> qrcode</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compress_text</span>():</span><br><span class="line">    <span class="comment"># 要压缩的长文本</span></span><br><span class="line">    long_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这是一个需要压缩并生成二维码的长文本内容。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 压缩文本</span></span><br><span class="line">    compressed_data = zlib.compress(long_text.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;压缩后的二进制数据:&quot;</span>, compressed_data)</span><br><span class="line">    <span class="comment"># 将压缩后的二进制数据分块（每块最大 2953 字节，适合二维码存储）</span></span><br><span class="line">    chunk_size = <span class="number">2200</span>  <span class="comment"># 二维码最大容量约为 3KB，Base64 编码后会略微增加</span></span><br><span class="line">    chunks = [compressed_data[i:i + chunk_size] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(compressed_data), chunk_size)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成二维码</span></span><br><span class="line">    <span class="keyword">for</span> i, chunk <span class="keyword">in</span> <span class="built_in">enumerate</span>(chunks):</span><br><span class="line">        <span class="comment"># 将二进制数据编码为 Base64 字符串</span></span><br><span class="line">        chunk_base64 = base64.b64encode(chunk).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加块信息（例如：块编号/总块数）</span></span><br><span class="line">        chunk_info = <span class="string">f&quot;<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(chunks)&#125;</span>:<span class="subst">&#123;chunk_base64&#125;</span>&quot;</span></span><br><span class="line">        <span class="comment"># print(f&quot;生成二维码块 &#123;i + 1&#125;:&quot;, chunk_info)</span></span><br><span class="line">        <span class="comment"># 创建二维码对象</span></span><br><span class="line">        qr = qrcode.QRCode(</span><br><span class="line">            version=<span class="number">40</span>,  <span class="comment"># 最大版本（40）</span></span><br><span class="line">            error_correction=qrcode.constants.ERROR_CORRECT_L,  <span class="comment"># 容错率</span></span><br><span class="line">            box_size=<span class="number">10</span>,</span><br><span class="line">            border=<span class="number">4</span>,</span><br><span class="line">        )</span><br><span class="line">        qr.add_data(chunk_info)</span><br><span class="line">        qr.make(fit=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 生成二维码图像</span></span><br><span class="line">        img = qr.make_image(fill_color=<span class="string">&quot;black&quot;</span>, back_color=<span class="string">&quot;white&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 保存二维码图像</span></span><br><span class="line">        img.save(<span class="string">f&quot;qr_chunk_<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>.png&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;二维码块 <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> 已保存为 qr_chunk_<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有二维码已生成。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decompress_text</span>():</span><br><span class="line">    <span class="comment"># 假设这是从二维码中扫描得到的 Base64 字符串列表</span></span><br><span class="line">    scanned_base64_list = [</span><br><span class="line">        <span class="string">&quot;1/2:eJzT0yMAAGTvBe8=&quot;</span>,  <span class="comment"># 示例 Base64 字符串（块 1/2）</span></span><br><span class="line">        <span class="string">&quot;2/2:eJzT0yMAAGTvBe9=&quot;</span>,  <span class="comment"># 示例 Base64 字符串（块 2/2）</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按块编号排序</span></span><br><span class="line">    scanned_base64_list.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>].split(<span class="string">&quot;/&quot;</span>)[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    compressed_data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i, chunk <span class="keyword">in</span> <span class="built_in">enumerate</span>(scanned_base64_list):</span><br><span class="line">        chunk_base64 = chunk.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解码 Base64 字符串为二进制数据</span></span><br><span class="line">        compressed_chunk = base64.b64decode(chunk_base64.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        compressed_data += compressed_chunk</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 解压缩二进制数据</span></span><br><span class="line">    original_text = zlib.decompress(compressed_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;解压缩后的文本:&quot;</span>, original_text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存解压缩后的文本（如果解码后的数据较大，某些环境（如终端或日志）可能会自动截断输出）</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output_file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(original_text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    compress_text()</span><br><span class="line">    decompress_text()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-语法</title>
    <url>/2021/08/17/Python/Python-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Python语法记录"><a href="#Python语法记录" class="headerlink" title="Python语法记录"></a>Python语法记录</h1><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul>
<li>创建列表,获取长度  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 已知元素</span></span><br><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 未知元素</span></span><br><span class="line">mylist = []</span><br><span class="line">mylist.append(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 获取长度</span></span><br><span class="line">length = <span class="built_in">len</span>(mylist)</span><br></pre></td></tr></table></figure></li>
<li>对list所有元素执行统一操作  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不想写循环的话,且不想改变原列表元素</span></span><br><span class="line">test = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line">test1 = [x+<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> test] <span class="comment"># [2, 3, 4, 5, 6]</span></span><br><span class="line">test2 = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x+<span class="number">1</span>, test)) <span class="comment"># [2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2>array数组在python中是不可改变的</li>
<li>创建array  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">test = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="comment"># 获取形状</span></span><br><span class="line">shape = test.shape</span><br><span class="line"><span class="comment">#获取部分元素</span></span><br><span class="line">part = test[<span class="number">2</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h2><ul>
<li>获取字典的key值  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">dict</span>:</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"><span class="keyword">for</span> i, key <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">dict</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;the <span class="subst">&#123;i&#125;</span> key:&quot;</span>, key)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">dict</span>.keys():</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure></li>
<li>获取字典键值对  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出为数组，例如(&#x27;key&#x27;,&#x27;value&#x27;)</span></span><br><span class="line"><span class="keyword">for</span> kv <span class="keyword">in</span> <span class="built_in">dict</span>.items():</span><br><span class="line">    <span class="built_in">print</span>(kv)</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">dict</span>.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>:<span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="sort-amp-sorted"><a href="#sort-amp-sorted" class="headerlink" title="sort &amp; sorted"></a>sort &amp; sorted</h2><ul>
<li>sort<br>list内置的sort()函数(只适用于list)，本身不会返回新的list，会改变原先的list的顺序(节省空间，提高效率)  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">my_list.sort()  <span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li>
<li>sorted<br>sorted()函数适用于任意可以迭代的对象排序，不会改变原对象，返回一个新的可迭代对象  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">result = <span class="built_in">sorted</span>(my_list)  <span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h2 id="cv2"><a href="#cv2" class="headerlink" title="cv2"></a>cv2</h2></li>
<li>cv2.resize()<br>要求size为integer，否则报错  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2img = cv2.resize(cv2img, (size1, size2))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用f-string保留小数点位数"><a href="#使用f-string保留小数点位数" class="headerlink" title="使用f-string保留小数点位数"></a>使用f-string保留小数点位数</h2><p><strong>参考文章</strong>  </p>
<ul>
<li><p><a href="https://blog.csdn.net/zlbingo/article/details/116946961">Python：使用f-string保留小数点位数</a></p>
</li>
<li><p>格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">f<span class="string">&quot;&#123;num:xxx&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面xxx的格式如下：</p>
<table>
<thead>
<tr>
<th align="left">格式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">width</td>
<td align="left">整数width指定宽度</td>
</tr>
<tr>
<td align="left">0width</td>
<td align="left">整数width指定宽度，0表示最高位用0补足宽度</td>
</tr>
<tr>
<td align="left">width.precision</td>
<td align="left">整数width指定宽度，整数precision表示精度（保留小数点后几位小数）</td>
</tr>
</tbody></table>
</li>
<li><p>实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123.456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只指定widthc</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;<span class="subst">&#123;a:<span class="number">10</span>&#125;</span>&quot;</span></span><br><span class="line"><span class="string">&#x27;123.456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定0width</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;<span class="subst">&#123;a:<span class="number">0</span>10&#125;</span>&quot;</span></span><br><span class="line"><span class="string">&#x27;000123.456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用width.precision</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;<span class="subst">&#123;a:<span class="number">10.1</span>f&#125;</span>&quot;</span></span><br><span class="line"><span class="string">&#x27;123.5&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;<span class="subst">&#123;a:<span class="number">.2</span>f&#125;</span>&quot;</span></span><br><span class="line"><span class="string">&#x27;123.46&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch-Q&amp;A</title>
    <url>/2021/08/09/Pytorch/Pytorch-Q&amp;A/</url>
    <content><![CDATA[<h1 id="Pytorch-Bug记录"><a href="#Pytorch-Bug记录" class="headerlink" title="Pytorch Bug记录"></a>Pytorch Bug记录</h1><h2 id="RuntimeError-view-size-is-not-compatible-with-input-tensor-39-s-size-and-stride-at-least-one-dimension-spans-across-two-contiguous-subspaces-Use-reshape-instead"><a href="#RuntimeError-view-size-is-not-compatible-with-input-tensor-39-s-size-and-stride-at-least-one-dimension-spans-across-two-contiguous-subspaces-Use-reshape-instead" class="headerlink" title="RuntimeError: view size is not compatible with input tensor&#39;s size and stride (at least one dimension spans across two contiguous subspaces). Use .reshape(...) instead."></a><code>RuntimeError: view size is not compatible with input tensor&#39;s size and stride (at least one dimension spans across two contiguous subspaces). Use .reshape(...) instead.</code></h2><ul>
<li>解决方法<br>view()需要Tensor中的元素地址是连续的，但可能出现Tensor不连续的情况，所以先用 .contiguous() 将其在内存中变成连续分布：  </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out = out.contiguous().view(out.size()[<span class="number">0</span>], -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="RuntimeError-The-size-of-tensor-a-32-must-match-the-size-of-tensor-b-28-at-non-singleton-or-ValueError-expected-sequence-of-length-51-at-dim-1-got-0"><a href="#RuntimeError-The-size-of-tensor-a-32-must-match-the-size-of-tensor-b-28-at-non-singleton-or-ValueError-expected-sequence-of-length-51-at-dim-1-got-0" class="headerlink" title="RuntimeError: The size of tensor a (32) must match the size of tensor b (28) at non-singleton or ValueError: expected sequence of length 51 at dim 1 (got 0)"></a><code>RuntimeError: The size of tensor a (32) must match the size of tensor b (28) at non-singleton</code> or <code>ValueError: expected sequence of length 51 at dim 1 (got 0)</code></h2><ul>
<li>问题及解决<br>pytorch中将list转为tensor的时候，如果list中长度不同会报维度不匹配的错误，查看list中的元素寻找解决方法</li>
</ul>
<h2 id="RTX3090运行stylegan编译不成功"><a href="#RTX3090运行stylegan编译不成功" class="headerlink" title="RTX3090运行stylegan编译不成功"></a><code>RTX3090运行stylegan编译不成功</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> TORCH_CUDA_ARCH_LIST=<span class="string">&quot;8.0&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="RuntimeError-The-size-of-tensor-a-4-must-match-the-size-of-tensor-b-3-at-non-singleton-dimension-0"><a href="#RuntimeError-The-size-of-tensor-a-4-must-match-the-size-of-tensor-b-3-at-non-singleton-dimension-0" class="headerlink" title="RuntimeError: The size of tensor a (4) must match the size of tensor b (3) at non-singleton dimension 0"></a><code>RuntimeError: The size of tensor a (4) must match the size of tensor b (3) at non-singleton dimension 0</code></h2><ul>
<li>问题出在<code>tensor.sub_(mean[:, None, None]).div_(std[:, None, None])</code><br>在读取PNG图片然后进行transform的正则化过程中，Image会读取成RGBA，即四个通道，一般在做图像处理只读取三个通道，所以归一化也只做三个通道，因此报错</li>
<li>解决办法<br>加上.convert(‘RGB’)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;img_path&quot;</span>).convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="torch-utils-cpp-extension-load卡住无响应"><a href="#torch-utils-cpp-extension-load卡住无响应" class="headerlink" title="torch.utils.cpp_extension.load卡住无响应"></a><code>torch.utils.cpp_extension.load卡住无响应</code></h2><p><strong>参考文章</strong></p>
<ul>
<li><a href="https://blog.csdn.net/qq_38677322/article/details/109696077">torch.utils.cpp_extension.load卡住无响应</a></li>
</ul>
<p>主要原因是因为读写锁，在home/username/的路径下的.cache文件中，找到torch_extensions文件夹，然后寻找里面的文件夹是否存在lock文件，存在删除即可。</p>
<h2 id="TypeError-Caught-TypeError-in-DataLoader-worker-process-0"><a href="#TypeError-Caught-TypeError-in-DataLoader-worker-process-0" class="headerlink" title=" TypeError: Caught TypeError in DataLoader worker process 0"></a><code> TypeError: Caught TypeError in DataLoader worker process 0</code></h2><p>问题极大可能出现在transform，实际上和work的数量没什么关系</p>
<p>我第一次遇到这个bug的时候是因为送入的transform为None</p>
<h2 id="RuntimeError-Trying-to-backward-through-the-graph-a-second-time-but-the-saved-intermediate-results-have-already-been-freed-Specify-retain-graph-True-when-calling-backward-the-first-time"><a href="#RuntimeError-Trying-to-backward-through-the-graph-a-second-time-but-the-saved-intermediate-results-have-already-been-freed-Specify-retain-graph-True-when-calling-backward-the-first-time" class="headerlink" title="RuntimeError: Trying to backward through the graph a second time, but the saved intermediate results have already been freed. Specify retain_graph=True when calling backward the first time."></a><code>RuntimeError: Trying to backward through the graph a second time, but the saved intermediate results have already been freed. Specify retain_graph=True when calling backward the first time.</code></h2><p>在网络训练过程中，在一次迭代中使用多次backward()时就有可能会遇到这个问题。说明你的中间变量进行了两次的梯度回传。</p>
<ul>
<li>解决<br>查找除了叶子节点的其他中间节点，是否重复使用，若有，则对这个中间节点使用<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var_new = var.clone().detach().requires_grad_(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
或者<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var.detach()</span><br></pre></td></tr></table></figure>
<h2 id="pytorch-中的Out-of-memory-显存占用问题-记录"><a href="#pytorch-中的Out-of-memory-显存占用问题-记录" class="headerlink" title="pytorch 中的Out of memory(显存占用问题)记录"></a>pytorch 中的<code>Out of memory</code>(显存占用问题)记录</h2></li>
</ul>
<ol>
<li>计算loss但是不进行梯度回传</li>
<li>读取数据的batch 大小</li>
<li>用于计算loss时的图片大小(1024和256使用同一个loss计算可能显存占用差别会很大)</li>
<li>即使设置generator的grad为false，但是forward经过generator生成的图片仍带有梯度；</li>
</ol>
<h2 id="pytorch中程序退出但显存未释放"><a href="#pytorch中程序退出但显存未释放" class="headerlink" title="pytorch中程序退出但显存未释放"></a>pytorch中程序退出但显存未释放</h2><p>查看进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fuser -v /dev/nvidia*</span><br></pre></td></tr></table></figure>
<p>杀死进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch-Streamlit</title>
    <url>/2021/11/29/Pytorch/Pytorch-Streamlit/</url>
    <content><![CDATA[<h1 id="Streamlit-一个快速构建python应用程序的框架"><a href="#Streamlit-一个快速构建python应用程序的框架" class="headerlink" title="Streamlit, 一个快速构建python应用程序的框架"></a>Streamlit, 一个快速构建python应用程序的框架</h1><p><strong>本文参考</strong></p>
<ul>
<li><a href="https://github.com/streamlit/streamlit">Github官方文档</a></li>
<li><a href="http://cw.hubwiz.com/card/c/streamlit-manual/">中文开发文档</a></li>
</ul>
<h2 id="安装Streamlit"><a href="#安装Streamlit" class="headerlink" title="安装Streamlit"></a>安装Streamlit</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install streamlit</span><br><span class="line">streamlit hello</span><br></pre></td></tr></table></figure>

<h2 id="使用Streamlit"><a href="#使用Streamlit" class="headerlink" title="使用Streamlit"></a>使用Streamlit</h2><p>具体用法可以参考中文开发文档，实际上就是单纯调用api。这里我记录一些我在使用过程中遇到的一些问题。  </p>
<ol>
<li>Streamlit运行过程<br>Streamlit在每次运行时，都会从头开始将整个app重新运行一遍(除了那些缓存在cache中的数据)</li>
<li>Streamlit远程运行<br>Streamlit默认端口为8501，同样可以利用端口转发技术，将远程Streamlit程序显示在当前电脑中。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -L 8501:127.0.0.1:8501 xuedue@125.216.231.147 </span><br></pre></td></tr></table></figure></li>
<li>vscode开发Streamlit<br>在扩展商店中安装<strong>multi-command</strong>扩展，扩展的settings.json文件中加入 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;multiCommand.commands&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;multiCommand.streamlitActiveFile&quot;</span>,</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;Streamlit: Run Active File&quot;</span>,</span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Streamlit run active file in active terminal&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sequence&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;workbench.action.terminal.focus&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;command&quot;</span>: <span class="string">&quot;workbench.action.terminal.sendSequence&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;args&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;text&quot;</span>: <span class="string">&quot;streamlit run <span class="variable">$&#123;relativeFile&#125;</span>\u000D&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>
 实际上就是用一个快捷命令来控制Streamlit的运行，这样不用每次自己手敲输命令。<br> 键入crtl+shift+p，选择Multi command:Execute multi command,再选择Streamlit命令。</li>
</ol>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>streamlit</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch环境相关</title>
    <url>/2021/07/22/Pytorch/Pytorch-env/</url>
    <content><![CDATA[<h1 id="显卡，显卡驱动-nvcc-cuda-driver-cudatoolkit-cudnn到底是什么？"><a href="#显卡，显卡驱动-nvcc-cuda-driver-cudatoolkit-cudnn到底是什么？" class="headerlink" title="显卡，显卡驱动,nvcc, cuda driver,cudatoolkit,cudnn到底是什么？"></a>显卡，显卡驱动,nvcc, cuda driver,cudatoolkit,cudnn到底是什么？</h1><p><a href="https://www.cnblogs.com/marsggbo/p/11838823.html">https://www.cnblogs.com/marsggbo/p/11838823.html</a></p>
<h1 id="conda-换源"><a href="#conda-换源" class="headerlink" title="conda 换源"></a>conda 换源</h1><ul>
<li>查看原来的镜像源<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --show</span><br></pre></td></tr></table></figure></li>
<li>删除旧镜像源<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --remove channels &lt;https://mirrors.tuna.tsinghua.edu.cn/tensorflow/linux/cpu/&gt;  </span><br></pre></td></tr></table></figure></li>
<li>添加新镜像源<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --add channels &lt;https://mirrors.tuna.tsinghua.edu.cn/tensorflow/linux/cpu/&gt;</span><br></pre></td></tr></table></figure></li>
<li>设置搜索时显示通道地址<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> show_channel_urls <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>查看已有的channel<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --show channels</span><br></pre></td></tr></table></figure></li>
<li>添加新的channel  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --add channels &lt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&gt;  </span><br><span class="line">conda config --add channels &lt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge&gt;</span><br><span class="line">conda config --add channels &lt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/&gt;</span><br><span class="line">conda config --add channels &lt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/&gt;</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="pip-换源"><a href="#pip-换源" class="headerlink" title="pip 换源"></a>pip 换源</h1><p>pip国内常用源：</p>
<blockquote>
<p>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>豆瓣(douban) <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a><br>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/</a>  </p>
</blockquote>
<p>例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -i &lt;https://pypi.tuna.tsinghua.edu.cn/simple&gt; keras</span><br></pre></td></tr></table></figure>

<h1 id="Pytorch-换卡运行"><a href="#Pytorch-换卡运行" class="headerlink" title="Pytorch 换卡运行"></a>Pytorch 换卡运行</h1><p>换卡运行  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1 python example.py xxxxxx</span><br></pre></td></tr></table></figure>

<h1 id="cuda-amp-cudnn版本查看"><a href="#cuda-amp-cudnn版本查看" class="headerlink" title="cuda&amp;cudnn版本查看"></a>cuda&amp;cudnn版本查看</h1><p>cuda版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvcc -V or <span class="built_in">cat</span> /usr/local/cuda/version.txt</span><br></pre></td></tr></table></figure>

<p>cudnn版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2</span><br></pre></td></tr></table></figure>

<h1 id="Ubuntu-安装cuda"><a href="#Ubuntu-安装cuda" class="headerlink" title="Ubuntu 安装cuda"></a>Ubuntu 安装cuda</h1><ol>
<li><p>下载cuda<br>在官网选择自己需要的cuda版本<br><a href="https://developer.nvidia.com/cuda-toolkit-archive">https://developer.nvidia.com/cuda-toolkit-archive</a><br>并根据系统和环境选择下载方式</p>
</li>
<li><p>安装cuda<br>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> sh cuda_xx.x.xxx_xxx.xx_linux.run</span><br></pre></td></tr></table></figure>
<p>比较新的版本在安装之前提示选择安装的内容，这里把驱动Driver的选择取消，即不选择安装驱动Driver<br>然后一路闪电带火花</p>
</li>
<li><p>设置cuda环境变量<br>打开.bashrc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gedit ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/local/cuda-xx.x/lib64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/cuda-xx.x/bin</span><br><span class="line"><span class="built_in">export</span> CUDA_HOME=<span class="variable">$CUDA_HOME</span>:/usr/local/cuda-xx.x</span><br></pre></td></tr></table></figure></li>
<li><p>验证<br>在终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvcc --version</span><br></pre></td></tr></table></figure>
<p>显示正确版本则安装成功</p>
</li>
</ol>
<h1 id="Ubuntu-安装cudnn"><a href="#Ubuntu-安装cudnn" class="headerlink" title="Ubuntu 安装cudnn"></a>Ubuntu 安装cudnn</h1><p>下载链接<br><a href="https://developer.nvidia.com/zh-cn/cudnn">https://developer.nvidia.com/zh-cn/cudnn</a><br>选择合适的版本下载(tgz format(library),deb format(runtime，develop))<br>下载好后直接命令行解压，然后复制 lib64 和 include 文件夹到 /usr/local/cuda-xx.x，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf cudnn-xx.x-linux-x64-v7.5.0.56.tgz</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> cuda/include/cudnn.h /usr/local/cuda-xx.x/include</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> cuda/lib64/libcudnn* /usr/local/cuda-xx.x/lib64</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /usr/local/cuda-xx.x/include/cudnn.h /usr/local/cuda-xx.x/lib64/libcudnn*</span><br></pre></td></tr></table></figure>

<h1 id="Ubuntu-cuda-版本切换"><a href="#Ubuntu-cuda-版本切换" class="headerlink" title="Ubuntu cuda 版本切换"></a>Ubuntu cuda 版本切换</h1><ol>
<li>设置链接库<br>执行sudo gedit ~/.bashrc 打开.bashrc，可以看到已经安装的版本，比如<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/usr/local/cuda-9.0/bin&quot;</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="string">&quot;<span class="variable">$LD_LIBRARY_PATH</span>:/usr/local/cuda-9.0/lib64/&quot;</span></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="string">&quot;<span class="variable">$LIBRARY_PATH</span>:/usr/local/cuda-9.0/lib64&quot;</span>  </span><br></pre></td></tr></table></figure>
将上面行中所有的cuda-9.0更改为cuda：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/usr/local/cuda/bin&quot;</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="string">&quot;<span class="variable">$LD_LIBRARY_PATH</span>:/usr/local/cuda/lib64/&quot;</span></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="string">&quot;<span class="variable">$LIBRARY_PATH</span>:/usr/local/cuda/lib64&quot;</span></span><br></pre></td></tr></table></figure>
保存退出后，在终端运行如下命令使之生效:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li>切换版本<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /usr/local/cuda <span class="comment">#删除之前创建的软链接</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/local/cuda-10.0 /usr/local/cuda  <span class="comment">#创建新 cuda-10.0 的软链接</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Ubuntu-安装TensorRT"><a href="#Ubuntu-安装TensorRT" class="headerlink" title="Ubuntu 安装TensorRT"></a>Ubuntu 安装TensorRT</h1><p>使用压缩包进行安装</p>
<ol>
<li>下载TensorRT的压缩包<br>下载地址 <a href="https://developer.nvidia.com/nvidia-tensorrt-download">https://developer.nvidia.com/nvidia-tensorrt-download</a><br>需要填写问卷之后才能下载</li>
<li>解压并添加环境变量  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xzvf TensorRT-x.××××.tar</span><br></pre></td></tr></table></figure>
添加环境变量需要注意TensorRT的版本需要和cuda以及cudnn一致  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gedit ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/wsy/TensorRT-5.0.2.6/lib:<span class="variable">$LD_LIBRARY_PATH</span> </span><br><span class="line"><span class="built_in">export</span> CUDA_INSTALL_DIR=/usr/local/cuda-x.x</span><br><span class="line"><span class="built_in">export</span> CUDNN_INSTALL_DIR=/usr/local/cuda-x.x</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li>安装<br>cd到解压目录，并且进入需要安装的conda环境，安装所有whl文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先进入conda虚拟环境</span></span><br><span class="line">conda activate env_name</span><br><span class="line"><span class="comment">#install TensorRT</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/tensorrt-x.x.x.x/python</span><br><span class="line">pip install xxxxxx.whl</span><br></pre></td></tr></table></figure></li>
<li>测试<br>测试TensorRT是否安装成功，进入Python编辑器导入tensorrt和uff模块<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorrt</span><br><span class="line"><span class="keyword">import</span> uff</span><br><span class="line"><span class="built_in">print</span>(tensorrt.__version__)</span><br><span class="line"><span class="built_in">print</span>(uff.__version__)</span><br></pre></td></tr></table></figure>
此处<code>print(uff.__version__)</code>可能会报错是因为没有安装TensorFlow的原因，可不用管。至此TensorRT安装完成。</li>
</ol>
<h1 id="pytorch环境更新包"><a href="#pytorch环境更新包" class="headerlink" title="pytorch环境更新包"></a>pytorch环境更新包</h1><p>-U更新到最新版本，加上==指定版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -U tensorflow-gpu==2.4.1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch visdom相关</title>
    <url>/2021/07/22/Pytorch/Pytorch-visdom/</url>
    <content><![CDATA[<h1 id="Visdom远程连接"><a href="#Visdom远程连接" class="headerlink" title="Visdom远程连接"></a>Visdom远程连接</h1><p>此方法同样适用于tensorboard,streamlit(已知，且亲自尝试过)</p>
<ol>
<li>连接ssh时，将服务器的8097端口重定向到自己机器上的18097端口：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -L 18097:127.0.0.1:8097 xuedue@125.216.231.147 </span><br></pre></td></tr></table></figure></li>
<li>在服务器上使用8097端口正常启动Visdom<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">visdom</span><br></pre></td></tr></table></figure></li>
<li>在本地浏览器中输入local host地址再加上重定向的端口号：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:18097/</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
        <tag>visdom</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch-语法</title>
    <url>/2021/09/26/Pytorch/Pytorch-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="torch函数"><a href="#torch函数" class="headerlink" title="torch函数"></a>torch函数</h1><h2 id="torch-clamp"><a href="#torch-clamp" class="headerlink" title="torch.clamp()"></a>torch.clamp()</h2><p>torch.clamp(input, min, max, out=None) → Tensor<br>参数：</p>
<ul>
<li>input (Tensor) – 输入张量</li>
<li>min (Number) – 限制范围下限</li>
<li>max (Number) – 限制范围上限</li>
<li>out (Tensor, optional) – 输出张量</li>
</ul>
<p>作用：将输入夹紧至某一区间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output = torch.clamp(<span class="built_in">input</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">#输入值&lt;0则为0，&gt;1则为1  </span></span><br></pre></td></tr></table></figure>
<h2 id="torch-round"><a href="#torch-round" class="headerlink" title="torch.round()"></a>torch.round()</h2><p>torch.round(input, out=None)<br>作用：返回一个新张量，将输入input张量每个元素舍入到最近的整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.tensor(<span class="number">0.6</span>)</span><br><span class="line">b = torch.<span class="built_in">round</span>(a)  <span class="comment"># a = 0.6, b = 1.0</span></span><br><span class="line">a = a.<span class="built_in">round</span>()  <span class="comment"># a = 1.0, b = 1.0</span></span><br></pre></td></tr></table></figure>

<h2 id="torch-sign"><a href="#torch-sign" class="headerlink" title="torch.sign()"></a>torch.sign()</h2><p>torch.sign(input, out=None) → Tensor<br>作用：返回tensor的符号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.tensor([-<span class="number">1.1</span>, <span class="number">0.</span>, <span class="number">1.1</span>])</span><br><span class="line">sign = torch.sign(a) </span><br><span class="line"><span class="built_in">print</span>(a.sign()) <span class="comment"># tensor([-1.,  0.,  1.])</span></span><br><span class="line"><span class="built_in">print</span>(sign) <span class="comment"># tensor([-1.,  0.,  1.])</span></span><br></pre></td></tr></table></figure>
<h2 id="detach-amp-clone"><a href="#detach-amp-clone" class="headerlink" title="detach() &amp; clone()"></a>detach() &amp; clone()</h2><ul>
<li>torch.detach() </li>
</ul>
<ol>
<li>新的tensor会脱离计算图，不会牵扯梯度计算；</li>
<li>浅拷贝，和原先的tensor指向同一内存；</li>
</ol>
<ul>
<li>torch.clone()</li>
</ul>
<ol>
<li>新的tensor充当中间变量，会保留在计算图中，参与梯度计算（回传叠加），但是一般不会保留自身梯度；</li>
<li>深拷贝，开辟新的内存空间；</li>
</ol>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode配置C语言</title>
    <url>/2022/06/27/Vscode/Vscode-C%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p><strong>参考文章</strong><br><a href="https://blog.csdn.net/m0_46147064/article/details/124424305">VScode中配置 C/C++ 环境,超级详细，问题分析全面，绝对好用</a></p>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode-代理设置</title>
    <url>/2022/06/25/Vscode/Vscode-%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>本文参考</strong></p>
<ul>
<li><a href="https://blog.csdn.net/lihefei_coder/article/details/119905933">VSCode设置代理</a></li>
</ul>
<h2 id="具体步骤-亲测"><a href="#具体步骤-亲测" class="headerlink" title="具体步骤(亲测)"></a>具体步骤(亲测)</h2><ol>
<li>依次点击左下角按钮<br> setting-应用程序-代理服务器-edit in settings</li>
<li>在配置最后加上,端口和ip需要根据自己的代理进行设置，可以在window中的代理中查看 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;http.proxy&quot;</span>: <span class="string">&quot;http://xxx.xxx.xxx.xxx:8080&quot;</span>,</span><br><span class="line"><span class="string">&quot;http.proxyStrictSSL&quot;</span>: <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li>打开命令终端，在根目录给项目设置git代理 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config  http.sslVerify <span class="literal">false</span></span><br><span class="line">git config  http.proxy http://xxx.xxx.xxx.xxx:8080</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode-快捷键</title>
    <url>/2022/06/25/Vscode/Vscode-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>在使用快捷键的时候下方蓝条有提示，如果快捷键不起作用可以注意一下下面的提示。</p>
<ul>
<li>折叠/展开所有函数<br>ctrl+k + ctrl+0(ctrl+k+0) /ctrl+k + ctrl+j(ctrl+k+j)</li>
<li>折叠所有函数至第n层级：<br>ctrl+k + ctrl+n(ctrl+k+n)</li>
</ul>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode-远程调试</title>
    <url>/2022/06/25/Vscode/Vscode-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="利用vscode远程连接服务器，配置免密连接（亲测）"><a href="#利用vscode远程连接服务器，配置免密连接（亲测）" class="headerlink" title="利用vscode远程连接服务器，配置免密连接（亲测）"></a>利用vscode远程连接服务器，配置免密连接（亲测）</h2><ol>
<li><p>在vscode扩展搜索并安装远程ssh连接插件<br>Remote-SSH 或者 Remote Development</p>
</li>
<li><p>在远程连接中打开配置文件<br>这里要选择后续免密登录生成密钥文件下的config文件，当然默认都是选择第一个<br><img src="https://i.loli.net/2021/08/03/HlPmu7O1VJxzIav.png" alt="image.png"><br>config里面的内容就是你ssh连接的ip，端口号等<br>创建ssh连接命令(p为端口号)  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh usr@111.111.111.111 -p 123</span><br></pre></td></tr></table></figure></li>
<li><p>免密登录设置<br>打开cmd，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p> -t 指定密钥类型，默认即 rsa ，可以省略<br> -C 设置注释文字，比如你的邮箱，可以省略<br> 回车跳过，会在默认文件夹，也就是第二步骤中的config文件夹中生成私钥文件 id_rsa 和公钥文件 id_rsa.pub<br> <strong>注意，这里的公钥文件id_rsa.pub可以用于多个ssh链接，即一对多</strong></p>
</li>
<li><p>配置服务器端  </p>
</li>
</ol>
<ul>
<li>进入服务器的ssh文件夹，如果是Linux系统，一般是/home/usrname/.ssh</li>
<li>打开authorized_keys文件，如果没有就新建一个</li>
<li>将第三步中生成的公钥id_rsa.pub中的内容复制到authorized_keys文件中</li>
<li>完成免密设置</li>
</ul>
<h2 id="vscode-远程服务器调试选择其他id的显卡"><a href="#vscode-远程服务器调试选择其他id的显卡" class="headerlink" title="vscode 远程服务器调试选择其他id的显卡"></a>vscode 远程服务器调试选择其他id的显卡</h2><p>在运行的配置中的env添加配置</p>
<blockquote>
<p>“CUDA_VISIBLE_DEVICES”: “1”</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Python: 当前文件&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;python&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;console&quot;</span>: <span class="string">&quot;integratedTerminal&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;env&quot;</span>: &#123;<span class="string">&quot;PYTHONPATH&quot;</span>:<span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;CUDA_VISIBLE_DEVICES&quot;</span>: <span class="string">&quot;1&quot;</span>&#125;,</span><br><span class="line">            <span class="string">&quot;envFile&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;/.env&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>80211 6G调研</title>
    <url>/2026/02/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/80211%206G%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>WiFi7 (Extremely High Throughput，简称 EHT)，其目标为提高WLAN网络的吞吐量至30Gbps，时延控制在5ms之内，为此引入了多项新技术如320MHz带宽、4096-QAM调制、Multi-RU、多链路操作、增强MU-MIMO、多AP协作等技术。在传输速率方面，WiFi7通过引入6G 320MHz带宽、4096-QAM调制技术使得单链路最大理论速率达到46.1Gbps。对于如手机、PC、网卡等常用终端，相同流数的情况下，WiFi7 6G 320MHz带宽相比WiFi6 160M峰值理论吞吐量直接提升一倍。虽然国内目前尚不支持6G频段，但后续仍存在6G开放给WIFI使用的可能。</p>
<table>
<thead>
<tr>
<th>参数描述</th>
<th>WIFI6(11ax)</th>
<th>WIFI7(11be)</th>
</tr>
</thead>
<tbody><tr>
<td>频段</td>
<td>2.4GHz、5GHz、6GHz（仅Wi-Fi 6E）</td>
<td>2.4GHz、5GHz、6GHz</td>
</tr>
<tr>
<td>最大带宽</td>
<td>160MHz</td>
<td>320MHz</td>
</tr>
<tr>
<td>调制方式</td>
<td>OFDMA，最高1024QAM</td>
<td>OFDMA，最高4096QAM</td>
</tr>
<tr>
<td>最大理论速率</td>
<td>9.6Gbps</td>
<td>46.1Gbps</td>
</tr>
<tr>
<td>MIMO</td>
<td>8×8</td>
<td>16×16</td>
</tr>
</tbody></table>
<h2 id="6G频段划分及当前国内现状"><a href="#6G频段划分及当前国内现状" class="headerlink" title="6G频段划分及当前国内现状"></a>6G频段划分及当前国内现状</h2><p>6GHz频段（5925MHz~7125MHz）共有1200MHz带宽，可以提供59个20MHz、29个40MHz、14个80MHz、7个160MHz或者3个320MHz信道带宽，可极大地缓解Wi-Fi频谱资源短缺的问题。6G频段具体划分如下：</p>
<p><strong>1、国内关于6G频段的划分情况：</strong></p>
<p>2020年4月23日，FCC宣布，考虑允许将6GHz频段中的1200MHz频谱开放给免许可应用，最终投票表决通过将6GHz（5925-7125MHz）的新频段开放给了免许可应用。欧盟随后也发布将6GHz低频段的500MHz（5925-6425MHz）带宽放开授权使用，其它世界各国也已经放开或正在逐步放开中。目前我国计划将6G高频段的700MHz（6425-7125MHz）带宽放开给5G或6G移动通信，低频段部分待定。</p>
<p>原文见：<a href="https://wap.miit.gov.cn/gyhxxhb/jgsj/cyzcyfgs/bmgz/wxdl/art/2023/art_1e98823e689f42ca9ed14dcb6feec07a.html">《中华人民共和国无线电频率划分规定》</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHN45 6425-7125MHz 全部或部分频段的移动业务确定用于国际移动通信（IMT）系统。该频段应用模式、频率使用规划、业务间的兼容共存条件及协调程序确定前，IMT系统不投入实际部署使用。（2023年）</span><br></pre></td></tr></table></figure>

<p>工业和信息化部发布新版<a href="https://wap.miit.gov.cn/gyhxxhb/jgsj/cyzcyfgs/bmgz/wxdl/art/2023/art_1e98823e689f42ca9ed14dcb6feec07a.html">《中华人民共和国无线电频率划分规定》</a> 率先在全球将6GHz频段划分用于5G/6G系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在本次《划分规定》修订中，工业和信息化部率先在全球将6425-7125MHz全部或部分频段划分用于IMT（国际移动通信，含5G/6G）系统。6GHz频段是中频段仅有的大带宽优质资源，兼顾覆盖和容量优势，特别适合5G或未来6G系统部署，同时可以发挥现有中频段5G全球产业的优势。此次以规章形式确定其规则地位，有利于稳定5G/6G产业预期，推动5G/6G频谱资源全球或区域划分一致，为5G/6G发展提供所必需的中频段频率资源，促进移动通信技术和产业创新发展。</span><br></pre></td></tr></table></figure>



<p><strong>2、其它国家关于6G频段的划分情况：</strong></p>
<p>1）<strong>美洲部分国家6GHz频段规划</strong></p>
<p>2020年4月，美国联邦通信委员会（FCC）宣布采用免许可方式开放使用6GHz频段。即5925MHz~7125MHz 可用于WiFi；</p>
<p>原因是美国 5G/6G 部署一开始主要关注于毫米波。加拿大、巴西监管机构采用与美国相同的6GHz频段规划方案。</p>
<p>2）<strong>欧洲部分国家6GHz频段规划</strong></p>
<p>2021年，欧盟委员会宣布支持欧盟各国将5945MHz-6425MHz共计480MHz频谱用于WiFi系统。对于6425MHz~7125MHz频段，尚未确定具体方案；</p>
<p>2020年7月，英国无线电监管机构Ofcom决定将5925MHz~6425MHz共500MHz频率用于WiFi，同时该频段需满足极低功率业务户外使用要求；</p>
<p>2022年4月，Ofcom就6GHz高段部分（6425MHz~7070MHz）的使用方式征求意见。12月，Ofcom表示高段部分倾向于“不变”，即继续用于用于WiFi。</p>
<p>3）<strong>亚太地区部分国家6GHz频段规划</strong></p>
<p>2020年10月，韩国科学与信息通信部将6GHz频段规划用于WiFi等系统，成为继美国之后第二个将6GHz频段全部规划用于WiFi的国家；</p>
<p>2022年4月日本总务省将5925MHz~6425MHz规划用于WiFi系统，6425MHz~7125MHz频段规划正在制定中。2021年3月澳大利亚通信和媒体管理局将5925MHz~6425MHz作为WiFi系统频率，6425MHz~7125MHz频率规划正在制定中。新西兰尚未制定6GHz频段规划。</p>
<p><strong>3、最新进展：</strong><br>世界无线电通信大会2023（WRC-2023）已结束，工信部官网对会上6G 频段划分的总结如下：</p>
<p>完整原文见<a href="https://www.miit.gov.cn/ztzl/rdzt/sjwxdtxdh/ywkb/art/2024/art_b07e57c923be4038805fcf79907a081c.html">《WRC-23观察 | 大势所趋 业界所向——6GHz频段划分用于5G/6G的全球规则基础已 建立》</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6GHz频段划分是本次大会的焦点，在所有议题中，其文稿数量、关注度、会议频次等方面均十分突出，累计收到6个区域电信组织和近30个国</span><br><span class="line">家的提案，召开各级别会议约80场。会上，非洲、阿拉伯、俄联邦三个区域均主张6425-7125MHz频段700MHz带宽划分用于5G/6G；亚太地区共同提</span><br><span class="line">案支持7025-7125MHz频段划分，亚太部分国家提交提案支持6425-7025MHz频段划分。欧洲在一定条件下可接受6425-7125MHz频段划分。美洲地区总</span><br><span class="line">体反对6425-7125MHz频段划分，在各个层级的会议讨论中，美国、加拿大和美洲区域电信组织的代表以及沙特、萨摩亚、南苏丹等其他地区少数反</span><br><span class="line">对6425-7125MHz 频段划分的国家，在能否实现6GHz频段划分、划分技术条件、2区和3区6425-7025MHz频段国家脚注等方面持反对意见。随着会议</span><br><span class="line">讨论的升级，俄联邦、尼日利亚、阿联酋、巴西等还在会议期间额外向大会提交了多篇新提案，以加强对6GHz频段划分的支持。会上，尽管菲律</span><br><span class="line">宾、印尼、泰国、越南等8个亚太国家最终未能加入6425-7125MHz频段划分脚注，但均在会议上表达了增加上述频段划分的强烈诉求。</span><br><span class="line">6GHz频段划分用于IMT的全球规则基础建立</span><br><span class="line"></span><br><span class="line">最终，大会议题1.2的各方讨论达到了一种极为敏感和微妙的平衡，并顺利结束。各国代表就国际移动通信（IMT，含5G/6G）系统频谱划分达</span><br><span class="line">成共识，形成6GHz频段划分新决议：1区（欧洲、非洲、俄联邦和阿拉伯国家地区）划分整个6425-7125MHz频段用于IMT；2区（美洲地区）部分国</span><br><span class="line">家划分整个6425-7125MHz频段用于IMT；3区（亚太地区）划分整个7025-7125MHz频段用于IMT，在此基础上，3区部分国家划分6425-7025MHz频段用</span><br><span class="line">于IMT。同时，大会在WRC-27（2027年世界无线电通信大会） IMT新议题决议中表明，未来其他亚太国家可以直接加入6425-7025MHz频段划分脚</span><br><span class="line">注，国际电信联盟无需对此再次开展额外的技术和规则研究。上述决议标志着6GHz频段划分用于5G/6G的全球规则基础已充分建立。</span><br></pre></td></tr></table></figure>

<h2 id="6G特性"><a href="#6G特性" class="headerlink" title="6G特性"></a>6G特性</h2><h3 id="频谱资源"><a href="#频谱资源" class="headerlink" title="频谱资源"></a>频谱资源</h3><p>6G频段频率范围为5925MHz ~ 7125MHz，拥有59个20MHz信道、29个40MHz信道、14个80MHz信道、7个160MHz信道，Wi-Fi 7/11be还可扩展至320MHz。且其160MHz带宽的使用不像5G band1+band2、band3那样受限于DFS法规的约束。</p>
<h3 id="旧协议兼容性"><a href="#旧协议兼容性" class="headerlink" title="旧协议兼容性"></a>旧协议兼容性</h3><p>6GHz频段最低需支持11ax，不再需要向下兼容以往11b、11g、11a、11n，beacon中去除HT、VHT相关IE，可减少部分开销。且由于6G频段无旧协议设备，理论上OFDMA将会获得表现更好。</p>
<h3 id="信道号划分"><a href="#信道号划分" class="headerlink" title="信道号划分"></a>信道号划分</h3><p>按照IEEE标准，6G信道从1-233，共计59个信道，部分信道会与5G信道重复（如149、153、157、161、165），若是原来5G代码中存在通过信道范围区分频段的逻辑，也会造成困扰。</p>
<p>而QCA驱动存在另一种信道格式：仍在5G信道基础上增加（计算公式：Freq=5000+channel*5），即191-423，将6G当5G的扩展来进行信道设置，但此数值会超过1字节的上限（255），对不少信道变量、协议字段造成困扰。</p>
<h3 id="信道过多-减少扫描时间"><a href="#信道过多-减少扫描时间" class="headerlink" title="信道过多/减少扫描时间"></a>信道过多/减少扫描时间</h3><p>6G信道多引入了扫描时间过长的问题，如每个信道扫100ms，59个信道就需要5.9s。为了优化这个问题，Wi-Fi 6E提供了以下机制：</p>
<p><strong>OOB /  RNR</strong></p>
<p>OOB（Out Of Band Discovery），通过6G外的其他频段（如2.4GHz或5GHz）的beacon 和probe response帧携带6G信息，该信息由RNR（Reduced Neighbor Reports） IE承载，让STA能够预先获取6G的信道等信息，免除了去大量6G扫描的时间开销。</p>
<p><strong>PSC</strong></p>
<p>用一种专注于只有1/4信道数的信道列表(Preffered Scanning Channels, PSC)，PSC共有15个20MHz信道，间隔80MHz。使用PSC将被动扫描时间从5.9s减少至1.5s。</p>
<p><strong>FILS / Unsolicited broadcast probe response</strong></p>
<p>终端快速扫描机制FILS（Fast Initial Link Setup），STA在每个信道最多停留20ms，beacon间隔100ms，FILS Discovery/Bcast Probe Response帧间隔小于20ms。当STA通过FILS Discovery/Bcast Probe Response获取的SSID匹配要扫描的SSID，那么STA给AP发送Probe Request，AP收到后，回复单播Probe Response，告知具体BSS信息。此后STA即可进入认证关联过程。</p>
<p><strong>多VAP聚合 / Multi-BSS IE</strong></p>
<p>如上述章节，在100ms的beacon间隔中加入了20ms间隔的其他信标帧（FILS或广播probe rsp），大幅增加了信标帧的开销。若该频段再开启多个APVAP（主人、BH、访客等），将会引入更大空时开销。</p>
<p>目前100ms的beacon，各个VAP都会发送；而新引入的FILS/广播probe rsp，则是只会选择一个VAP进行发送，该VAP称为transmitted AP，默认选择第一个APVAP，也可通过接口指定。</p>
<p>另外，也可开启Multiple BSSID IE，简要来说，其作用是将所有apvap的beacon合并到一起，通过指定apvap发送出去，不同apvap的beacon差异通过MBSSID IE来调整（SSID、加密等）。</p>
<h2 id="常用6G终端"><a href="#常用6G终端" class="headerlink" title="常用6G终端"></a>常用6G终端</h2><p>常用终端包括网卡与手机，由于国内6G频段尚未开放，受法规限制，大多数终端厂商通过搜索环境中无线SSID并识别其国家码，如识别为不支持6G频段的国家则屏蔽其自身6G频段的方式来满足法规，这也导致很多终端无法在国内搜索到6G信号，可通过一些操作进行规避，方法主要包括：</p>
<p>1、 屏蔽环境下使用，且屏蔽房中无其他带有CN国家码的无线WiFi；</p>
<p>2、 网卡可通过原厂提供的工具修改网卡自身国家码，修改国家码后均可在开放环境下支持6G频段；</p>
<p>3、 部分手机可以通过关闭定位或屏蔽房重启的方式连接到6G；</p>
<p>4、 三星手机可通过刷新特定的工程固件来支持国内使用6G。</p>
<div class="hide-block"><button type="button" class="hide-button" style="">6G设备调研</button><div class="hide-content"><h3 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h3><table>
<thead>
<tr>
<th><strong>屏蔽环境下可搜索到6G信号的手机</strong></th>
<th><strong>开放环境下可搜索到6G信号的手机</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Pixel 6Pro</td>
<td>MSI GE66 Raider  10UG-211US[AX210网卡]</td>
</tr>
<tr>
<td>Pixel 7 Pro</td>
<td>Surface Pro 9[AX211网卡]</td>
</tr>
<tr>
<td>Pixel 8Pro[支持WiFi7]</td>
<td>Samsung S22 Ultra</td>
</tr>
<tr>
<td>Motorola Edge(2021)</td>
<td>OnePlus 11(欧版)[支持WiFi7 320M]</td>
</tr>
<tr>
<td>Samsung S21 Ultra</td>
<td>OnePlus 11(美版)[支持WiFi7 320M]</td>
</tr>
<tr>
<td>Samsung S23 Ultra</td>
<td>iPhone 15 Pro Max</td>
</tr>
<tr>
<td>小米13(欧版)</td>
<td>iPad Pro 6th 12.9-inch  (M2,2022)</td>
</tr>
<tr>
<td>小米13 Pro(欧版)[支持WiFi7]</td>
<td>MacBook Pro 14-in.(M2  Pro,2023)</td>
</tr>
<tr>
<td>vivo X90 Pro(欧版)</td>
<td>Galaxy S24 Ultra(New)[支持 WiFi 7 320M]（需工程固件以支持国内使用6G）</td>
</tr>
<tr>
<td></td>
<td>Galaxy Tab S9+</td>
</tr>
<tr>
<td></td>
<td>Galaxy Z Flip 5</td>
</tr>
<tr>
<td></td>
<td>Galaxy Z Fold 5</td>
</tr>
<tr>
<td></td>
<td>One Plus 12(美版)[支持WiFi 7 320M]</td>
</tr>
</tbody></table>
<h3 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h3><p>支持6G频段的网卡基本都可以通过修改国家码的方式来支持国内使用6G频段，如下为各家厂商支持6G频段的网卡终端：</p>
<p>Intel：BE200[WiFi 7 320M] 、AX210[WIFI6E 160M]</p>
<p>MTK：MT7927[WiFi 7 320M] 、MT7925[支持WiFi 7]</p>
<p>QCA：NCM865[WiFi 7 320M]</p>
</div></div>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>802.11</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础</title>
    <url>/2026/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h1><h3 id="网络主要设备及作用"><a href="#网络主要设备及作用" class="headerlink" title="网络主要设备及作用"></a>网络主要设备及作用</h3><table>
<thead>
<tr>
<th>设备</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>网卡</td>
<td>使计算机连网的设备</td>
</tr>
<tr>
<td>中继器（Repeater）</td>
<td>从物理层上延长网络的设备</td>
</tr>
<tr>
<td>网桥（Bridge）/2层交换机</td>
<td>从数据链路层上延长网络的设备</td>
</tr>
<tr>
<td>路由器（Router）/3层交换机</td>
<td>通过网络层转发分组数据的设备</td>
</tr>
<tr>
<td>4~7层交换机</td>
<td>处理传输层以上各层网络传输的设备</td>
</tr>
<tr>
<td>网关（gateway）</td>
<td>转换协议的设备</td>
</tr>
</tbody></table>
<blockquote>
<p>传输速率与吞吐量</p>
<p>两个设备之间数据流动的物理速度称为传输速率（每秒比特数 bps），传输速率高不是指单位数据流动的速度有多快，而是指单位时间内传输的数据量有多少（各传输媒介中信号的流动速度时恒定的）。</p>
<p>主机之间实际的传输速率被称为吞吐量（每秒比特数 bps）,吞吐量不仅衡量带宽，同时也衡量主机的CPU处理能力、网络的拥堵程度、报文中数据字段的占有份额（不含报文首部，只计算数据字段本身）等信息。</p>
</blockquote>
<h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><ul>
<li>中继器是对减弱的信号进行放大和发送的设备，由电缆传过来的电信号或光信号经由中继器的波形调整和放大再传给另一个电缆；</li>
<li>中继器通过物理层的连接延长网络；</li>
<li>即使在数据链路层出现某些错误，中继器仍然转发数据；</li>
<li>中继器无法改变传输速度；</li>
</ul>
<h4 id="网桥-2层交换机"><a href="#网桥-2层交换机" class="headerlink" title="网桥/2层交换机"></a>网桥/2层交换机</h4><p>网桥在数据链路层面上连接两个网络的设备。识别数据帧，存储于内存，重新生成信号作为一个全新的帧发送给相连的另一个网段。以太网等网络经常使用的交换集线器现在基本也属于网桥的一种，相当于持有多个端口（计算机外部接口称为端口，和TCP/UDP等的端口不同）的网桥。</p>
<h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p><img src="tcpip%E5%8D%8F%E8%AE%AE%E6%97%8F.png" alt="tcpip协议族"><img src="OSI&TCPIP.png" alt="image-20230915141858585"></p>
<p>数据传输时，对于TCP来说，数据部分为应用层数据，对IP来说，数据部分为TCP首部和TCP数据合起来的部分；</p>
<h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><p>包：全能性述语；</p>
<p>帧：用于表示数据链路层中包的单位；</p>
<p>数据报：是IP和UDP等网络层以上的分层中包的单位；</p>
<p>段：表示TCP数据流中的信息；</p>
<p>消息：应用协议中的数据的单位；</p>
<h1 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h1><h2 id="数据链路相关技术"><a href="#数据链路相关技术" class="headerlink" title="数据链路相关技术"></a>数据链路相关技术</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p><img src="MAC%E5%9C%B0%E5%9D%80.png" alt="image-20230915161633528"></p>
<blockquote>
<p>MAC地址不总是唯一的，实际上，即使MAC地址相同，只要不是同属于一个数据链路就不会有问题。</p>
<p>例如虚拟机没有硬件网卡，只能由虚拟软件自己设置MAC地址给虚拟网卡</p>
</blockquote>
<h3 id="共享介质型网络"><a href="#共享介质型网络" class="headerlink" title="共享介质型网络"></a>共享介质型网络</h3><p>设备之间使用同一个载波信道进行发送和接收。为此，基本上采用半双工通信，有必要对介质进行访问控制</p>
<ul>
<li><p>争用方式</p>
<ul>
<li>CSMA(载波监听多路访问) 先到先得方式，空闲就发，多个站同时发产生冲突</li>
<li>CSMA/CD 载波信道没有数据流动，任何站都可以发送数据；检查是否发生冲突，一旦发生冲突，先发送阻塞报文再停止发送，立即释放载波信道；放弃发送以后，随机延时一段时间，再重新争用介质，重新发送帧。</li>
</ul>
</li>
<li><p>令牌方式</p>
<p>只有获得令牌的站发送数据。一不会有冲突，二每个站平等循环获得令牌的机会。</p>
</li>
</ul>
<h3 id="非共享介质网络"><a href="#非共享介质网络" class="headerlink" title="非共享介质网络"></a>非共享介质网络</h3><p>网络中每个站直连交换机，由交换机负责转发数据帧。此方式下，发送端与接收端并不共享通信介质，因此很多情况下采用全双工通信方式。</p>
<p>一对一连接全双工通信的方式不会发生冲突，不需要CSMA/CD的机制、</p>
<blockquote>
<p>半双工是指，只发送或只接收的通信方式。若两端同时说话，听不见对方说的话的。采用CSMA/CD方式的以太网，独占信道。</p>
<p>全双工，允许再同一时间既可以发送数据也可以接收数据。以太网使用交换机与双绞线电缆，既可以通过交换机的端口与计算机之间进行一对一的连接，也可以通过相连电缆<strong>内部的收发线路</strong>分别进行接收和发送数据。</p>
</blockquote>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><blockquote>
<p>计算机内部二进制，1K=1024，1M=1024K，1G=1024M</p>
<p>以太网以时钟频率决定传输速度，1K=1000，1M=1000K，1G=1000M</p>
</blockquote>
<h3 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h3><p>以太网帧前端有一个叫前导码的部分，由01数字交替组而成，表示以太网帧的开始，也是对端网卡能够确保与其同步的标志。前导码末尾有一个叫SFD（Start Frame Delimiter）的域，值时“11”。这个域之后就是以太网帧的本体。</p>
<p><img src="%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E5%89%8D%E5%AF%BC%E7%A0%81.png" alt="image-20230915152755054"></p>
<p>以太网帧本体的前端是以太网的首部，总共占14个字节。分别是6个字节的目标MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。</p>
<p><img src="%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7.png" alt="image-20230915153118837"></p>
<p>类型标识以太网再上一层网络协议的类型，哪种类型就转给哪种类型的处理模块（ARP, RARP, IP, …）</p>
<p>帧尾的FCS(Frame Check Sequence)：4个字节，设置FCS的目的是为了判断数据包是否由于噪声而被破坏，用CRC方式校验。</p>
<h2 id="无线通信"><a href="#无线通信" class="headerlink" title="无线通信"></a>无线通信</h2><p>MAC层中物理地址与以太网相同，都是用MAC地址，而介质访问控制上则使用CSMA/CD相似的CSMA/CA方式。</p>
<p>在物理层上使用电磁波或红外线。</p>
<h1 id="IP协议（互联网层）"><a href="#IP协议（互联网层）" class="headerlink" title="IP协议（互联网层）"></a>IP协议（互联网层）</h1><h2 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h2><blockquote>
<p>主机：配置有IP地址，但是不进行路由控制的设备</p>
<p>路由器：既配有IP地址又具有路由控制能力的设备</p>
<p>节点：主机和路由器的统称</p>
</blockquote>
<p>IP面向无连接。在发包之前，不需要建立与对端目标地址之间的连接。这表示上层如果雨打需要发送给IP的数据，该数据会立刻被压缩成IP包发送出去。原因：一是为了简化，二是为了提速。</p>
<h2 id="IP地址基础知识"><a href="#IP地址基础知识" class="headerlink" title="IP地址基础知识"></a>IP地址基础知识</h2><h3 id="地址分类"><a href="#地址分类" class="headerlink" title="地址分类"></a>地址分类</h3><ul>
<li><p>ABCD类地址</p>
</li>
<li><p>分配注意事项</p>
<p>主机地址不可以全部为0或全部为1。C类地址每个网段最多只能有254（2^8-2=254）个主机地址。</p>
</li>
</ul>
<h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><p>本地广播和直接广播</p>
<p>本地广播：本网络内的广播，192.168.0.0/24的广播地址为192.168.0.255；</p>
<p>直接广播：192.168.0.0/24向192.168.1.0/24发送的广播地址为192.168.1.255</p>
<h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><p>广播会给毫无关系的网络或主机带来影响，广播无法穿透路由（路由一般不会转发广播地址）</p>
<p>多播使用D类地址，首位开始到第4位是“1110”，则可以认为是多播地址。范围224.0.0.0~239.255.255.255。从224.0.0.0到224.0.0.255范围不需要路由控制，同一链路内也能实现多播，而在这个范围之外设置多播地址会给全网所有组内成员发送多播的包。</p>
<p>对于多播，所有主机（路由器以外的主机和终端主机）必须属于224.0.0.1的组，所有路由器必须属于224.0.0.2的组。</p>
<h3 id="全局地址和私有地址"><a href="#全局地址和私有地址" class="headerlink" title="全局地址和私有地址"></a>全局地址和私有地址</h3><p>私有网络的地址地址</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>地址范围</th>
</tr>
</thead>
<tbody><tr>
<td>A类</td>
<td>10.0.0.0~10.255.255.255（10/8）</td>
</tr>
<tr>
<td>B类</td>
<td>172.16.0.0~172.31.255.255（172.16/12）</td>
</tr>
<tr>
<td>C类</td>
<td>192.168.0.0~192.168.255.255（192.168/16）</td>
</tr>
</tbody></table>
<p>包含在这个范围内的IP地址属于私有IP，而在此之外的IP地址称为全局IP。</p>
<p>私有IP最早没有计划接入互联网，用于互联网之外的独立网络。当互换私有IP与全局IP的NAT技术诞生后，就实现了与互联网主机的通信。</p>
<p>全局IP由ICANN进行管理，在日本则由一个叫做JPNIC的机构进行管理。</p>
<h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><p>静态路由控制：管理员手动设置</p>
<p>动态路由控制：路由器与其他路由器相互交换信息时自动刷新</p>
<h3 id="IP地址和路由控制"><a href="#IP地址和路由控制" class="headerlink" title="IP地址和路由控制"></a>IP地址和路由控制</h3><p>最长匹配：相同位数最多。此外如果路由表中下一个路由器的位置记录着某个主机或路由器网卡的IP地址，意味着“发送的目标地址属于同一链路”（目标地址在同一链路中的情况下，路由表的记录格式可能会根据操作系统和路由器种类的不同而有所区别）。</p>
<ul>
<li><p>默认路由</p>
<p>0.0.0.0/0（子网掩码也是0.0.0.0）或default，“/0”表示没有标识IP地址（0.0.0.0的IP地址应记为0.0.0.0/32）</p>
</li>
<li><p>主机路由</p>
<p>IP地址/32</p>
</li>
<li><p>环回地址</p>
<p><strong>同一台计算机上的程序之间</strong>进行网络通信时所使用的一个默认地址。计算机使用一个特殊的IP地址127.0.0.1作为环回地址，与该地址具有相同意义的是一个叫做localhost的主机名。使用这个IP或主机名时，数据包<strong>不会流向网络</strong>。</p>
</li>
</ul>
<h3 id="IP报文的分片与重组"><a href="#IP报文的分片与重组" class="headerlink" title="IP报文的分片与重组"></a>IP报文的分片与重组</h3><p>以太网默认MTU为1500字节。经过分片之后的IP数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</p>
<h3 id="路径MTU发现"><a href="#路径MTU发现" class="headerlink" title="路径MTU发现"></a>路径MTU发现</h3><p>分片机制让路由器的处理负荷加重。因此，只要允许，是不希望由路由器进行IP数据包的分片处理的。其次，一旦某个分片丢失，造成整个IP数据报作废。</p>
<p>路径MTU是指从发送端主机到接收端主机之间不需要分片时最大MTU的大小，即路径中存在的所有数据链路中最小的MTU。路径MTU发现从发送主机按照路径MTU的大小将数据报分片后进行发送，这可以避免在中途的路由器上进行分片处理。</p>
<p>原理：</p>
<ol>
<li>发送端发送IP数据报，设置禁止分片，途中路由器遇到需要分片才能处理的大包也不会分片，而是丢弃。随后通过ICMP的不可达消息将链路上MTU的值发给主机。</li>
<li>下次，将这个MTU设为当前MTU，然后进行分片。如此往复，直到数据报发送到目标主机位置没有再收到任何ICMP（不断通过ICMP报文更新MTU值），就认为最后一次ICMP通知的MTU时最适合的MTU值。</li>
<li>UDP同IP，在TCP情况下，根据MTU计算出最大段长度（MSS），然后再根据这些信息进行数据报的发送。因此，在TCP中如果采用路径MTU发现，<strong>IP层则不会再进行分片处理</strong>。</li>
</ol>
<h2 id="IPv4首部"><a href="#IPv4首部" class="headerlink" title="IPv4首部"></a>IPv4首部</h2><p><img src="IPv4%E9%A6%96%E9%83%A8.png" alt="image-20230911160139709"></p>
<ul>
<li><p>首部长度</p>
<p>由4比特构成，表明IP首部的大小，单位为4字节（32比特）。对于没有可选项的IP包，首部长度则设置为“5”。也就是说，当没有可选项时，IP首部的长度为20字节。</p>
</li>
<li><p>填充</p>
<p>有可选项情况下，首部字段可能不是32比特的整数倍。为此，通过向字段填充0，调整为32比特的整数倍。</p>
</li>
</ul>
<h2 id="ICMP首部"><a href="#ICMP首部" class="headerlink" title="ICMP首部"></a>ICMP首部</h2><p><img src="icmp.jpg" alt="icmp"></p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP头部</p>
<p><img src="TCP%E9%A6%96%E9%83%A8.png" alt="image-20230911160253860"></p>
<p>TCP通过<strong>校验和、序列号、确认应答、重发控制、连接管理以及窗口控制</strong>等机制实现可靠性传输。</p>
<p>在TCP模块中处理下层发给自己的包，首先会计算一下校验和，判断数据是否被破坏，然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。</p>
<p>UDP首部</p>
<p><img src="UDP%E9%A6%96%E9%83%A8.png" alt="image-20230911160219908"></p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>FTP (File Transfer Protocal, 文件传输协议，RFC959) 的目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。</p>
<p>FTP 采用客户 / 服务器模式，客户机与服务器之间利用 TCP 建立连接，客户可以从服务器上下载文件，也可以把本地文件上传至服务器。</p>
<p>FTP 客户端和服务器之间需要建立两个 TCP 连接：<strong>控制连接</strong>和<strong>数据连接</strong>。控制连接传送命令和响应，数据连接只传输数据（上传 / 下载）。</p>
<h3 id="FTP工作模式"><a href="#FTP工作模式" class="headerlink" title="FTP工作模式"></a>FTP工作模式</h3><p>PORT（主动模式）与 PASV（被动模式）。<strong>两种模式下，控制连接都是由客户端发起</strong>（关闭发起者不一定？）；而数据连接，在主动模式中由服务器主动发起，在被动模式中由客户端发起，服务器开启数据端口（&gt; 1024）被动监听。<font color=#FAA0A0> （只有数据模式才分主动被动）</font></p>
<p>FTP服务器控制端口一般为21，数据端口一般为20</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式调测工具</title>
    <url>/2026/01/18/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%B0%83%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="Perf"><a href="#Perf" class="headerlink" title="Perf"></a>Perf</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tp_upgrade tftp 192.168.1.200 xdr3010mv6_cn_1_0_18_flash(231102)_perf.bin</span><br><span class="line">tp_upgrade tftp 192.168.1.200 xdr3010mv6_cn_1_0_18_flash(231103)_origin_perf.bin</span><br><span class="line">tp_upgrade firmware;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">tftp -gr usr_ax3000.tar.gz 192.168.1.200</span><br><span class="line">tar -zxvf usr_ax3000.tar.gz</span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment"># 添加下面两行</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/tmp/usr/lib:<span class="variable">$LD_LIBRARY_PATH</span> </span><br><span class="line"><span class="built_in">export</span> PATH=/tmp/usr/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">perf record -C 1 -g -F 99 <span class="built_in">sleep</span> 10</span><br><span class="line">perf record -a -g -F 99 <span class="built_in">sleep</span> 10</span><br><span class="line"><span class="comment"># 在tmp目录下得到 perf.data，用script工具进行解析</span></span><br><span class="line">perf script -i perf.data &amp;&gt; perf.unfold</span><br><span class="line"></span><br><span class="line">tftp -pl perf.unfold 192.168.1.200</span><br><span class="line"><span class="comment"># ubuntu</span></span><br><span class="line">FlameGraph/stackcollapse-perf.pl perf.unfold &amp;&gt; perf.folded</span><br><span class="line">FlameGraph/flamegraph.pl perf.folded &gt; perf.svg</span><br></pre></td></tr></table></figure>

<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定设备（这里指定的是网桥br-lan）抓包，并将抓取的报文保存到文件（这里保存到br-lan.pcap）</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">tftp -gr tcpdump 192.168.1.10</span><br><span class="line"><span class="built_in">chmod</span> 777 tcpdump</span><br><span class="line">./tcpdump -i br-lan -w host.pcap</span><br><span class="line"><span class="comment"># 抓取完成后，使用ctrl c停止抓包，然后用tftp命令将抓取的报文导出</span></span><br><span class="line">tftp -pl host.pcap 192.168.1.10</span><br><span class="line"><span class="comment"># 【注意】tcpdump的钩子在内核部分，在驱动的更上层，驱动收到报文后将其交到协议栈后才能在tcpdump抓到，如果驱动丢包，则tcpdump上抓不到</span></span><br><span class="line"><span class="comment"># 通过cmd &amp; 后台运行</span></span><br><span class="line">ping 192.168.1.1 &amp;</span><br><span class="line"><span class="comment"># 通过杀ping进程结束运行</span></span><br><span class="line">killall ping</span><br><span class="line"><span class="built_in">kill</span> -9 pid</span><br></pre></td></tr></table></figure>


<h2 id="addr2line"><a href="#addr2line" class="headerlink" title="addr2line"></a>addr2line</h2><blockquote>
<p>基本用法：addr2len 选项 地址</p>
</blockquote>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>–address 显示地址</td>
</tr>
<tr>
<td>-b</td>
<td>–target=设置二进位文件格式</td>
</tr>
<tr>
<td>-e</td>
<td>–exe=设置输入文件名称（默认为a.out）</td>
</tr>
<tr>
<td>-i</td>
<td>–inline 解开内联函数</td>
</tr>
<tr>
<td>-j</td>
<td>–section=读取相对于段的偏移而非地址</td>
</tr>
<tr>
<td>-p</td>
<td>–pretty-print 让输出对人类更可读</td>
</tr>
<tr>
<td>-s</td>
<td>–basenames 去除目录名</td>
</tr>
<tr>
<td>-f</td>
<td>–functions 显示函数名</td>
</tr>
<tr>
<td>-C</td>
<td>–demangle[=style] 解码函数名</td>
</tr>
<tr>
<td>-h</td>
<td>–help 显示帮助文本</td>
</tr>
</tbody></table>
<p>使用流程</p>
<ol>
<li><p>反汇编.o文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /home/zengruihua/workspace/xdr3010mv6/SLP_SDK_for_xdr3010mv6_230917</span></span><br><span class="line">./slp-sp-target-src/rtl/toolchain/msdk-10.3.0-mips-EB-5.10-g2.30-m32s-210630/bin/mips-linux-gnu-objdump -d ./build_dir/target-mips-linux-gnu/linux-rtl_rtl8198d/g6_wifi_driver_015.20/core/rtw_a4.o &gt; /tmp/yxyx</span><br></pre></td></tr></table></figure></li>
<li><p>找到对应的section</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /tmp/yxyx</span><br><span class="line"><span class="comment"># 使用/找到对应函数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以直接用readelf来查看elf的符号表，符号就是程序中的函数和变量，函数名或变量名就是符号名</p>
<p>查看符号表</p>
<p>readelf -s elf_file</p>
<p>查看节信息</p>
<p>readelf -S elf_file</p>
</blockquote>
</li>
<li><p>add2line指定section</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用addr2line 指定 section</span></span><br><span class="line">./slp-sp-target-src/rtl/toolchain/msdk-10.3.0-mips-EB-5.10-g2.30-m32s-210630/bin/mips-linux-gnu-addr2line -a -i -p -f -C -e   ./build_dir/target-mips-linux-gnu/linux-rtl_rtl8198d/g6_wifi_driver_015.20/core/rtw_a4.o 0x118 -j .text.a4_recv_remote_handle</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意点</p>
<p>第一现场，即epc和最上面的函数调用，可以直接加偏移量</p>
<p>其他的函数要 -4，这是由于汇编代码会在调用函数时，使用LR暂存下一行指令，这里的下一行就是+4，然后函数调用执行完毕后，就把LR赋给PC，并继续执行。</p>
</blockquote>
<p>log:</p>
<pre><code>[   55.020102] CPU 1 Unable to handle kernel paging request at virtual address 00007f88, epc == c09951c8, ra == c09951c0
[   55.031743] Oops[#1]:
[   55.034236] CPU: 1 PID: 0 Comm: swapper/1 Tainted: G           O      5.10.70 #1
[   55.042327] $ 0   : 00000000 00000001 00000001 00000101
[   55.048057] $ 4   : 80940000 00000302 00000000 c1370288
[   55.053787] $ 8   : 00000010 802f1cec 00000000 00000000
[   55.059511] $12   : 00000000 82813c1d ffffffff 00000000
[   55.065232] $16   : c1abc000 00000000 84fe0000 82813e64
[   55.070950] $20   : c0a70000 00000000 c1510888 c0a6e450
[   55.076671] $24   : 00000000 80012d34
[   55.082389] $28   : 8288c000 82813e40 c1471000 c09951c0
[   55.088111] Hi    : 23626b04
[   55.091254] Lo    : 38fec800
[   55.095760] epc   : c09951c8 rtw_core_rx_process+0x9a8/0xa50 [rtk_wifi6]
[   55.104513] ra    : c09951c0 rtw_core_rx_process+0x9a0/0xa50 [rtk_wifi6]
[   55.111846] Status: 1100fc03 KERNEL EXL IE
[   55.116425] Cause : 4080000c (ExcCode 03)
[   55.120803] BadVA : 00007f88
[   55.123952] PrId  : 0001a120 (MIPS interAptiv (multi))
[   55.129572] Modules linked in: br_guest_filter(O) dns_proxy(O) dn_login(O) arp_filter(O) igmp_proxy_snooping(O) wfo_virt(O) rtk_wifi6(O) ther_ctrl(O) wan_port_detect_hook(O) map_filter(O) k_mwan_load_balance(O) game_port(O) slp_gpio(O) xt_multiurl(O) k_wlan_assoc_info(O) k_eventMngt(O)
[   55.157310] Process swapper/1 (pid: 0, threadinfo=5f40ec35, task=5857a7f6, tls=00000000)
[   55.166156] Stack : c0107ed4 800ba3a4 00000000 82813ee0 00000009 8093f360 808902b4 8089028c
[   55.175313]         c1510888 c1510888 00000000 80012448 00000004 813e0350 80cb0000 813e024c
[   55.184472]         00000000 80087398 c1510888 80cd0000 c0a674f0 c147660c c0990000 c09952ac
[   55.193630]         c0990000 c0a6b428 8093f360 00000001 8093f3cc fffdffff 8093f378 00020000
[   55.202787]         000003e8 00000000 c0114a18 c0107eb4 00000001 c010f000 84fe0000 00000001
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 4232.224109] CPU 1 Unable to handle kernel paging request at virtual address c1b13830, epc == 800a52d4, ra == 800a5224</span><br><span class="line">[ 4232.235733] Oops[#1]:</span><br><span class="line">[ 4232.238212] CPU: 1 PID: 0 Comm: swapper/1 Tainted: G           O      5.10.70 #1</span><br><span class="line">[ 4232.246293] $ 0   : 00000000 00000001 c1b1382c 813de4c0</span><br><span class="line">[ 4232.252020] $ 4   : 00000001 00000180 00000000 813dea08</span><br><span class="line">[ 4232.257741] $ 8   : ffffffe0 00001000 82813ef4 00000004</span><br><span class="line">[ 4232.263460] $12   : 813de4d8 00000001 00000200 82813ef8</span><br><span class="line">[ 4232.269180] $16   : 80940000 813de480 3fffffff 8093e040</span><br><span class="line">[ 4232.274899] $20   : 80ca1228 813de498 80890000 00000002</span><br><span class="line">[ 4232.280619] $24   : 00000001 00000000</span><br><span class="line">[ 4232.286339] $28   : 8288c000 82813ee0 00000020 800a5224</span><br><span class="line">[ 4232.292058] Hi    : 005f446b</span><br><span class="line">[ 4232.295195] Lo    : a0000000</span><br><span class="line">[ 4232.298352] epc   : 800a52d4 run_timer_softirq+0x124/0x38c</span><br><span class="line">[ 4232.304349] ra    : 800a5224 run_timer_softirq+0x74/0x38c</span><br><span class="line">[ 4232.310246] Status: 1100fc02 KERNEL EXL</span><br><span class="line">[ 4232.314532] Cause : 4080000c (ExcCode 03)</span><br><span class="line">[ 4232.318912] BadVA : c1b13830</span><br><span class="line">[ 4232.322049] PrId  : 0001a120 (MIPS interAptiv (multi))</span><br><span class="line">[ 4232.327664] Modules linked in: br_guest_filter(O) dns_proxy(O) dn_login(O) arp_filter(O) igmp_proxy_snooping(O) wfo_virt(O) rtk_wifi6(O) ther_ctrl(O) wan_port_detect_hook(O) map_filter(O) k_mwan_load_balance(O) game_port(O) slp_gpio(O) xt_multiurl(O) k_wlan_assoc_info(O) k_eventMngt(O)</span><br><span class="line">[ 4232.355399] Process swapper/1 (pid: 0, threadinfo=69545d85, task=ccc7d431, tls=00000000)</span><br><span class="line">[ 4232.364246] Stack : 80991f90 00000004 809b68a0 00000011 c1aa3a74 c1b1382c 00000000 00000000</span><br><span class="line">[ 4232.373404]         00000004 80940000 00000001 00000001 00000001 80940000 809c0000 80892604</span><br><span class="line">[ 4232.382560]         00000001 80947924 3fffffff 8093e040 80ca1228 80ca11c4 8093e044 00000101</span><br><span class="line">[ 4232.391720]         00000020 807b4f38 00000000 00000000 00000000 00000000 00000004 00000004</span><br><span class="line">[ 4232.400878]         80ca6aa0 0000000a 00060001 80940000 8088d57c 00200042 807bf050 0000001f</span><br></pre></td></tr></table></figure>

<p>PC(Ubuntu):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1：</span></span><br><span class="line"><span class="comment"># 编出出来的模块文件.ko是一个普通的ELF文件，使用file和nm命令可以查看相关信息，使用nm可以查看模块目标文件的符号信息，地址，符号类型，符号名</span></span><br><span class="line">$ nm ./build_dir/target-mips-linux-gnu/linux-rtl_rtl8198d/g6_wifi_driver_015.20/rtk_wifi6.ko | grep rtw_core_rx_process</span><br><span class="line">0000d840 T rtw_core_rx_process</span><br><span class="line"><span class="comment"># 0x0000d840 + 0x9a8 = 0xe1e8</span></span><br><span class="line">$ addr2line -a -i -p -f -C -e ./build_dir/target-mips-linux-gnu/linux-rtl_rtl8198d/g6_wifi_driver_015.20/rtk_wifi6.ko  0xe1e8</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法2：</span></span><br><span class="line">$ nm ./build_dir/target-mips-linux-gnu/linux-rtl_rtl8198d/g6_wifi_driver_015.20/core/rtw_recv.o  | grep rtw_core_rx_process</span><br><span class="line">00000000 T rtw_core_rx_process</span><br><span class="line"><span class="comment"># 根据log得到	</span></span><br><span class="line"><span class="comment"># 0 + 0x9a8 = 0x9a8  &lt;=  pc</span></span><br><span class="line"><span class="comment"># 0 + 0x9a0 = 0x9a0  &lt;=  lr/ra</span></span><br><span class="line">$ addr2line -a -i -p -f -C -e ./build_dir/target-mips-linux-gnu/linux-rtl_rtl8198d/g6_wifi_driver_015.20/core/rtw_recv.o  0x9a8 x99c</span><br><span class="line">0x000009a8: amsdu_to_msdu 于 /home/zengruihua/workspace/xdr3010mv6/SLP_SDK_for_xdr3010mv6_230917/build_dir/target-mips-linux-gnu/linux-rtl_rtl8198d/g6_wifi_driver_015.20/core/rtw_recv.c:3900</span><br><span class="line"></span><br><span class="line">0x00000000: check_fwstate 于 /home/zengruihua/workspace/xdr3010mv6/SLP_SDK_for_xdr3010mv6_230917/build_dir/target-mips-linux-gnu/linux-rtl_rtl8198d/g6_wifi_driver_015.20/core/rtw_recv.c:3639</span><br><span class="line"> (已内连入) sta2sta_data_frame 于 /home/zengruihua/workspace/xdr3010mv6/SLP_SDK_for_xdr3010mv6_230917/build_dir/target-mips-linux-gnu/linux-rtl_rtl8198d/g6_wifi_driver_015.20/core/rtw_recv.c:1510</span><br></pre></td></tr></table></figure>

<h2 id="GBD"><a href="#GBD" class="headerlink" title="GBD"></a>GBD</h2><h3 id="coredump"><a href="#coredump" class="headerlink" title="coredump"></a>coredump</h3><ol>
<li>进入sdk的gdb目录：SLP_SDK_for_etr13080mtv1_221028/staging_dir/toolchain-aarch64/bin（也可能不是arch64的gdb）</li>
<li>将dms文件以及挂起时的dms.XX.core文件都放到gdb的目录下</li>
<li>启动gdb：./aarch64-openwrt-linux-musl-gdb dms dms.XX.core</li>
<li>加载符号表：set sysroot ../../target-aarch64/root-ipq95xx/</li>
<li>bt</li>
</ol>
<h3 id="dms-coredump"><a href="#dms-coredump" class="headerlink" title="dms coredump"></a>dms coredump</h3><ol>
<li>进入sdk的gdb目录：SLP_SDK_for_etr13080mtv1_221028/staging_dir/toolchain-aarch64/bin（也可能不是arch64的gdb）</li>
<li>将dms文件以及挂起时的dms.XX.core文件都放到gdb的目录下</li>
<li>启动gdb：./aarch64-openwrt-linux-musl-gdb dms dms.XX.core</li>
<li>加载符号表：<br> set sysroot ../../target-aarch64/root-ipq95xx/<br> MTK 14060<br> set sysroot ../../target-aarch64_cortex-a53_musl/root-mediatek/<br> hostapd?<br> set solib-search-path ../../../staging_dir/toolchain-arm_cortex-a7_gcc-10.2.0_musl_eabi/lib</li>
<li>bt</li>
</ol>
<h2 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h2><h3 id="readelf-h"><a href="#readelf-h" class="headerlink" title="readelf -h"></a>readelf -h</h3><p>使用命令 <strong>readelf -h</strong> 可以查看一个 ELF 文件的 ELF Header 信息。</p>
<p>比较重要的成员有：<code>e_ident</code>（ELF 文件幻数）、<code>e_type</code>（比如可执行文件 ET_EXEC）、<code>e_entry</code>（程序入口虚拟地址）等等。</p>
<p>ELF 头部定义如以下结构体所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* /include/uapi/linux/elf.h */</span><br><span class="line">typedef struct elf32_hdr</span><br><span class="line">&#123;</span><br><span class="line">      unsigned char e_ident [EI_NIDENT];    /* Magic number and other info */</span><br><span class="line">      Elf32_Half    e_type;         /* Object file type */</span><br><span class="line">      Elf32_Half    e_machine;      /* Architecture */</span><br><span class="line">      Elf32_Word    e_version;      /* Object file version */</span><br><span class="line">      Elf32_Addr    e_entry;        /* Entry point virtual address */</span><br><span class="line">      Elf32_Off e_phoff;            /* Program header table file offset */</span><br><span class="line">      Elf32_Off e_shoff;            /* Section header table file offset */</span><br><span class="line">      Elf32_Word    e_flags;        /* Processor-specific flags */</span><br><span class="line">      Elf32_Half    e_ehsize;       /* ELF header size in bytes */</span><br><span class="line">      Elf32_Half    e_phentsize;    /* Program header table entry size */</span><br><span class="line">      Elf32_Half    e_phnum;        /* Program header table entry count */</span><br><span class="line">      Elf32_Half    e_shentsize;    /* Section header table entry size */</span><br><span class="line">      Elf32_Half    e_shnum;        /* Section header table entry count */</span><br><span class="line">      Elf32_Half    e_shstrndx;     /* Section header string table index */</span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>

<p>简单归纳各字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elf header:</span><br><span class="line">    magic num、version、arch、endian、flag、elf header size</span><br><span class="line">    elf type: EXEC (Executable file)、REL (Relocatable file)、DYN (Shared object file)</span><br><span class="line">    entry point: EXEC 文件才有，程序入口虚拟地址</span><br><span class="line">    program hdr offset/size/num in file:</span><br><span class="line">    section hdr offset/size/num in file:</span><br><span class="line">    str table of section hdr idx:</span><br></pre></td></tr></table></figure>

<h3 id="readelf-S"><a href="#readelf-S" class="headerlink" title="readelf -S"></a>readelf -S</h3><p>使用命令 <strong>readelf -S</strong> 可以查看一个 ELF 文件的 Section Header 信息。</p>
<p>一个 ELF 文件中到底有哪些具体的 sections，由包含在这个 ELF 文件中的 section head table (SHT) 决定。每个 section 描述了这个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其它属性。</p>
<p>下面介绍下常见和比较重要的 section：</p>
<table>
<thead>
<tr>
<th>sh_name</th>
<th>sh_type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>.text</td>
<td>SHT_PROGBITS</td>
<td>代码段，包含程序的可执行指令</td>
</tr>
<tr>
<td>.data</td>
<td>SHT_PROGBITS</td>
<td>包含初始化了的数据，将出现在程序的内存映像中</td>
</tr>
<tr>
<td>.bss</td>
<td>SHT_NOBITS</td>
<td>未初始化数据</td>
</tr>
<tr>
<td>.rodata</td>
<td>SHT_PROGBITS</td>
<td>包含只读数据</td>
</tr>
<tr>
<td>.comment</td>
<td>SHT_PROGBITS</td>
<td>包含版本控制信息</td>
</tr>
<tr>
<td>.eh_frame</td>
<td>SHT_PROGBITS</td>
<td>它生成描述如何 unwind 堆栈的表</td>
</tr>
<tr>
<td>.debug</td>
<td>SHT_PROGBITS</td>
<td>此节区包含用于符号调试的信息</td>
</tr>
<tr>
<td>.dynsym</td>
<td>SHT_DYNSYM</td>
<td>此节区包含了动态链接符号表</td>
</tr>
<tr>
<td>.shstrtab</td>
<td>SHT_STRTAB</td>
<td>存放 section 名，字符串表。Section Header String Table</td>
</tr>
<tr>
<td>.strtab</td>
<td>SHT_STRTAB</td>
<td>字符串表</td>
</tr>
<tr>
<td>.symtab</td>
<td>SHT_SYMTAB</td>
<td>符号表</td>
</tr>
<tr>
<td>.got</td>
<td>SHT_PROGBITS</td>
<td>全局偏移表</td>
</tr>
<tr>
<td>.plt</td>
<td>SHT_PROGBITS</td>
<td>过程链接表</td>
</tr>
<tr>
<td>.relname</td>
<td>SHT_REL</td>
<td>包含了重定位信息，例如 .text 节区的重定位节区名字将是：.rel.text</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Section 头部定义如以下结构体所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* /include/uapi/linux/elf.h */</span><br><span class="line">typedef struct elf32_shdr &#123;</span><br><span class="line">        Elf32_Word sh_name;     // 节区名，名字是一个 NULL 结尾的字符串。</span><br><span class="line">        Elf32_Word sh_type;     // 为节区类型</span><br><span class="line">        Elf32_Word sh_flags;    // 节区标志</span><br><span class="line">        Elf32_Addr sh_addr;     // 节区的第一个字节应处的位置。否则，此字段为 0。</span><br><span class="line">        Elf32_Off sh_offset;    // 此成员的取值给出节区的第一个字节与文件头之间的偏移。</span><br><span class="line">        Elf32_Word sh_size;     // 此成员给出节区的长度（字节数）。</span><br><span class="line">        Elf32_Word sh_link;     // 此成员给出节区头部表索引链接。其具体的解释依赖于节区类型。</span><br><span class="line">        Elf32_Word sh_info;     // 此成员给出附加信息，其解释依赖于节区类型。</span><br><span class="line">        Elf32_Word sh_addralign;    // 某些节区带有地址对齐约束.</span><br><span class="line">        Elf32_Word sh_entsize;      // 给出每个表项的长度字节数。</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>

<p>简单归纳各字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section header: （用于 link 的 elf 必须有，其他文件不是必要的）</span><br><span class="line">    name（string tbl index）、offset、size、addr</span><br><span class="line">    type:</span><br><span class="line">        PROGBITS</span><br><span class="line">        REL：重定位，如.rel.text</span><br><span class="line">        NOBITS：</span><br><span class="line">        STRTAB：字符串表，格式为 str1 \0 str2 \0 ... (其他使用该 str 时不需要记录 size)</span><br><span class="line">        SYMTAB：格式</span><br><span class="line"></span><br><span class="line">    flag: write、alloc、execute、merge、strings、info、exclude、group</span><br><span class="line"></span><br><span class="line">    .rel.text：</span><br><span class="line">         Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">        00000038  00000e04 R_MIPS_26         00000000   b_func_1</span><br><span class="line"></span><br><span class="line">    .symtab：</span><br><span class="line">    val：取决 type，可能是地址（相对所在 section 的 offset）</span><br><span class="line">    type 有 SECTION  OBJECT（变量） FUNC  NOTYPE（外部 sym） FILE（文件名 a.c）</span><br><span class="line">    Ndx: ABS (文件名)  UND（外部 sym）其他为所在 section index</span><br><span class="line">    Bind：LOCAL   GLOBAL（外部可见）</span><br><span class="line">    例子：</span><br><span class="line">        Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">        13: 00000000   200 FUNC    GLOBAL DEFAULT    1 a_func_1</span><br><span class="line">        14: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND b_func_1</span><br></pre></td></tr></table></figure>

<h3 id="readelf-I"><a href="#readelf-I" class="headerlink" title="readelf -I"></a>readelf -I</h3><p>使用命令 <strong>readelf -l</strong> 可以查看一个 ELF 文件的 Program Header 信息。</p>
<p>程序头是一个结构的数组，每一个结构都表示一个段 (segments)。在可执行文件或者共享链接库中所有的节 (sections) 都被分为不同的几个段 (segments)。</p>
<p>程序头的索引地址 (e_phoff)、段数量 (e_phnum)、表项大小 (e_phentsize) 都是通过 ELF 头部信息获取的。</p>
<p>Program 头部定义如以下结构体所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* /include/uapi/linux/elf.h */</span><br><span class="line">typedef struct elf32_phdr &#123;</span><br><span class="line">      Elf32_Word    p_type;    /* Magic number and other info */</span><br><span class="line">      Elf32_Off p_offset;</span><br><span class="line">      Elf32_Addr    p_vaddr;</span><br><span class="line">      Elf32_Addr    p_paddr;</span><br><span class="line">      Elf32_Word    p_filesz;</span><br><span class="line">      Elf32_Word    p_memsz;</span><br><span class="line">      Elf32_Word    p_flags;</span><br><span class="line">      Elf32_Word    p_align;</span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>

<p>简单归纳各字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program Headers:（用于进程 img 加载，其他文件不是必要的）</span><br><span class="line">    例子：</span><br><span class="line">      Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">      REGINFO        0x000094 0x00400094 0x00400094 0x00018 0x00018 R   0x4</span><br><span class="line">      LOAD           0x000000 0x00400000 0x00400000 0x003a0 0x003a0 R E 0x10000</span><br><span class="line">      LOAD           0x0003a0 0x004103a0 0x004103a0 0x00020 0x00050 RW  0x10000</span><br><span class="line"></span><br><span class="line">     Section to Segment mapping:</span><br><span class="line">      Segment Sections...</span><br><span class="line">       00     .reginfo</span><br><span class="line">       01     .reginfo .text</span><br><span class="line">       02     .data .sbss .bss</span><br></pre></td></tr></table></figure>

<p>从加载的角度来看，ELF 文件被分成了许多段，ELF 文件中的代码，链接信息和注释都以段的形式存访。每个段在程序表头表中有一个描述项，分别包含段的类型，段的驻留位置相对于 ELF 文件开始处的偏移量，段在内存中的首地址，段的物理地址，段在文件中的大小，段在内存中的大小，段的对齐标志，如上图所示。</p>
<p>一个可执行文件至少要有一个可加载类型的段，这种类型的段会被装载或映射进内存中，这个会在后面分析程序加载流程时会描述到。</p>
]]></content>
  </entry>
  <entry>
    <title>makefile基础介绍</title>
    <url>/2026/01/18/C%E8%AF%AD%E8%A8%80/makefile%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Makefile 是一个文本文件，描述了一个或者多个目标-依赖关系以及目标对应的生成/更新（后续统一称为更新）规则。</p>
<p>Makefile 由 make 命令一键解析并处理。</p>
<p>通过 Makefile+make 的支持，我们可以以层级的方式组织项目的成百上千个代码文件，并达到增量编译的目的、以减少编译时间。</p>
<h3 id="本文的阅读方式"><a href="#本文的阅读方式" class="headerlink" title="本文的阅读方式"></a>本文的阅读方式</h3><p>本文只列出了我们工作中常用的 Makefile 语法，还有一些高级语法及特性没有没有讲解。</p>
<p>本文出现的示例代码中：</p>
<ul>
<li><code>$</code>为命令行提示符，意为等待用户输入</li>
<li><code>#</code>开头的为注释，也是 Makefile中 的注释符号</li>
<li>部分示例可以直接保存到文件中运行，行首的的空格需要改为 Tab，否则编译会提示 <code>missing separator. Stop.</code></li>
</ul>
<h2 id="Makefile-基本组成"><a href="#Makefile-基本组成" class="headerlink" title="Makefile 基本组成"></a>Makefile 基本组成</h2><p>Makefile 由以下的基本结构外加其他一些特性（如变量定义、文件包含等）组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target(s) : prerequisite(s)</span><br><span class="line">    command(s)</span><br></pre></td></tr></table></figure>

<p>我们通过以下一个简单的Makefile来讲解这个基本的结构：</p>
<p>Makefile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main: main.o libtest.a test.h</span><br><span class="line">    cc -o main main.o -L. -ltest</span><br><span class="line"></span><br><span class="line"># 隐含规则</span><br><span class="line"># main.o: main.c</span><br><span class="line">#   cc -c main.c -o main.o</span><br><span class="line"></span><br><span class="line">libtest.a: test.c test.h</span><br><span class="line">    cc -c -o test.o test.c</span><br><span class="line">    ar rv libtest.a test.o</span><br><span class="line"></span><br><span class="line">.PHONY:</span><br><span class="line">clean:</span><br><span class="line">    -rm main.o main test.o libtest.a</span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;test.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    printf(&quot;main sizeof struct TEST %d\n&quot;, sizeof(struct TEST));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test.c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;test.h&quot;</span><br><span class="line"></span><br><span class="line">int test(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;test sizeof struct TEST: %ld\n&quot;, sizeof(struct TEST));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test.h</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef _TEST_H_</span><br><span class="line">#define _TEST_H_</span><br><span class="line"></span><br><span class="line">struct TEST</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int test(void);</span><br><span class="line"></span><br><span class="line">#endif /* _TEST_H_ */</span><br></pre></td></tr></table></figure>

<p>该 Makefile支 持的功能有：</p>
<ol>
<li>执行 <code>make</code>或<code>make main</code>：编译 main.c 更新可执行程序 main</li>
<li>执行 <code>make libtest.a</code>：编译 test.c 更新静态库 libtest.a</li>
<li>执行 <code>make clean</code>：删除中间产物 main.o、test.o、libtest.a 及可执行程序 main</li>
</ol>
<h3 id="目标列表-targets"><a href="#目标列表-targets" class="headerlink" title="目标列表 targets"></a>目标列表 targets</h3><p>什么可以作为目标：</p>
<ul>
<li>一个文件，如可执行程序 main、静态库 libtest.a</li>
<li>一个动作，如删除动作 clean<ul>
<li>clean 动作未对应实际文件，因此也称作伪目标</li>
<li>为避免当磁盘上存在一个名为 clean 文件时，目标 clean 对应规则无法执行，可通过 <code>.PHONY</code> 特殊目标将 clean 目标声明为伪目标</li>
</ul>
</li>
</ul>
<p>Makefile 可支持多个目标，Makefile 中出现的第一个目标，是 <code>make</code> 命令默认更新的目标。</p>
<p>所以我们在更新 main 的时候，可以不用指定 main 目标，但要执行 clean 动作或者更新 libtest.a 时，就要在 <code>make</code> 时明确指定目标了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make                    # 更新main无需指定</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc -c -o test.o test.c</span><br><span class="line">ar rv libtest.a test.o</span><br><span class="line">ar: creating libtest.a</span><br><span class="line">a - test.o</span><br><span class="line">cc -o main main.o -ltest</span><br><span class="line">$ make main               # 也可以指定main</span><br><span class="line">make: &#x27;main&#x27; is up to date.</span><br><span class="line">$ make clean              # 更新clean需指定</span><br><span class="line">rm main.o main test.o libtest.a</span><br></pre></td></tr></table></figure>



<h3 id="依赖列表-prerequisites"><a href="#依赖列表-prerequisites" class="headerlink" title="依赖列表 prerequisites"></a>依赖列表 prerequisites</h3><p>什么可以作为目标的依赖：</p>
<ul>
<li>一个或多个文件，如 main.o</li>
<li>另外的一个或多个目标，如 libtest.a</li>
<li>依赖可以为空</li>
</ul>
<p><code>make</code> 命令通过目标-依赖这个组合达到增量更新的目的：</p>
<ul>
<li>依赖的文件修改时间比目标文件更新（包含目标文件不存在），才触发执行规则<ul>
<li>main.o、libtest.a 或 test.h 有一个比可执行文件 main 更新，则触发执行 <code>cc -o main main.o -ltest</code> 命令</li>
<li>test.c 比 libtest.a 新，则触发执行对应 <code>cc</code> 和 <code>ar</code> 命令</li>
</ul>
</li>
<li>如依赖是一个或多个目标，且依赖需要更新，则按书写顺序先递归更新依赖<ul>
<li>判断是否需要更新 main 时，要先依次判断依赖 main.o 和 libtest.a 是否需要更新</li>
</ul>
</li>
<li>特别的，伪目标没有对应文件，不管依赖文件是否更新，必然触发执行规则<ul>
<li>clean 是伪目标，更新该目标时必然触发 <code>rm</code> 操作</li>
</ul>
</li>
</ul>
<p><strong>注意：C/C++ 头文件未出现在依赖中可能引发运行错误</strong></p>
<p>对于 C/C++ 代码，编写的 Makefile 中依赖关系通常没有包含头文件，如果涉及头文件更新（如结构体新增一个字段），会导致包含该头文件的源文件没有被重新编译，进而导致运行时出错（不同源文件中结构体的大小不一致）。</p>
<p>如果涉及有头文件更新，保险起见建议 clean 清除最终及中间产物后重新编译（或通过 <code>-B</code> 选项强制重建所有目标）。</p>
<p>我们修改 Makefile 删除第一行 main 对 test.h 的依赖，TEST 结构体新增一个变量，然后 <code>touch test.c</code>，然后更新并执行 main 看会出现什么问题：</p>
<p>修改后 Makefile：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main: main.o libtest.a</span><br><span class="line">    cc -o main main.o -L. -ltest</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>修改后 test.h：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">struct TEST</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -c -o test.o test.c</span><br><span class="line">ar rv libtest.a test.o</span><br><span class="line">r - test.o</span><br><span class="line">cc -o main main.o -L. -ltest</span><br><span class="line">$ ./main</span><br><span class="line">test sizeof struct TEST: 8</span><br><span class="line">main sizeof struct TEST: 4</span><br></pre></td></tr></table></figure>



<h3 id="执行命令-commands"><a href="#执行命令-commands" class="headerlink" title="执行命令 commands"></a>执行命令 commands</h3><p>执行命令是更新目标所执行的动作，由一组Shell命令组成，它们被顺序执行。需要注意：</p>
<ul>
<li>除了第一条命令可以跟在依赖列表之后、以分号分隔之外，命令<strong>必须以水平制表符 <code>TAB</code> 开头</strong>，否则会引发语法错误：</li>
</ul>
<p>libtest.a 更新规则可改写为（但一般不会这么做，命令单独书写看起来更美观）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libtest.a: test.c test.h; cc -c -o test.o test.c</span><br><span class="line">  ar rv libtest.a test.o</span><br></pre></td></tr></table></figure>

<p>将 Makefile 第9行编译 test.c 命令的 <code>cc</code> 前的 TAB 替换成空格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libtest.a: test.c test.h</span><br><span class="line"> cc -c -o test.o test.c</span><br><span class="line">  ar rv libtest.a test.o</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">Makefile:9: *** missing separator.  Stop.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>每一行命令都在一个子 Shell 中执行，每一个子 Shell 都通过 <code>fork</code> 一个新的进程来执行，各个子Shell的运行结果不互相影响，因此<strong>特别注意</strong>：</p>
<ul>
<li>相互依赖的命令需要写在同一行</li>
</ul>
<p>看如下 Makefile 的执行的结果是否符合你的预期：</p>
<p>我想在 /home/tp 目录下的 Makefile 中，获取到 /home/tp/test 目录的绝对路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.PHONY: test</span><br><span class="line">test:</span><br><span class="line">    # 正确做法</span><br><span class="line">    @cd test; pwd</span><br><span class="line"></span><br><span class="line">    # 错误做法</span><br><span class="line">    @cd test</span><br><span class="line">    @pwd</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">/home/tp/test</span><br><span class="line">/home/tp</span><br></pre></td></tr></table></figure>

<ul>
<li>Shell 的 <code>if</code>、<code>for</code> 等结构通过行连接符 <code>\</code> 连接成一行，否则会有语法错误：</li>
</ul>
<p>我想在 1 小于 2 的情况下打印”1 &lt; 2”，但如下 Makefile 将在 <code>make</code> 时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.PHONY: test</span><br><span class="line">test:</span><br><span class="line">    if [ 1 -lt 2 ]; then</span><br><span class="line">        echo &quot;1 &lt; 2&quot;;</span><br><span class="line">    fi</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">if true; then</span><br><span class="line">/bin/sh: -c: line 1: syntax error: unexpected end of file # if true; then和fi孤立存在，Shell if结构不完整导致报错</span><br><span class="line">Makefile:3: recipe for target &#x27;test&#x27; failed # 报错在Makefile第三行的Shell if</span><br><span class="line">make: *** [test] Error 1</span><br></pre></td></tr></table></figure>

<p>修改后的 Makefile：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.PHONY: test</span><br><span class="line">test:</span><br><span class="line">    if [ 1 -lt 2 ]; then \</span><br><span class="line">        echo &quot;1 &lt; 2&quot;; \</span><br><span class="line">    fi</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">1 &lt; 2</span><br></pre></td></tr></table></figure></li>
<li><p><strong>命令组不能孤立存在，必须置于目标下或命令包内</strong>，否则会出现语法错误</p>
</li>
</ul>
<p>我们在 Makefile 的开始加上一行 <code>echo</code>，看会出现什么问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1   echo &quot;test&quot;</span><br><span class="line">2</span><br><span class="line">3 main: main.o libtest.a</span><br><span class="line">4   cc -o main main.o -L. -ltest</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">Makefile:1: *** recipe commences before first target.  Stop. # 新增的第一行echo命令报错</span><br></pre></td></tr></table></figure>



<h4 id="定义命令包-中阶"><a href="#定义命令包-中阶" class="headerlink" title="定义命令包 - 中阶"></a>定义命令包 - 中阶</h4><p>书写 Makefile 时，可能有多个目标的生成会使用相同的一组命令。我们可以把这一组命令定义成一个命令包，然后各个目标的执行规则中通过 <code>$(cmd-pack)</code> 调用对应命令包就可以。</p>
<p>命令包的定义结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define cmd-pack</span><br><span class="line">    Shell-cmd</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define cc_compile</span><br><span class="line">    @cc -g -o $@ $^ # $@/$^是Makefile的自动变量，分别代表目标列表及依赖列表，自动变量一节</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">main: main.c test.c</span><br><span class="line">    $(cc_compile)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -g -o main main.c test.c</span><br></pre></td></tr></table></figure>



<h2 id="Makefile-的执行过程"><a href="#Makefile-的执行过程" class="headerlink" title="Makefile 的执行过程"></a>Makefile 的执行过程</h2><p>当我们在命令行中执行 <code>make</code> 命令时，后台执行了以下过程：</p>
<ol>
<li>读入 Makefile</li>
<li>读入被 <code>include</code> 的其它 Makefile</li>
<li>初始化文件中的变量</li>
<li>推导隐含规则，并分析所有规则</li>
<li>为所有的目标文件创建依赖关系链</li>
<li>根据依赖关系，决定哪些目标要重新生成</li>
<li>执行规则更新目标。</li>
</ol>
<p>我们以上的介绍中只介绍了 4-7 步骤相关的内容，接下来介绍 1-3 相关的内容。</p>
<h2 id="文件包含-include命令-中阶"><a href="#文件包含-include命令-中阶" class="headerlink" title="文件包含 - include命令 - 中阶"></a>文件包含 - include命令 - 中阶</h2><p>我们使用 <code>include</code>命令包含其他文件，包括且不限于其他形式的Makefile，也可以是普通文本文件，一般我们会以 .mk 为后缀命名。</p>
<p>这些文件一般包含变量定义及函数定义，类似于C语言的 <code>#include</code> 操作。</p>
<p><code>include file</code> 之后我们就可以使用 file 中的定义了。</p>
<h2 id="变量定义与使用-中阶"><a href="#变量定义与使用-中阶" class="headerlink" title="变量定义与使用 - 中阶"></a>变量定义与使用 - 中阶</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量定义常用有两种方式，他们的区别是：</p>
<ul>
<li>variable = value，递归展开式变量定义</li>
</ul>
<p>递归展开的含义是：在定义变量时，如果其包含对其它变量或函数的引用，则在<strong>引用此变量时才对其递归展开、进行文本替换</strong>。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = foo</span><br><span class="line">b = $(a)</span><br><span class="line">a = later</span><br><span class="line">all:; @echo $(b) # 即定义b时，b的值就是$(a)，在通过$(b)引用变量a时，才触发$(b)-&gt;$(a)-&gt;later的文本替换</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">later</span><br></pre></td></tr></table></figure>

<ul>
<li>variable := value，直接展开式变量定义</li>
</ul>
<p>直接展开的意思是，<strong>在定义变量时</strong>，变量值中对其他量或者函数的引用在定义变量时<strong>就已经被展开、进行文本替换了</strong>。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a := foo</span><br><span class="line">b := $(a)</span><br><span class="line">a := later</span><br><span class="line">all:; @echo $(b) # 即定义a时，a的值就是$(b)，在通过$(a)引用变量a时，才触发$(a)-&gt;$(b)-&gt;$(c)-&gt;d的文本替换</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">foo</span><br></pre></td></tr></table></figure>

<p>更多的赋值方式（条件赋值 <code>?=</code> 和 追加赋值 <code>+=</code>）可参考</p>
<h3 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h3><p>如以上例子显示，通过 <code>$(val)</code> 或 <code>$&#123;var&#125;</code> 方式引用变量值。</p>
<p>由于 Makefile 的执行规则中大部分都是 Shell 相关命令，Shell 命令中也可能包含变量定义。在 Makefile 的 Shell 语句中访问 Shell 变量时，需要对 <code>$</code> 进行转义，即通过 <code>$$var</code> 来访问Shell变量。</p>
<blockquote>
<p>如果要使用 <code>$</code> 的字面值，需要通过 <code>$$</code> 转义。</p>
</blockquote>
<p>例如，通过Shell for循环一次打印Makefile的list变量中的单词：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = 1 2 3</span><br><span class="line">all:</span><br><span class="line">    for i in $(list); do \</span><br><span class="line">        echo $$i; \</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>



<h4 id="变量的高级用法"><a href="#变量的高级用法" class="headerlink" title="变量的高级用法"></a>变量的高级用法</h4><h5 id="变量的替换引用"><a href="#变量的替换引用" class="headerlink" title="变量的替换引用"></a>变量的替换引用</h5><p>对于一个已经定义的变量，可以使用替换引用将其值中的后缀字符串使用指定的字符字符串替换。</p>
<p>格式为 <code>$(VAR:A=B)</code> ，意为替换变量 VAR 中所有 <code>A</code> 字符串的字为 <code>B</code> 结尾的字符串。</p>
<p>例如，将二进制文件名替换成源文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj_files := a.o b.o c</span><br><span class="line">src_files := $(obj_files:.o=.c)</span><br><span class="line">all:</span><br><span class="line">    @echo $src_files</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">a.c b.c c</span><br></pre></td></tr></table></figure>



<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>当前文件中定义的变量默认只在当前 Makefile 生效。</p>
<p>如果要生效在子 Makefile，需要通过 <code>export</code> 声明，或者通过命令行 <code>make var=val</code> 命令传入。当然也可通过 <code>include</code> 命令将变量定义引入到其他文件。</p>
<p>例如：</p>
<p>被下一个 Makefile 调用的 Makefile：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all:</span><br><span class="line">    @echo $(export_var)</span><br><span class="line">    @echo $(cmd_line_var)</span><br></pre></td></tr></table></figure>

<p>调用上面的 Makefile，并通过 <code>export</code> 和命令行传入变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export export_var = &quot;export variable&quot;</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">    @make -f makefile2 cmd_line_var=&quot;command line variable&quot;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">make[1]: Entering directory &#x27;/home/tp&#x27;</span><br><span class="line">export variable</span><br><span class="line">command line variable</span><br><span class="line">make[1]: Leaving directory &#x27;/home/tp&#x27;</span><br></pre></td></tr></table></figure>



<h2 id="流程控制-中阶"><a href="#流程控制-中阶" class="headerlink" title="流程控制 - 中阶"></a>流程控制 - 中阶</h2><p>Shell 流程控制只支持<code>ifeq</code>/<code>ifneq</code>/<code>ifdef</code>/<code>ifndef</code>，其他流程控制如循环、<code>case</code>等需要函数或 Shell 命令支持。</p>
<p><code>ifeq</code>/<code>ifneq</code>结构，判断 ARG1 与 ARG2 是否相等或不等：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifeq (ARG1, ARG2)</span><br><span class="line">    texts # ARG1 == ARG2分支</span><br><span class="line">else</span><br><span class="line">    texts # ARG1 != ARG2分支</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p><code>ifdef</code>/<code>ifndef</code>结构，判断变量是否定义或未定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifdef var</span><br><span class="line">    texts # var定义执行分支</span><br><span class="line">else</span><br><span class="line">    texts # var未定义执行分支</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p><code>ifeq</code>/<code>ifdef</code>结构均可嵌套使用。<code>else</code> 是可选分支。</p>
<p>注意：<code>ifeq</code>/<code>ifneq</code>/<code>ifdef</code>/<code>ifndef</code>不是 Shell 命令，在执行规则中无需以制表符 TAB 开头；若最外层 <code>if</code> 以制表符开头，将会引发语法错误。</p>
<p>示例：</p>
<p>以下 Makefile 判断 var 是否定义，以及定义的情况下变量值是否为空：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var = &quot; &quot; # 空格等空白字符必须由引号包含</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">ifdef var</span><br><span class="line">ifeq ($(var), &quot; &quot;)</span><br><span class="line">    @echo &quot;var is space&quot;</span><br><span class="line">else</span><br><span class="line">    @echo &quot;var is not space&quot;</span><br><span class="line">endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">var is space</span><br></pre></td></tr></table></figure>



<h2 id="内置函数-中-高阶"><a href="#内置函数-中-高阶" class="headerlink" title="内置函数 - 中/高阶"></a>内置函数 - 中/高阶</h2><p>Makefile内置了一些常用函数，常用函数按功能分类主要有以下：</p>
<ul>
<li>字符串处理函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>调用方式及作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>patsubst</code></td>
<td><code>$(patsubst pattern, replacement, text)</code>，模式字符串替换，将 text 末尾的 pattern 替换为 replacement</td>
</tr>
<tr>
<td><code>subst</code></td>
<td><code>$(subst from, to, text)</code>，字符串替换，将 text 中 from 替换为 to</td>
</tr>
<tr>
<td><code>strip</code></td>
<td><code>$(strip text)</code>，去掉字符串 text 的开头和结尾的空格，并且将其中的多个连续的空格合并成为一个空格</td>
</tr>
<tr>
<td><code>findstring</code></td>
<td><code>$(findstring sub, text)</code>，字符串查找，在 text 中查找 sub 字符串</td>
</tr>
<tr>
<td><code>filter</code></td>
<td><code>$(filter pattern, text)</code>，模式过滤，在 text 中过滤出符合 pattern 模式的字符串，pattern 可包含多个模式</td>
</tr>
<tr>
<td><code>filter-out</code></td>
<td><code>$(filter-out pattern, text)</code>，模式反过滤，在 text 中过滤出不符合 pattern 模式的字符串，pattern 可包含多个模式</td>
</tr>
<tr>
<td><code>sort</code></td>
<td><code>$(sort list)</code>，单词排列，对 list 中包含的单词去重后、按照升序排列</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：以上 pattern中 一般需要包含模式字符 <code>%</code>，如 %.c 匹配C源文件。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ori = 1.o       3.o 3.o 2.c</span><br><span class="line">striped = $(strip $(ori)) # 去除多余空格</span><br><span class="line">sorted = $(sort $(ori))   # 去重、排序</span><br><span class="line">patsubsted = $(patsubst %.o, %.c, $(ori)) # 模式替换</span><br><span class="line">substed = $(subst 2, 4, $(ori))           # 字符串替换：2.c替换成4.c</span><br><span class="line">find_string = $(findstring foo, foo bar)  # 查找字符串foo</span><br><span class="line">filtered = $(filter %.c, $(ori))          # 过滤出.c文件</span><br><span class="line">filtered_out = $(filter-out %.c, $(ori))  # 过滤出非.c文件</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">  @echo &quot;ori: $(ori)&quot;</span><br><span class="line">  @echo &quot;striped: $(striped)&quot;</span><br><span class="line">  @echo &quot;sorted: $(sorted)&quot;</span><br><span class="line">  @echo &quot;patsubsted: $(patsubsted)&quot;</span><br><span class="line">  @echo &quot;substed: $(substed)&quot;</span><br><span class="line">  @echo &quot;find_string: $(find_string)&quot;</span><br><span class="line">  @echo &quot;filtered: $(filtered)&quot;</span><br><span class="line">  @echo &quot;filteredout: $(filtered_out)&quot;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">ori: 1.o       3.o 3.o 2.c</span><br><span class="line">striped: 1.o 3.o 3.o 2.c</span><br><span class="line">sorted: 1.o 2.c 3.o</span><br><span class="line">patsubsted:  1.c  3.c  3.c 2.c</span><br><span class="line">substed:  1.o       3.o 3.o  4.c</span><br><span class="line">find_string: foo</span><br><span class="line">filtered: 2.c</span><br><span class="line">filteredout: 1.o 3.o 3.o</span><br></pre></td></tr></table></figure>

<ul>
<li>文件名操作函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>调用方式及作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>wildcard</code></td>
<td><code>$(wildcard pattern)</code>，列出当前目录下所有符合模式 pattern 格式的文件名（patter 中包含有通配符；pattern 中也可包含目录名）</td>
</tr>
<tr>
<td><code>dir</code></td>
<td><code>$(dir file_paths)</code>，取 file_paths 文件路径目录名部分（最后一个 <code>/</code>之前的内容）</td>
</tr>
<tr>
<td><code>notdir</code></td>
<td><code>$(notdir file_paths)</code>，取 file_paths 文件路径目录名部分（最后一个 <code>/</code> 之后的内容）</td>
</tr>
<tr>
<td><code>basename</code></td>
<td><code>$(notdir file_paths)</code>，取 file_paths 文件路径名的前缀部分（文件路径名中最后一个点号之前的部分）</td>
</tr>
</tbody></table>
<blockquote>
<p><code>*</code> 是我们经常使用的文件名通配符，代表符合某一规则的所有文件，如以下 src/*. c代表 src 目录下的所有 C 源文件</p>
</blockquote>
<p>示例：</p>
<p>/home/tp/src 文件夹下有一 1.c 文件，通过 Makefile 获取其相关信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SRC = $(wildcard src/*.c)</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        @echo &quot;source file $(SRC):&quot;</span><br><span class="line">        @echo -e &quot;\tdir      - $(dir $(SRC))&quot;</span><br><span class="line">        @echo -e &quot;\tfilename - $(notdir $(SRC))&quot;</span><br><span class="line">        @echo -e &quot;\tbasename - $(basename $(SRC))&quot;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">source file src/1.c:</span><br><span class="line">        dir      - src/</span><br><span class="line">        filename - 1.c</span><br><span class="line">        basename - src/1</span><br></pre></td></tr></table></figure>

<p>注意：<code>wildcard</code> 并不会自动帮你补全绝对路径，你需要自己处理。</p>
<ul>
<li>控制函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>调用方式及作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>if</code></td>
<td><code>$(if conditon(s), then-part[, else-part])</code>，类似于 Shell if 功能，conditon(s) 展开结果非空时执行 then-part、否则执行 else-part，[] 代表 else-part 可选</td>
</tr>
<tr>
<td><code>foreach</code></td>
<td><code>$(foreach var, list, op)</code>，类似于 Shell for 功能，依次取 list 中单词赋值给 var ，然后在 var 上执行 op 操作</td>
</tr>
<tr>
<td><code>warning</code></td>
<td><code>$(warning text)</code>，输出一条警告信息</td>
</tr>
<tr>
<td><code>error</code></td>
<td><code>$(error text)</code>，输出一条错误信息、并退出 <code>make</code> 命令</td>
</tr>
</tbody></table>
<p>示例一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">texts = foo bar baz</span><br><span class="line">print_on_off =</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">  @echo $(foreach i, $(texts), $(Shell echo *$i*)) # 依次为texts中单词两边加上星号*</span><br><span class="line">  @echo $(if $(print_on_off), print on, print off) # 查看打印开关print_on_off是否定义且非空</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">*foo* *bar* *baz*</span><br><span class="line">print off</span><br></pre></td></tr></table></figure>

<p>示例二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all:</span><br><span class="line">  $(warning this is warning msg) # 打印一条警告信息</span><br><span class="line">  $(error this is error msg)     # 打印一条错误信息并退出</span><br><span class="line">  $(warning cannot reach me)     # error后的流程执行不到了</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">makefile:2: this is warning msg</span><br><span class="line">makefile:2: *** this is error msg.  Stop.</span><br></pre></td></tr></table></figure>

<ul>
<li>其他常用函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>调用方式及作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>shell</code></td>
<td><code>$(shell shell-cmd)</code>，执行一条 Shell 命令、并返回执行结果，也可以用 Shell 的操作符 ``替代</td>
</tr>
</tbody></table>
<p>Shell 函数示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PWD = $(Shell pwd)</span><br><span class="line">DIRS = `ls`</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">  @echo &quot;current work directory is $(PWD)&quot;</span><br><span class="line">  @echo &quot;dirs under current directory: $(DIRS)&quot;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">current work directory is /home/tp</span><br><span class="line">dirs under current directory: Desktop Documents Downloads examples.desktop ...</span><br></pre></td></tr></table></figure>

<p>call函数示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reverse = $(2) $(1)</span><br><span class="line"></span><br><span class="line">define func</span><br><span class="line">  @echo $(1) $(2)</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">  @echo $(call reverse, a, b)       # 翻转a b =&gt; b a</span><br><span class="line">  $(call func, hello, Li Lei)       # 通过call + func执行打印动作</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">b a</span><br><span class="line">hello Li Lei</span><br></pre></td></tr></table></figure>



<h2 id="其他常用特性-中阶"><a href="#其他常用特性-中阶" class="headerlink" title="其他常用特性 - 中阶"></a>其他常用特性 - 中阶</h2><h3 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h3><p>隐含规则为 <code>make</code> 提供了重建一类符合某一模式的目标文件的固定及通用方法，针对这类某的目标文件，无需显示的在Makefile中定义规则，<code>make</code> 命令会自动帮我们生成。</p>
<p>make命令根据文件名后缀自动推导的规则，跟我们工作相关的常用隐含规则有：</p>
<ul>
<li>编译 C 程序：file.o 自动由 file.c 生成，执行命令为 <code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code></li>
<li>编译 C++ 程序：file.o 自动由 file.cc 或 file.C 生成，执行命令为 <code>$(CXX) -c $(CPPFLAGS) $(CFLAGS)</code></li>
<li>链接单一的 object 文件：exe 自动由 exe.o 生成，执行命令是 <code>$(CC) $(LDFLAGS) N.o $(LOADLIBES) $(LDLIBS)</code></li>
</ul>
<blockquote>
<p>建议针对所有目标显示定义执行规则，隐式规则在 Makefile 中不可见，并且可能与我们的需求不符</p>
</blockquote>
<p>从文章开头的示例 Makefile 的执行结果可以看到，虽然我们并没有在 Makefile 中为 main.o 显示的定义规则，但 <code>make</code> 命令还是执行了 <code>cc</code> 编译命令：</p>
<p>Makefile 截取片段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main: main.o libtest.a test.h</span><br><span class="line">    cc -o main main.o -L. -ltest</span><br><span class="line"></span><br><span class="line"># 隐含规则</span><br><span class="line"># main.o: main.c</span><br><span class="line">#   cc -c main.c -o main.o</span><br><span class="line"></span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>执行结果截取片段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make                    # 更新main无需指定</span><br><span class="line">cc    -c -o main.o main.c</span><br></pre></td></tr></table></figure>


<h3 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h3><p>静态模式规则的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target(s): target-pattern: prereq-pattern(s)</span><br><span class="line">    command(s)</span><br></pre></td></tr></table></figure>

<ul>
<li>targets，列出了静态规则适用的所有目标；可以省略，省略时意味着对该文件中所有符合 target-pattern 的目标生效</li>
<li>target-pattern，描述了目标文件的模式、需包含模式字符 <code>%</code></li>
<li>prereq-patterns，描述了依赖文件所包含的模式组合、需包含模式字符 <code>%</code></li>
</ul>
<p>以以下编译当前目录下 main.c test.c other.c 生成对应目标文件的 Makefile 为例，说明该语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OBJS = main.o test.o # OBJS中可以包含非.o文件，但make时会报警，不建议这么做</span><br><span class="line">OTHER = other.c</span><br><span class="line"></span><br><span class="line">all: $(OBJS) $(OTHER)</span><br><span class="line"></span><br><span class="line">$(OBJS): %.o: %.c    # 改为%.o: %.c，看看目标other.o是不是也由该规则生成</span><br><span class="line">    cc -g -c -o $@ $&lt;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -g -c -o main.o main.c   # main.o和test.o使用静态模式规则生成</span><br><span class="line">cc -g -c -o test.o test.c</span><br><span class="line">cc    -c -o other.o other.c # other.o由隐含规则生成</span><br></pre></td></tr></table></figure>

<p>该 Makefile 的执行过程是：</p>
<ol>
<li><code>make</code> 命令默认生成 all，检查其依赖目标 main.o test.o 是否需要更新；</li>
<li>根据静态规则的描述，目标文件应以 .o 为后缀，并依赖于同名的后缀为 .c 的源文件，即 main.o 依赖于 main.c、test.o 依赖于 test.c;</li>
<li>查找 main.c 文件是否存在，且比 main.o 更新，是则执行 <code>cc</code> 命令更新 main.o；test.o 也是同样处理；</li>
<li>main.o test.o 更新完毕，all 是伪目标，每次 <code>make</code> 都需要更新，但执行规则为空，所以没有执行什么指令。</li>
</ol>
<h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>关于自动化变量可以理解为由 Makefile 自动产生的变量。</p>
<p>在以上描述的静态模式规则中，依赖文件和目标文件可能是变动的，显然在命令中不能出现具体的文件名称，否则模式规则将失去意义。</p>
<p>那么模式规则命令中该如何表示文件呢？就需要使用自动化变量，常用的自动化变量有：</p>
<table>
<thead>
<tr>
<th>自动化变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$@</code></td>
<td>表示规则的目标文件名，在多目标模式规则中，它代表的是触发规则被执行的文件名。</td>
</tr>
<tr>
<td><code>$&lt;</code></td>
<td>规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</td>
</tr>
<tr>
<td><code>$^</code></td>
<td>代表的是所有依赖文件列表，使用空格分隔</td>
</tr>
</tbody></table>
<p>简单改动下静态模式规则的示例来查看这些自动变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OBJS = main.o test.o</span><br><span class="line"></span><br><span class="line">all: $(OBJS)</span><br><span class="line">    @echo &quot;$$^ is $^&quot; # $^中的$有特殊含义，需要通过转义字符$转义</span><br><span class="line">    @echo &quot;$$&lt; is $&lt;&quot; # $&lt;中的$有特殊含义，需要通过转义字符$转义</span><br><span class="line"></span><br><span class="line">%.o: %.c</span><br><span class="line">    @echo &quot;target: $@, prereq: $&lt;&quot;</span><br><span class="line">    @cc -g -c -o $@ $&lt;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">target: main.o, prereq: main.c</span><br><span class="line">target: test.o, prereq: test.c</span><br><span class="line">\^ is main.o test.o</span><br><span class="line">\&lt; is main.o</span><br></pre></td></tr></table></figure>



<h3 id="常用命令前缀"><a href="#常用命令前缀" class="headerlink" title="常用命令前缀"></a>常用命令前缀</h3><p>可以使用一些命令前缀控制命令的行为，常用的有：</p>
<ul>
<li><code>@cmd</code>，命令执行时不回显（回显为默认行为）</li>
<li><code>-cmd</code>，cmd 执行错误时、忽略错误</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all: $(OBJS)</span><br><span class="line">    echo &quot;echo&quot;</span><br><span class="line">    @echo &quot;no echo&quot;</span><br><span class="line"></span><br><span class="line">    @-rm test</span><br><span class="line">    @rm test</span><br><span class="line"></span><br><span class="line">    @echo &quot;cannot reach me&quot;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">echo &quot;echo&quot; # echo &quot;echo&quot;命令的回显</span><br><span class="line">echo        # echo &quot;echo&quot;命令的执行结果</span><br><span class="line">no echo     # @echo &quot;no echo&quot;的执行结果</span><br><span class="line">rm: cannot remove &#x27;test&#x27;: Is a directory</span><br><span class="line">Makefile:2: recipe for target &#x27;all&#x27; failed</span><br><span class="line">make: [all] Error 1 (ignored) # @-rm test删除不存在test文件的错误被忽略</span><br><span class="line">rm: cannot remove &#x27;test&#x27;: Is a directory</span><br><span class="line">Makefile:2: recipe for target &#x27;all&#x27; failed</span><br><span class="line">make: *** [all] Error 1 # @rm test删除不存在test文件的错误导致make提前退出</span><br></pre></td></tr></table></figure>



<h2 id="make命令常用选项"><a href="#make命令常用选项" class="headerlink" title="make命令常用选项"></a>make命令常用选项</h2><table>
<thead>
<tr>
<th>参数</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-B</code></td>
<td>强制重建所有目标</td>
</tr>
<tr>
<td><code>-C dir</code></td>
<td>切换到 dir 目录执行 <code>make</code> 命令</td>
</tr>
<tr>
<td><code>-f file</code></td>
<td>指定要读入并执行的 Makefile ，<code>make</code> 命令默认读入并执行当前目录下的名为 Makefile、makefile 的文件</td>
</tr>
<tr>
<td><code>-j [N]</code></td>
<td>指定并行 <code>make</code> 的任务数，不带 N 时不限制并行任务数</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>只打印、不执行命令，做调试用</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>在正常处理信息之外打印调试信息，做调试用</td>
</tr>
</tbody></table>
<h3 id="通过-C-选项实现代码层级结构组织"><a href="#通过-C-选项实现代码层级结构组织" class="headerlink" title="通过 -C 选项实现代码层级结构组织"></a>通过 -C 选项实现代码层级结构组织</h3><p>一般情况下，我们单个工程的代码文件还是比较多的。如果按照模块将文件组织在不同的目录及子目录当中，那么我们在查找及管理文件时效率就比较高了。</p>
<p>通过在工程每个父目录的 Makefile 中添加 <code>make -C sub_dir</code> 这样一条指令，我们可以达到编译整个工程目录树的目的。</p>
<p>我们将开头的示例改造一下以展示该功能：</p>
<p>首先将功能相关的文件组织成一下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── main.c</span><br><span class="line">└── test</span><br><span class="line">    ├── test.c</span><br><span class="line">    └── test.h</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure>

<p>然后分别在当前目录及 test 子目录添加 Makefile：</p>
<p>当前目录 Makefile：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main: main.o</span><br><span class="line">    make -C test/      # 进入test 目录，查找 Makefile，并更新默认目标</span><br><span class="line">    cc -o main main.o -Ltest/ -ltest</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    -rm main main.o</span><br><span class="line">    make -C test clean # 进入 test 目录，查找 Makefile，并更新 clean 目标</span><br></pre></td></tr></table></figure>

<p>test 子目录 Makefile：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libtest.a: test.c</span><br><span class="line">    cc -c -o test.o test.c</span><br><span class="line">    ar rv libtest.a test.o</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    -rm libtest.a test.o</span><br></pre></td></tr></table></figure>

<p>在当前目录执行 <code>make</code> 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">make -C test/</span><br><span class="line">make[1]: Entering directory &#x27;/home/tp/test&#x27; # make命令进入test 目录，执行 make 动作</span><br><span class="line">cc -c -o test.o test.c</span><br><span class="line">ar rv libtest.a test.o</span><br><span class="line">ar: creating libtest.a</span><br><span class="line">a - test.o</span><br><span class="line">make[1]: Leaving directory &#x27;/home/tp/test&#x27; # test目录make完成，返回上一级父目录，继续在父目录中执行规则中的剩余动作</span><br><span class="line">cc -o main main.o -Ltest/ -ltest</span><br></pre></td></tr></table></figure>



<h2 id="Makefile调试"><a href="#Makefile调试" class="headerlink" title="Makefile调试"></a>Makefile调试</h2><p>我们调试 Makefile 一般采用两种方式：</p>
<ul>
<li>通过 <code>echo</code> 在关键位置添加打印信息</li>
<li>通过以上 <code>-n</code> 或 <code>-d</code> 命令查看 <code>make</code> 命令输出的信息</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h3><p>《GNU+makefile中文手册》</p>
<p>《跟我一起写Makefile》</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>802.11无线网络</title>
    <url>/2026/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/80211%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="802-11-PHY协议基础"><a href="#802-11-PHY协议基础" class="headerlink" title="802.11 PHY协议基础"></a>802.11 PHY协议基础</h2><h3 id="通信系统模型"><a href="#通信系统模型" class="headerlink" title="通信系统模型"></a>通信系统模型</h3><p><img src="%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B.png" alt="image-20231115155106166"></p>
<ul>
<li><p>信源：产生需要传递给信宿的比特信息。</p>
</li>
<li><p>调制器：将比特信息通过一系列调制方法“放置在”电磁波上，生成调制信号。</p>
</li>
<li><p>信道：调制信号从发送端传递给接收端经过的传输媒介。</p>
</li>
<li><p>解调器：从调制信号中 “提取出”比特信息，是调制器的逆过程。</p>
</li>
<li><p>信宿：接收比特信息。</p>
</li>
</ul>
<h3 id="通信质量指标"><a href="#通信质量指标" class="headerlink" title="通信质量指标"></a>通信质量指标</h3><ul>
<li>有效性：传输效率，可用通信速率来评估。</li>
<li>可靠性：传输质量，可用误符号率来评估。</li>
<li>安全性：通信安全，涉及加密解密技术。</li>
</ul>
<blockquote>
<p>注：有效性和可靠性不可兼得，需要两者权衡</p>
</blockquote>
<h3 id="涉及参数"><a href="#涉及参数" class="headerlink" title="涉及参数"></a>涉及参数</h3><ul>
<li>频率：通信载波频率。目前WiFi使用的频率段包括2.4G、5G和6G。</li>
<li>带宽：信号占用频带宽度。带宽越大，速率越高。</li>
<li>功率：发射信号强度。提高功率可提高传输质量，但会加强对其他通信链路的干扰。</li>
<li>速率：每秒传输的比特数量。一般以Mbps/Gbps为单位。</li>
<li>天线数量：可使用多跟天线进行信号发射和接收，一般接收天线数量要大于有效发射天线数量。</li>
</ul>
<h2 id="802-11-MAC层"><a href="#802-11-MAC层" class="headerlink" title="802.11 MAC层"></a>802.11 MAC层</h2><h3 id="MAC层介绍"><a href="#MAC层介绍" class="headerlink" title="MAC层介绍"></a>MAC层介绍</h3><p>MAC层，即Medium Access Control，顾名思义其主要工作就是：</p>
<ol>
<li>通过管理帧对设备接入进行管控；</li>
<li>通过信道接入规则对信道使用权进行分配，有序管理多终端，进行信道分时使用；</li>
<li>通过控制帧对PHY层的通信过程进行管理调度，实现数据的有效传输；</li>
</ol>
<p><img src="%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.png" alt="image-20231115170736998"></p>
<p>在OSI七层模型中，物理层对应于OSI模型中的最低层，MAC和OSI第二层的下层相对应，该层和逻辑链路控制(LLC)层构成了OSI的第二层。</p>
<p>802.2规定了数据链路层的LLC子层，802.3和802.11都处在物理层和数据链路层的MAC子层。802.3定义了LAN的以太网实现方法，802.11定义了WLAN的以太网实现方法。</p>
<p>有线和无线数据帧格式最重要的区别在于七层模型的下两层，802.11标准仅限于物理层(PHY)和媒介访问控制(MAC)</p>
<p><img src="MAC%E5%B1%82%E4%BB%8B%E7%BB%8D.png" alt="image-20231115161910799"></p>
<p>mac层的通信过程</p>
<p><img src="MAC%E5%B1%82%E9%80%9A%E4%BF%A1.png" alt="image-20231115162138754"></p>
<h3 id="DCF"><a href="#DCF" class="headerlink" title="DCF"></a>DCF</h3><p>IEEE802.11协议定义了两种接入方式，在信道争用期的分布式协调功能(Distributed Coordination Function，简称DCF)与非信道争用期的点协调功能(Point Coordination Function，简称PCF)，其中DCF是必备功能，而PCF由各WLAN设备硬件厂商来决定是否实现。</p>
<p>802.11根据Multi-Access时是否有中心控制设备，来分为Point Coordination Function（PCF）和Distributed Coordination Function（DCF）。</p>
<ul>
<li>PCF:通过点协调者（即AP）的中心控制权，实现无竞争服务。(可选)</li>
<li>DCF:没有中心控制设备，实现竞争服务。(强制)</li>
</ul>
<p>其中DCF是必备功能，而PCF由各WLAN设备硬件厂商来决定是否实现，实际上，几乎没有厂商使用PCF，通常都是采用DCF作为802.11无线通信的基础。</p>
<h4 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h4><p>DCF采用载波侦听多路访问冲突避免(CSMA/CA)的媒体存取方式,节点(STA)在发送数据前要先检测信道是否空闲，如果信道空闲则准备发送MAC业务数据单元(MSDU) 。如果2个STA同时检测到信道空闲并开始发送数据就会发生冲突，为此，802.11定义了冲突避免(CA)机制来降低发生冲突的概率。</p>
<p><strong>载波侦听多路访问</strong>（英语：Carrier Sense Multiple Access，缩写：CSMA）是一种介质访问控制（MAC）的协议。</p>
<ul>
<li><p><strong>载波侦听</strong>（Carrier Sense） 指任何连接到介质的设备在欲发送帧前，必须对介质进行侦听，当确认其空闲时，才可以发送。 </p>
<p>物理载波监听：实际信号检测<br>虚拟载波监听：帧的解析</p>
</li>
<li><p><strong>多路访问</strong>（Multiple Access） 指多个设备可以同时访问介质，一个设备发送的帧也可以被多个设备接收。</p>
</li>
</ul>
<p><strong>CD:collision deteced</strong>（冲突检测）<br><strong>CA:collision avoid</strong>（冲突避免）</p>
<blockquote>
<p>Ethernet采用CSMA/CD，而IEEE802.11采用CSMA/CA</p>
</blockquote>
<p>CSMA/CA过程见文章 <a href="https://zhuanlan.zhihu.com/p/20721272">DCF与CSMA/CA</a></p>
<h4 id="RTS-CTS"><a href="#RTS-CTS" class="headerlink" title="RTS/CTS"></a>RTS/CTS</h4><p>为解决CSMA方式引起的“隐藏节点”问题，802.11定义了请求发送/清除发送(RTS/CTS)机制。在传送数据帧以前STA先发送一个短RTS帧，接收方接收到RTS后立即发送一个CTS帧，RTS和CTS帧都包含了下一个数据帧的长度信息。因此STA附近的其他STA及接收数据的STA附近的“隐藏节点”通过设置网络分配向量 (NAV)定时器，在NAV规定的时间内不发送数据以避免数据冲突。RTS/CTS和NAV机制可以有效保护长数据 帧免受“隐藏节点”的碰撞。</p>
<h3 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h3><p>上述DCF操作中，由于各STA在发送数据前需要对信道进行争用，因此DCF无法对时延敏感的业务提供QoS保障。因此，802.11协议定义了点协调功能(PCF)来保证STA以一定的优先权接入到无线信道中。</p>
<p>STA的优先权由点协调器(PC)来协调，一般来说是AP。PCF发起数据传输的等待时间间隔称为PIFS，PIFS介于SIFS和DIFS之间，因而PCF比DCF的优先级高。PCF的传输时间被划分为重复的周期，即交替出现的竞争周期(CP)和非竞争周期(CFP)。</p>
<p>CP和随后的CFP一起组成超帧。在CFP阶段采用PCF机制接入无线信道，在CP阶段则使用DCF机制传输数据。超帧由信标帧(Beacon)开始。信标帧是一种管理帧，它维持STA内本地定时器的同步，并负责传送协议相关的参数。</p>
<p>PC周期性地产生信标帧，下一个信标帧到来的时间被称为目标信标帧传输时间(TBTT)，每个信标帧都携带该信息。每个STA被PC轮询后发送数据，因而不会发生冲突。PC通过发送CF-Poll帧轮询有数据要发送的STA，STA接收到轮询帧以后给出确认。若PC在等待了一个PIFS的时间后没有收到STA的响应，可以继续轮询其他的STA，一直到CFP的结束。PC通过发送一个特殊的控制帧CF-End来指示CFP的结束。</p>
<p>DCF与PCF的联系在于：它们都是IEEE802.11协议定义的接入方式，前者是在避免冲突前提下，确保各个移动终端可以公平接入信道，如果其中有一个终端占用信道，其它则处在监听状态，而后者则是保证STA以一定的优先权接入到无线信道中；它们可以在资源分配的不同阶段使用，即在CFP阶段使用PCF，在CP阶段使用DCF方式。</p>
<h2 id="802-11和802-3协议差异"><a href="#802-11和802-3协议差异" class="headerlink" title="802.11和802.3协议差异"></a>802.11和802.3协议差异</h2><p>在OSI七层模型中，802.2规定了数据链路层的LLC子层，802.3和802.11都处在物理层和数据链路层的MAC子层。</p>
<p>802.3定义了LAN的以太网实现方法，802.11定义了WLAN（Wireless Local Area Network，无线局域网）的以太网实现方法。</p>
<p>区别主要表现在</p>
<p><strong>MAC标准</strong></p>
<p>802.3定义了CAMA/CD规则，即载波监听多路访问/冲突检测(Carrier Sense Multiple Access with Collision Detection)，成为以太网通信的标准。</p>
<p>在802.11无线局域网协议中，冲突的检测存在一定的问题，这个问题称为”Near/Far”现象，这是由于要检测冲突，设备必须能够一边接受数据信号一边传送数据信号，而这在无线系统中是无法办到的。802.11对CSMA/CD的进行了修改，定义了适合无线传输的CAMA/CA（Carrier Sense Multiple Access with Collision Avoidance）标准。与802.3不同，CSMA/CA并不是采用冲突检测来判断数据是否需要重发，而是利用ACK信号来判断数据是否成功发送，也就是说，只有当客户端收到网络上返回的ACK信号后才确认送出的数据已经正确到达目的。如果冲突发生了，则数据就会出错，然后接收方就不会返回一个ACK信号，发送方于是启动重发机制。可见处理冲突导致的错误帧和其它原因导致的错误帧的处理方式是一样的，CSMA/CA本身不能判断冲突是否发生，而是一种尽可能避免冲突发生的机制。CSMA/CA的具体工作机制见“DCF和PC联系”该题。</p>
<p>CSMA/CA通过这种方式来提供无线的共享访问，这种显式的ACK机制在处理无线问题时非常有效。然而不管是对于802.11还是802.3来说，这种方式都增加了额外的负担，所以802.11网络和类似的Ethernet网比较总是在性能上稍逊一筹。另一个的无线MAC层问题是”hidden node”问题。两个相反的工作站利用一个中心接入点进行连接，这两个工作站都能够”听”到中心接入点的存在，而互相之间则可能由于障碍或者距离原因无法感知到对方的存在。为了解决这个问题，802.11在MAC层上引入了一个新的Send/Clear to Send(RTS/CTS)选项，当这个选项打开后，一个发送工作站传送一个RTS信号，随后等待访问接入点回送RTS信号，由于所有的网络中的工作站能够”听”到访问接入点发出的信号，所以CTS能够让他们停止传送数据，这样发送端就可以发送数据和接受ACK信号而不会造成数据的冲突，这就间接解决了”hidden node”问题。由于RTS/CTS需要占用网络资源而增加了额外的网络负担，一般只是在那些大数据报上采用(重传大数据报会耗费较大)。</p>
<p>最后，802.11MAC子层提供了另两个强壮的功能，CRC校验和包分片。在802.11协议中，每一个在无线网络中传输的数据报都被附加上了校验位以保证它在传送的时候没有出现错误，这和Ethernet中通过上层TCP/IP协议来对数据进行校验有所不同。包分片的功能允许大的数据报在传送的时候被分成较小的部分分批传送。这在网络十分拥挤或者存在干扰的情况下(大数据报在这种环境下传送非常容易遭到破坏)是一个非常有用的特性。这项技术大大减少了许多情况下数据报被重传的概率，从而提高了无线网络的整体性能。MAC子层负责将收到的被分片的大数据报进行重新组装，对于上层协议这个分片的过程是完全透明的。</p>
<p><strong>PHY标准</strong></p>
<p>802.3规定了10Base-2、10Base-T、10Base-FB、10Base-TX、10Base-FX等以太网标准。</p>
<p>802.11规定了跳频技术（FHSS：frequency-hopping spread-spectrum）、直接序列展频技术（DSSS：direct-sequence spread-spectrum）、红外线技术（IR：infrared PHY）等无线以太网标准，并采用BPSK和QPSK两种调制方式。</p>
<p><strong>体系结构</strong></p>
<p>802.11网络包含四个基本单元：无线站点STA（station），无线接入点AP（access point），独立基本服务组IBSS（independent basic service set），基本服务组BSS（basic service set），分布式系统DS（distribution system）和扩展服务组ESS（extended service set）。802.3以太网中没有分布式系统、接入点的概念，使用的是有线介质。</p>
<p><strong>帧结构</strong></p>
<p>802.11的MAC层帧结构比802.3复杂的多，它包含很多控制信息，如多址方式，信道共享模式以及网络结构和安全性等，同时地址字段一般有四个。</p>
<h2 id="802-11协议"><a href="#802-11协议" class="headerlink" title="802.11协议"></a>802.11协议</h2><h3 id="协议发展"><a href="#协议发展" class="headerlink" title="协议发展"></a>协议发展</h3><p>早在20世纪九十年代初，工作在900MHZ、2.4GHZ和5GHZ频率上的无线局域网就已经出现。但是由于价格、性能、通用性等种种原因，没有得到广泛的应用。1997年6月，第一个WLAN标准IEEE802.11正式颁布实施，为WLAN的物理层与MAC层制定了统一的标准，有力推动了该技术的发展。此后，又先后出台了802.11a、802.11b、802.11g等标准，使无线局域网的通信速率从2M提升到108M。随着无线网络技术的进一步发展，无线传输速率将不断高。</p>
<p><img src="%E5%8D%8F%E8%AE%AE%E5%8F%98%E5%8C%96.png" alt="image-20230921170606892"></p>
<h3 id="频段信道"><a href="#频段信道" class="headerlink" title="频段信道"></a>频段信道</h3><p>2.4G：2.4GHz-2.483GHz共83MHz的频段划分成13个信道，每个信道带宽22MHz。</p>
<p>5G：国内使用三个频段，共13个信道</p>
<ol>
<li>5.150GHz-5.250GHz</li>
<li>5.250GHz-5.350GHz</li>
<li>5.725GHz-5.850GHz</li>
</ol>
<p>5GHz信道中心频率与信道编号N的关系如下：</p>
<p>信道中心频率=5000+5×N(MHz)；(N=0, 1, …, 199)</p>
<p><img src="5G%E9%A2%91%E6%AE%B5%E4%BF%A1%E9%81%93.png" alt="image-20231115161034400"></p>
<h3 id="11n技术"><a href="#11n技术" class="headerlink" title="11n技术"></a>11n技术</h3><ul>
<li>AMSDU</li>
<li>BA</li>
<li>MCS速率表</li>
</ul>
<p><img src="MCS%E9%80%9F%E7%8E%87%E8%A1%A8.png" alt="image-20231115162609896"></p>
<h3 id="11ac技术"><a href="#11ac技术" class="headerlink" title="11ac技术"></a>11ac技术</h3><ul>
<li><p>频分复用（OFDMA）技术</p>
</li>
<li><p>上行MU-MIMO</p>
</li>
</ul>
<p>一条空间流的MCS速率表</p>
<p><img src="ac-MCS%E9%80%9F%E7%8E%87%E8%A1%A8-%E5%8D%95%E7%A9%BA%E9%97%B4%E6%B5%81.png" alt="image-20231115162814920"></p>
<h3 id="11be"><a href="#11be" class="headerlink" title="11be"></a>11be</h3><p>11be定义的物理层叫做EHT PHY</p>
<p>EHT PHY支持的频段为2.4G、5G、6G</p>
<table>
<thead>
<tr>
<th>2.4G·</th>
<th>5G</th>
<th>6G</th>
</tr>
</thead>
<tbody><tr>
<td>NON-HT</td>
<td>NON-HT</td>
<td>NON-HT</td>
</tr>
<tr>
<td>HT</td>
<td>HT</td>
<td></td>
</tr>
<tr>
<td></td>
<td>VHT</td>
<td></td>
</tr>
<tr>
<td>HE</td>
<td>HE</td>
<td>HE</td>
</tr>
<tr>
<td>EHT</td>
<td>EHT</td>
<td>EHT</td>
</tr>
</tbody></table>
<blockquote>
<p>6G频段范围为：5.925GHz ~ 7.125GHz</p>
</blockquote>
<h2 id="帧聚合"><a href="#帧聚合" class="headerlink" title="帧聚合"></a>帧聚合</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>无线Legacy Tx数据帧的原子操作如下</p>
<ul>
<li>竞争到信道，只能发送一个data帧</li>
<li>通过ACK帧来确认该data帧Tx成功</li>
</ul>
<p>MAC层 Tx 效率 = payload_time/(payload_time+overhead)</p>
<p>Payload time：MAC层报文Tx时间(速率变化，速率选择相关）</p>
<p>Overhead包括：</p>
<ul>
<li><p>DIFS、Random backoff以及碰撞开销、SIFS</p>
</li>
<li><p>PLCP Time</p>
</li>
<li><p>ACK Time（RTS/CTS）</p>
</li>
</ul>
<p>因此提高MAC层效率的措施有</p>
<p>数据突发（Burst）</p>
<p>即单次竞争到信道，此TXOP（Transmission Opportunity）时间内可以发送多个数据帧，减小DIFS、信道竞争、概率引入冲突造成的开销。</p>
<p>块确认和聚合</p>
<ul>
<li><p>将多个ACK帧组合成一个帧表示接收（Block ACK），减少ACK</p>
</li>
<li><p>多个数据帧组合成一个发送（聚合），减少SIFS</p>
</li>
</ul>
<h3 id="Block-Ack机制"><a href="#Block-Ack机制" class="headerlink" title="Block Ack机制"></a>Block Ack机制</h3><p>将多个ACK聚合到一个帧中发出，一次性表示多个数据帧接收情况的一种机制。</p>
<ul>
<li><p>减少ACK数量，提高信道的利用率</p>
</li>
<li><p>面向会话，以&lt;RA, TA, TID&gt;条目标识</p>
</li>
<li><p>发起端更灵活的发送QoS数据（用TID区分不同优先级报文）</p>
<p>对多个具有相同TID且分布在多个TXOP传输的MPDU，它们的Ack可以组合到一个BA（block ack）中</p>
<p>在不同的TXOP进行数据传输和确认</p>
</li>
</ul>
<p>Block Ack分为</p>
<p>Immediate Block Ack：在同一个TXOP内发起BAR和响应BA</p>
<p>Delayed Block Ack：在不同的TXOP内发起BAR和响应BA</p>
<p>Block Ack基本过程如下</p>
<p><img src="BA%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B.png" alt="alt text"></p>
<p><strong>setup</strong></p>
<p><strong>ADDBA Request/Response建立Block Ack</strong></p>
<ul>
<li><p>QoS Data才能BA，BA的协商是Per TID</p>
</li>
<li><p> 协商是由双向各自进行的，由Tx端发起</p>
</li>
<li><p>载体为Action管理帧，协商内容：</p>
<ul>
<li>ADDBA Request/Response通过Dialog Token字段配对</li>
<li>Originator决定要发送的第一个数据帧seqno（SSN）</li>
<li>协商BA window size、Block Ack的种类</li>
</ul>
</li>
<li><p>Status Code</p>
<ul>
<li>0表示Successful</li>
<li>1表示failed</li>
</ul>
</li>
</ul>
<p><strong>QoS data MPDU传输</strong></p>
<ul>
<li>Originator一个TXOP内容连续传输多个QoS data MPDU(Data Block)，MPDU有各自的SeqNo</li>
<li>SIFS间隔</li>
</ul>
<p><strong>Block Ack Request/Block Ack</strong></p>
<ul>
<li>Originator发送BAR请求，Recipient回复BA</li>
<li>BA的帧格式根据BAR的格式确定</li>
<li>Originator根据BA中Bitmap字段（对应MPDU的SeqNo）确定Recipient未收到的帧，并重新发送</li>
</ul>
<p><strong>DELBA Request拆除Block Ack（Tear Down）</strong></p>
<ul>
<li>载体为Action帧</li>
<li>由Originator或Recipient任意一方发起</li>
<li>单方向决定，无Response</li>
</ul>
<h3 id="帧聚合-1"><a href="#帧聚合-1" class="headerlink" title="帧聚合"></a>帧聚合</h3><p>帧聚合（Frame Aggregation）是802.11中为了提升传输效率的一种方式，自802.11n开始被引入。帧聚合是将多个无线帧组合成单个更长的无线帧传输，然后一次进行传输，以此来减少竞争开销，提高吞吐量，最终提高整体网络效率。</p>
<p>帧聚合分为A-MSDU和A-MPDU。</p>
<p>A-MSDU（Aggregate MAC Service Data Unit，聚合MAC服务数据单元）。 A-MSDU 聚合，将多个 MAC 级业务数据单元 （MSDU） 聚合到单个 MPDU 中。</p>
<p>A-MPDU(Aggregate MAC Protocol Data Unit ，聚合MAC协议数据单元)。 A-MPDU 聚合，将多个 MAC 级协议数据单元 （MPDU） 聚合到单个 PHY 协议数据单元 （PPDU） 中。</p>
<p>MSDU是Ethernet报文，本质是802.11数据帧的第3-7层有效载荷(即Payload)，一般MSDU的最大size是2304（不含加密信息部分）。</p>
<p>MPDU是MSDU经过添加完整性校验MIC、分帧、省电模式下报文缓存、加密、序列号赋值、CRC校验、MAC头之后成为MPDU，MPDU就是指的经过802.11协议封装过的数据帧。</p>
<p><img src="amsdu%E5%92%8Campdu%E5%AF%B9%E6%AF%94.png" alt="image-20231115164302072"></p>
<p><strong>A-MSDU</strong>：多个MSDU帧聚合为一个802.11帧中进行传输</p>
<ul>
<li>子帧的DA都是发往同一个RA和同一个TID</li>
<li>由ADDBA协商是否支持</li>
<li>HT Qos字段中标记是否为AMSDU</li>
</ul>
<p>单个MPDU传输多个MSDU帧。稀释MAC帧头开销，但所有MSDU只用一个FCS较验，一个MSDU错误，整个聚合帧全错；</p>
<p>4地址AMSDU报文</p>
<ul>
<li><p>A3/A4地址相同</p>
</li>
<li><p>不同子帧的SA/DA可能不同（ DA都是发往同一个RA和同TID即可 ）</p>
</li>
</ul>
<p><img src="amsdu1.png" alt="image-20231115164030382"></p>
<p><img src="amsdu.png" alt="image-20230928195323101"></p>
<p><strong>A-MPDU</strong>：多个MPDU帧聚合为一个无线帧中进行传输</p>
<ul>
<li>均为QOS数据</li>
<li>所有子帧的RA相同</li>
<li>属于同一TID</li>
</ul>
<p>单个PPDU传输多个MPDU帧。稀释前导、PHY帧头开销，每个MPDU帧都有各自的MAC层信息，加密和FCS是对MPDU子帧各自进行，单个子帧出现误码不影响其他子帧。</p>
<p><img src="ampdu.png" alt="image-20230928195417252"></p>
<h2 id="802-11网络"><a href="#802-11网络" class="headerlink" title="802.11网络"></a>802.11网络</h2><p>802.11定义了网络系统、系统中涉及的角色，规定了说话方式：</p>
<p><strong>Wi-Fi</strong>：Wireless-Fidelity的缩写，无线相容性认证</p>
<p><strong>WLAN</strong>：Wireless Local Area Network的缩写，无线局域网</p>
<p><strong>STA</strong>：站点（Station），802.11里一般指非AP设备。</p>
<p><strong>AP</strong>：接入点（Access Point），提供访问DS服务的设备。</p>
<p><strong>BSS</strong>：基础服务集（Basic Service Set），完成规定操作加入同一服务的逻辑集合，对应的标识称为BSSID。</p>
<p><strong>BSSID</strong>：每个BSS都会被赋予一个BSSID，它是一个长度为48位的二进制标识符，用来识别不同的BSS。在infrastructure BSS（基础结构型基本服务集）中，BSSID就是创建该BSS的接入点上无线接口（interface）的MAC地址。</p>
<p><strong>DS</strong>：分布式系统（Distribution System），用于将多个BSS和LAN组成一个扩展服务集。</p>
<p><strong>ESS</strong>：扩展服务集（Extended Service Set），由一个或多个相关BSS组成的服务集合，对STA来说，在链路控制层只表现为一个逻辑BSS。</p>
<p><img src="%E5%AE%B6%E5%BA%ADWIFI%E7%BD%91%E7%BB%9C.png" alt="image-20231115165139954"> <img src="802.11%E5%85%B8%E5%9E%8B%E7%BD%91%E7%BB%9C.png" alt="image-20231115165244239"></p>
<p><strong>802.11工作模式</strong></p>
<ul>
<li><p>ad hoc（对等）模式/IBSS（独立基本服务集）：</p>
<p>在ad hoc模式中，至少需要包含两个STA，每两个STA之间直接相连实现资源共享，不需要AP和分布式系统，由此构成的无线局域网也称为IBSS网络。</p>
</li>
<li><p>infrastructure（架构）模式：</p>
<p>在infrastructure模式中，各无线站点STA通过AP与现有的骨干网相连接，这种配置组成一个BSS。在BSS中，AP不仅提供STA之间通信的桥接功能，还提供STA与有线局域网的连接，以便无线用户访问有线网络上的设备或服务(如文件服务器、打印机、互联网链接等等)。多个BSS互相连接即组成一个ESS。ESS支持漫游功能（移动性），无线站点STA可以在ESS内不同的BSS之间漫游。分布式系统DS是用于BSS互联的逻辑组成单元，由它提供STA在BSS之间漫游的分配服务。</p>
</li>
</ul>
<h2 id="802-11帧类型"><a href="#802-11帧类型" class="headerlink" title="802.11帧类型"></a>802.11帧类型</h2><h3 id="管理帧"><a href="#管理帧" class="headerlink" title="管理帧"></a>管理帧</h3><p>负责链路层的各种维护功能(Beacon, Probe, Auth)</p>
<p><strong>管理帧的结构</strong></p>
<p><img src="%E7%AE%A1%E7%90%86%E5%B8%A7%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" alt="alt text"></p>
<p>地址字段</p>
<p>Fixed Fields:特定帧中长度和出现顺序都确定的</p>
<p>Information elements:可选的，长度可变的</p>
<h3 id="控制帧"><a href="#控制帧" class="headerlink" title="控制帧"></a>控制帧</h3><p>管理无线媒介的访问(RTS, CTS, … )</p>
<p>提供MAC层的可靠性(ACK, BA, PS-Poll, … )</p>
<h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><p>将上层协议的数据置于帧主体中加以传递(Data)</p>
<p>省电模式管理(NULL)</p>
<h4 id="WDS（Wireless-Distribution-System）"><a href="#WDS（Wireless-Distribution-System）" class="headerlink" title="WDS（Wireless Distribution System）"></a>WDS（Wireless Distribution System）</h4><p>WDS（Wireless Distribution System），即无线网络部署延展系统的简称，是指用多个无线网络相互联结的方式构成一个整体的无线网络。简单来说，WDS就是利用两个（或以上）无线宽带路由器/AP通过相互连接的方式将无线信号向更深远的范围延伸。WDS的作用主要是连接距离较远的有线网和扩展无线网络的范围。</p>
<p>STA通过控制无线帧头的字段中的两个标志位From/To DS位，以表示无线帧的来源与目的方向</p>
<table>
<thead>
<tr>
<th></th>
<th>To DS=0</th>
<th>To DS=1</th>
</tr>
</thead>
<tbody><tr>
<td><strong>From DS=0</strong></td>
<td>所有的管理帧和控制帧，以及IBSS网络中的数据帧。</td>
<td>Infra. BSS网络中无线STA传输的数据帧。</td>
</tr>
<tr>
<td><strong>From DS=1</strong></td>
<td>Infra. BSS网络中从无线STA接收到的数据帧。</td>
<td>无线网桥上的数据帧。</td>
</tr>
</tbody></table>
<p>在IEEE 802.11协议中定义的帧格式中，帧的控制域（Frame Control field）里面包含了ToDS和FromDS，不同的这些值表达的含义如下：</p>
<table>
<thead>
<tr>
<th><strong>To/From DS值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>To DS = 0, From DS = 0</td>
<td>在同一个独立的基本服务集合（IBSS）里面，一个数据帧（所有管理和控制类型的帧也是）直接从一个STA到另一个STA</td>
</tr>
<tr>
<td>To DS = 0, From DS = 1</td>
<td>数据帧离开DS</td>
</tr>
<tr>
<td>To DS = 1, From DS = 0</td>
<td>数据帧进入DS</td>
</tr>
<tr>
<td>To DS = 1, From DS = 1</td>
<td>无线分布式系统（WDS）帧正在从一个AP传到另一个AP</td>
</tr>
</tbody></table>
<p>地址字段在数据帧中的用法</p>
<table>
<thead>
<tr>
<th></th>
<th>To DS</th>
<th>From DS</th>
<th>Address1 (receiver 接收端)</th>
<th>Address2(sender 发送端)</th>
<th>address3</th>
<th>address4</th>
</tr>
</thead>
<tbody><tr>
<td>IBSS（独立基本服务集）</td>
<td>0</td>
<td>0</td>
<td>DA</td>
<td>SA</td>
<td>BSSID</td>
<td>未使用</td>
</tr>
<tr>
<td>To AP  (infra. 基础结构型)</td>
<td>1</td>
<td>0</td>
<td>BSSID</td>
<td>SA</td>
<td>DA</td>
<td>未使用</td>
</tr>
<tr>
<td>From AP  (infra. 基础结构型)</td>
<td>0</td>
<td>1</td>
<td>DA</td>
<td>BSSID</td>
<td>SA</td>
<td>未使用</td>
</tr>
<tr>
<td>WDS  (bridge 桥接器)</td>
<td>1</td>
<td>1</td>
<td>RA</td>
<td>TA</td>
<td>DA</td>
<td>SA</td>
</tr>
</tbody></table>
<p>其中一个无线芯片上（PHY），可以在软件层面虚拟出多个接入点（Virtual AP，即VAP），这些VAP共用无线PHY层相关参数，如信道、带宽等。而VAP根据模式的不同分为APVAP和STAVAP。</p>
<p>WDS桥接分为三地址桥接和四地址桥接</p>
<h2 id="认证关联过程"><a href="#认证关联过程" class="headerlink" title="认证关联过程"></a>认证关联过程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发布网络	        AP发布</span><br><span class="line">搜索网络	        主动搜索/被动搜索</span><br><span class="line">认证			AP、STA两者交互</span><br><span class="line">关联			AP、STA两者交互</span><br><span class="line">握手			WPA/WPA-PSK安全认证时使用</span><br><span class="line"></span><br><span class="line">STA		Probe Request 		AP</span><br><span class="line">		Probe Respond</span><br><span class="line">		Auth</span><br><span class="line">		Auth</span><br><span class="line">		Assoc Request</span><br><span class="line">		Assoc Respond</span><br></pre></td></tr></table></figure>

<p><strong>发布网络</strong></p>
<p>由AP完成。AP开启，选择合适信道，周期性发送Beacon帧，宣布网络存在。</p>
<p><strong>搜索网络</strong></p>
<ul>
<li>主动(Active Scanning)<br>发送Probe Request,等待Probe ResponseProbe Request的内容有两项――主机的SSID和支持的速率。其它STA或AP通过收到的探针请求帧的内容来判断是否允许该主机加入网络。</li>
<li>被动(Passive Scanning)<br>监听Beacon帧</li>
</ul>
<p>在Infrastructure networks中，Probe Request由STA发出，并由AP发回Probe Response。如果STA的SSID和支持的速率与网络所支持的兼容，则AP发回一个探针回复；否则就不发回复，也不会有后续的认证和连接。探针回复帧的内容包括网络中的基本信息参数，使STA能够使用合适参数来加入该网络。</p>
<p>可见，Probe（探针）是检测STA能否与它试图加入的网络兼容的一种手段。只有确定兼容了，才有可能建立连接。因此，作这种检测是建立连接的第一步，是必要的。</p>
<p><strong>认证过程</strong></p>
<p>由于无线网中没有物理介质上的限定，无线局域网中没有物理接入这一过程。无线网是通过“认证”服务来实现类似于有线网中的接入这一过程。</p>
<p>由于认证有两种模式（开放式系统认证和共享密钥认证），认证过程也不相同。</p>
<ul>
<li><p>开放系统认证</p>
<p>开放式系统认证是802.11默认的认证模式，使用明文传输。该模式下，STA先发送一个管理帧表明自己身份并向AP提出认证请求，AP随后返回一个确认帧。开放式系统认证模式下，任何STA都被认为是合法的，所以开放式系统认证实际上没有提供安全服务。</p>
<p>802.11帧中的Auth Algorithm字段为0（open system）</p>
</li>
<li><p>共享密钥认证</p>
<p>共享密钥认证需要经过四次交互，使用经WEP加密的密文传输。</p>
<p>a)  同开放式认证，STA先发送一个管理帧表明自己身份并向AP提出认证请求；</p>
<p>b)  AP做出响应并在响应帧中包含一个由WEP算法产生的随机“挑战信息”（challenge text）；</p>
<p>c)  STA对信息用共享密钥加密发回给AP；</p>
<p>d)  AP对加密结果用共享密钥进行解密，如果解密结果与挑战信息一致则认证成功，否则认证失败。</p>
<p>认证是提供一种合法接入，避免非法用户进入局域网的一种手段。只有通过认证的用户才能建立连接。</p>
<p>802.11帧中的Auth Algorithm字段为1（shared key）</p>
</li>
</ul>
<p><strong>关联过程</strong></p>
<p>“关联”服务使工作站（STA）找到给自己服务的AP。每台主机只拥有一个AP，而一个AP可以联合多台主机。一旦联合建立起来，主机便能通过AP充分利用DS进行通信。关联是由移动主机主动发起的而不是AP。</p>
<p>STA发起关联请求(Association Request)</p>
<p>AP回应关联应答(Association Response)</p>
<h3 id="以太帧-amp-无线帧"><a href="#以太帧-amp-无线帧" class="headerlink" title="以太帧&amp;无线帧"></a>以太帧&amp;无线帧</h3><p><img src="%E4%BB%A5%E5%A4%AA%E6%97%A0%E7%BA%BF%E5%B8%A7%E8%BD%AC%E6%8D%A2.png" alt="image-20230928194416280"></p>
<p><img src="psdu.png" alt="image-20230928195157956"></p>
<ul>
<li><p><strong>Sequence Control</strong>：帧序号，控制帧类型无此部分。</p>
</li>
<li><p><strong>QoS</strong> <strong>Control</strong>：802.11e协议新增，QoS（Quality of Service）数据帧携带，用于载荷数据的优先级控制。</p>
</li>
<li><p><strong>HT Control</strong>：802.11n协议新增，用于处理链路信息控制。</p>
</li>
<li><p><strong>Frame Body</strong>：帧载荷部分，长度从最小0字节到协议限定的最大允许值。</p>
</li>
<li><p><strong>FCS</strong>：帧校验（Frame Check Sum），覆盖MAC header、Frame Body的32-bit CRC校验。</p>
</li>
</ul>
<p>各层之间传输使用的服务数据</p>
<p><img src="msdu.png" alt="image-20230928194223798"></p>
<h2 id="无线吞吐量"><a href="#无线吞吐量" class="headerlink" title="无线吞吐量"></a>无线吞吐量</h2><h3 id="数据链路层效率"><a href="#数据链路层效率" class="headerlink" title="数据链路层效率"></a>数据链路层效率</h3><p>什么是 【<strong>信道利用率</strong>】与【<strong>空时</strong>】？</p>
<ul>
<li><p>信道利用率（Channel Utilization）是指信道非空闲时间所占的比例。</p>
<p>信道空闲是通过接收机进行检测的，其过程称为CS/CCA（Carrier Sense/Clear Channel Assessment），一共有两种机制同时进行检测：</p>
<ol>
<li>CCA-ED：即Energy-Detection CCA，通过检测信道能量强度进行判决——如果信道能量强度高于一定阈值，则认为是信道繁忙；</li>
<li>CCA-SD：即Signal-Detection CCA，通过对信号的自相关性进行检查来判别当前信号是否是802.11报文——如果通过自相关性检验，则认为是信道繁忙；</li>
</ol>
</li>
<li><p>空时（Airtime）是指报文在信道（空口）中占用的时长</p>
<p>受到报文长度、PHY速率等影响，空时会发生改变，通过无线抓包，可以对报文的空时进行统计分析，明确信道的分配情况。</p>
</li>
</ul>
<p>信道利用率受到什么影响？</p>
<ol>
<li>Self BSS（本BSS）的Tx/Rx空时；（My Tx/Rx）</li>
<li>Overlapping BSS（其他同信道BSS）的Tx/Rx空时；(OBSS Tx/Rx)</li>
<li>Self BSS在Tx/Rx时与OBSS同时Tx形成冲突所浪费的空时情况；（竞争冲突/隐藏节点）</li>
<li>各类干扰造成的空口占用；（Interference）</li>
</ol>
<h2 id="802-11安全"><a href="#802-11安全" class="headerlink" title="802.11安全"></a>802.11安全</h2><p>802.11为IEEE（电机电子工程师协会，The Institute of Electrical and Electronics Engineers）于1997年公告的无线区域网路标准，适用于有线站台与无线用户或无线用户之间的沟通连结。</p>
<p>涉及到无线连接会存在安全问题，主要有下面几个原因：</p>
<ol>
<li><p>信道开放，无法阻止攻击者窃听、恶意修改并转发。</p>
</li>
<li><p>传输媒质为无线电波，在空气中传播会因多种原因发生信号衰减，导致信息不稳定甚至丢失。</p>
</li>
<li><p>需常常移动设备（尤其是移动用户），设备易丢失或失窃。</p>
</li>
<li><p>用户不必与网络实际连接，使攻击者伪装合法用户更为容易。</p>
</li>
</ol>
<p>IEEE 802.11涉及到的概念有如下这些：</p>
<ol>
<li><p>认证。在被允许在无线网络中进行信息交换之前，无线节点必须先通过存取节点的认证，认证分为开放式系统认证和共享金钥认证两种，其过程前面已经论述，这里不再赘述。802.11协议中无线AP还能通过WLAN ESSID来判断是否提供服务。这种方法是在每个AP中都写入一个服务区域认证ID，无线客户端要连上AP时，AP要检查它的ESSID是否与自己的相同，如果不同则拒绝提供服务。</p>
</li>
<li><p>加密。在发送无线数据包之前，无线网络节点首先对数据进行加密（使用WEP方法）以确保数据的机密性。</p>
</li>
<li><p>数据完整。在发送无线数据包之前，无线网络节点需要在被加密部分加入一个完整性检验值ICV (integrity check value)，这样接收端就可以确定在传输过程中这个数据包的内容没有被修改。</p>
</li>
</ol>
<p>802.11安全性缺陷（802.1x草案详细描述了802.11的安全缺陷）：</p>
<ol>
<li><p>初始化向量（IV）太小。WEP使用的是24bit的IV,容易被解密。</p>
</li>
<li><p>完整性检查值（ICV）基于CRC-32多项式，ICV的已知数学漏洞可以改变加密帧和ICV，由于该漏洞，AP或客户机会将被更改过的帧接收为有效帧。</p>
</li>
<li><p>没有重发保护。攻击者可以通过发送一系列预先捕获的帧来尝试获得接入或者修改数据。</p>
</li>
<li><p>密钥一旦被设置，所有客户端、AP都直接使用这把密钥（都是同一把），而且没有提供一种更新密钥的方法，存在安全隐患。802.1x标准在分析802.11安全局限性的同时提出了一个密钥管理方案。</p>
</li>
</ol>
<p> 在认证方面，802.11不能提供基于用户的身份辨认及认证（per-user identification and authentication），没有中心（集中式）认证（central authentication）机制。</p>
<p> 其他安全措施</p>
<p>1、WI-FI保护接入(WPA)</p>
<p>WPA是Wi-Fi联盟签发的最新安全指南，它包括新兴802.11i标准提供的数据加密和网络访问控制机制，与当前的WEP标准增强了安全保护能力。在加密方面，WPA提供了临时密钥加密协议(TKIP)，它采用与WEP相同的加密算法，但以不同方式构建密钥。在访问控制方法，WPA采用IEEE 802.1x协议。</p>
<p>TKIP: 增强了加密，改善了入侵检测功能。仅WEP设备可以与采用WEP支持TKIP的设备互操作。</p>
<p>802.1x: 在设备和边缘网络设施之间提供了网络登录功能。它为实现各种认证方案提供了体系架构，通常调查服务器，简化认证。</p>
<p>2、802.11i</p>
<p>IEEE规范802.11i是实现更强大的加密和私密性的下一个标准化方法。它把改进的加密和认证结合在一起。它用两种加密方法代替较弱的WEP协议：TKIP和AES。TKIP是一种临时方法，它通过软件升级支持传统客户端和接入点。另一种方案基于AES，提供了更强大的安全保护能力。</p>
<p>802.11i的主要组成要素包括：</p>
<p>高级加密标准(AES): AES密钥长度可以配置成128位、192位或256位。</p>
<p>EAP: 提供集中认证和动态密钥分布的架构。它实现了无线客户端适配器，可以支持不同的认证类型，与不同的后端服务器通信，如远程认证拨入用户服务(RADIUS)。</p>
<p>强健安全网络(RSN): 动态协商接入点和无线客户端之间通信使用的认证和加密算法，这意味可以发现新的威胁，并可以增加新的算法。</p>
<p>802.11的安全建议：</p>
<p>改变默认的口令</p>
<p>安装最新的固化软件升级程序</p>
<p>为系统提供最强大的安全保护功能：WEP, WPA或802.11i (如果提供)</p>
<p>把SSID默认名称变成独特的名称</p>
<p>禁用SSID广播功能，在可能时使用MAC地址过滤功能</p>
<p>在可能时，使用基于IPSec的接入点或防火墙，其可以从最终用户到接入点建立VPN隧道</p>
<p>使用硬件防火墙，把WLAN与有线局域网隔开</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>802.11</tag>
      </tags>
  </entry>
  <entry>
    <title>编译链接原理</title>
    <url>/2026/01/18/C%E8%AF%AD%E8%A8%80/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.  前言"></a>1.  前言</h1><p>学过 C 语言同学，第一个接触的例子应该就是著名的 “hello world” 程序，即便时隔多年，也能行云流水般敲出以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用 GCC 一气呵成地编译链接出可执行文件，并运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -o <span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./test</span> </span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<p>看着屏幕输出我们想要的显示，开始难免会有一丝兴奋，原来这么简单就可以控制屏幕输出。但事实上真的有这么简单吗？<code>#include</code> 是做什么用的，<code>gcc</code> 在背后帮我们做了什么事情，<code>./test</code> 开始运行时背后又有什么故事。这就是本文的重点：编译、链接、装载。</p>
<p>实际上，一个 c 文件到最后运行，一般会经历以下过程，背后的故事，很长：</p>
<p><img src="c%E6%96%87%E4%BB%B6%E5%88%B0%E8%BF%90%E8%A1%8C.jpg" alt="img"></p>
<h1 id="2-预处理"><a href="#2-预处理" class="headerlink" title="2. 预处理"></a>2. 预处理</h1><p>预处理是将头文件进行展开，并进行相关的宏替换和处理，删除注释等，最后生成 .i 文件，使用命令 <code>gcc -E hello.c -o hello.i </code>可 以生成预处理文件 ，其后缀为<code>.i</code>，<code>.i </code>文件是一个可读文本，并不包含任何宏定义，预处理过程主要处理源代码内以 “<code>#</code>” 开始的编译指令，如 “<code>#include</code>” ， “<code>#define</code>”，它的主要处理规则如下：</p>
<ul>
<li>将所有 <code>#define</code> 删除，并展开所有宏定义。</li>
<li>处理所有条件编译指令，如 <code>#if</code> ， <code>#ifdef</code> ， <code>#elif</code> 等。</li>
<li>处理 <code>#include</code> 预编译指令，将被包含的文件插入到预编译指令的位置，这个过程是递归的，被包含的文件可能也包含其他文件。</li>
<li>删除所有注释。</li>
<li>添加行号和文件名标识，用于编译时编译器产生调试信息。</li>
<li>保留所有的 <code>#pragma</code> 编译器指令，因为编译器要用到他们。</li>
</ul>
<p>预处理阶段完成后，旧进入了程序的编译阶段。</p>
<h1 id="3-编译"><a href="#3-编译" class="headerlink" title="3.  编译"></a>3.  编译</h1><p>源代码是无法直接运行的，这是因为 CPU 能直接解析并运行的不是源代码而是本地代码程序，对于 CPU 来讲本地代码就是转换成机器语言的程序，而这种转换的程序称为编译器。编译器是和 CPU 类型相关的，因为编译器本身也是程序，所以也需要运行环境，比如有 windos 用的 c 编译器，还有 Linux 用的 c 编译器，此外还有一种交叉编译器，它生成的是和运行环境中的 CPU 不同的 CPU 所使用的本地代码，嵌入式开发一般使用的就是交叉编译器。（为什么要有交叉编译？原因在于程序的编译过程中会占用很大的内存和磁盘空间，且对 CPU 处理速度要求较高，而目标平台，如路由器根本不可能达到要求，所以一般进行嵌入式开发时，是先在 PC 主机上编译出目标代码，然后下载到板子上跑起来运行）</p>
<p>编译就是把完成预处理的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件，这个过程是程序构建的核心部分。使用命令 <code>gcc –S hello.i –s hello.s</code>  就将<code>.i</code> 文件翻译成汇编代码，并输出为<code>.s</code> 文件，此文件可读，由汇编代码和一些伪代码组成。</p>
<p>编译过程一般可以分为 6 步：扫描，语法分析，语义分析，源代码优化，代码生成和目标代码优化，整个过程见下图：</p>
<p><img src="%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%80%BB%E5%9B%BE.jpg" alt="img"></p>
<h2 id="3-1-编译过程"><a href="#3-1-编译过程" class="headerlink" title="3.1 编译过程"></a>3.1 编译过程</h2><p>以如下 C 代码为例 分析编译阶段的每一个过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Array [index] = (index + <span class="number">4</span>) * (<span class="number">2</span> + <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-1-1-词法分析"><a href="#3-1-1-词法分析" class="headerlink" title="3.1.1 词法分析"></a>3.1.1 词法分析</h3><p>首先源代码程序被输入到扫描器，它进行词法分析，将源代码的字符序列分割成一系列的记号，如下：</p>
<table>
<thead>
<tr>
<th>记号</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>标识符</td>
</tr>
<tr>
<td>[</td>
<td>左方括号</td>
</tr>
<tr>
<td>index</td>
<td>标识符</td>
</tr>
<tr>
<td>]</td>
<td>右方括号</td>
</tr>
<tr>
<td>=</td>
<td>赋值</td>
</tr>
<tr>
<td>(</td>
<td>左圆括号</td>
</tr>
<tr>
<td>index</td>
<td>标识符</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>4</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>右圆括号</td>
</tr>
<tr>
<td>*</td>
<td>乘号</td>
</tr>
<tr>
<td>(</td>
<td>左圆括号</td>
</tr>
<tr>
<td>2</td>
<td>数字</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>6</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>右圆括号</td>
</tr>
</tbody></table>
<h3 id="3-1-2-语法分析"><a href="#3-1-2-语法分析" class="headerlink" title="3.1.2 语法分析"></a>3.1.2 语法分析</h3><p>然后语法分析器将对扫描器产生的记号进行语法分析，从而产生语法树，如下图所示：</p>
<p><img src="%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90.jpg" alt="img"></p>
<p>从中可以看到整个语句被看作是一个赋值表达式，赋值表达式的左边是一个数组表达式，右边是一个乘法表达式，数组表达式又由两个符号表达式组成等。符号和数字是最小的表达式，他们不是由其他表达式来组成的，所以他们通常作为整个语法树的叶节点。</p>
<p>在语法分析过程的同时，很多运算符号的优先级和含义也被确定下来了，比如乘法表达式的优先级比加法高，而圆括号表达式的优先级比乘法高等等。如果出现表达式不合法，比如各种括号不匹配，表达式中缺少操作符等，编译器就会报告语法分析的错误。</p>
<h3 id="3-1-3-语义分析"><a href="#3-1-3-语义分析" class="headerlink" title="3.1.3 语义分析"></a>3.1.3 语义分析</h3><p>接下来进行语义分析，语法分析并不了解这个语句是否真正有意义，所以编译器要进行语义分析，这个过程由语义分析器完成。</p>
<p>编译器能够进行的只有静态语义分析，即可以在编译期间确定的语义，静态语义通常包含声明和类型的匹配，类型的转换，比如在将一个浮点型赋值给一个指针的时候，语义分析程序会发现类型不匹配，编译器将会报错。相对应的，动态语义分析一般指的是运行起出现的语义相关问题，比如将 <code>0</code> 作为除数是一个运行时的语义错误。</p>
<p>经过语义分析阶段后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序将会在语法数种插入相应的转换节点，如下图的语义树：</p>
<p><img src="%E8%AF%AD%E4%B9%89%E6%A0%91.jpg" alt="img"></p>
<p>可以看到语义分析还对符号表里的符号类型做了更新。</p>
<h3 id="3-1-4-中间代码生成"><a href="#3-1-4-中间代码生成" class="headerlink" title="3.1.4 中间代码生成"></a>3.1.4 中间代码生成</h3><p>现代编译器有着多层次的优化，往往在源代码级别会有一个优化过程，这个给过程是由源码级优化器。源码级优化器会在源代码级别进行优化，比如上述表达式中的（2 + 6）就可以被优化掉，因为它的值在编译期就可以确定，经过优化后的语法树如下为优化后的语法树：</p>
<p><img src="%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E8%AF%AD%E4%B9%89%E6%A0%91.jpg" alt="img"></p>
<p>可以看到 （2 + 6）的表达式被优化为 8。其实直接在语法树上进行优化比较困难，所以源代码优化器往往将整个语法树转换为中间代码，它是语法树的顺序表示，已经非常接近目标代码了。但是它一般跟目标机器和运行时环境是无关的，比如它不包含数据的尺寸，变量地址和寄存器的名字等，中间代码由很多形式，比较常见的有三地址码，我们上面的语法树被翻译为三地址码后的形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">t1 = <span class="number">2</span> + <span class="number">6</span></span><br><span class="line">t2 = index + <span class="number">4</span></span><br><span class="line">t3 = t2 * t1</span><br><span class="line"><span class="built_in">array</span> [index] = t3</span><br></pre></td></tr></table></figure>

<h3 id="3-1-5-目标代码的生成和优化"><a href="#3-1-5-目标代码的生成和优化" class="headerlink" title="3.1.5 目标代码的生成和优化"></a>3.1.5 目标代码的生成和优化</h3><p>代码生成器将中间代码转换为目标机器代码，这个过程依赖于目标机器，因为不同的机器拥有不同的字长，寄存器，整数数据类型等。对于上面的例子中的中间代码，代码生成器可能会生成如下代码序列，见下图目标机器（x86）代码：</p>
<p><img src="%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90.jpg" alt="img"></p>
<p>最后目标代码优化器对上述的目标代码进行优化，比如选择合适的寻址方式，使用位移来代替乘法运算，删除多余指令等。在上面的例子中，乘法由一条相对复杂的基址比例变址寻址的 <code>lea</code> 完成，随后由一条 <code>mov</code> 指令完成赋值操作，这条 <code>mov</code> 指令的寻址方式于 <code>lea</code> 是一样的，见下面的优化代码：</p>
<p><img src="%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81.jpg" alt="img"></p>
<p>经过以上步骤，最终生成了目标代码，为编译阶段的产物（一种 ELF 文件，ELF 文件的介绍会在第 5 章展开描述）。但是目标代码有个问题，index 和 array 的地址还没有确定，这其实是链接要做的事情，下面会继续分析。</p>
<h1 id="4-汇编"><a href="#4-汇编" class="headerlink" title="4.  汇编"></a>4.  汇编</h1><p>编译器将预处理文件转换为特定机器语言，但是对于 CPU 来讲，能处理的是自己的指令，所以还需要汇编器将汇编代码转换为特定机器指令。汇编器的作用是将汇编代码转变为机器可以执行的指令，每一个汇编语句几乎否对应一条机器指令。所以汇编器相对于编译器来讲比较简单，没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表翻译即可。</p>
<p>汇编器将汇编文件转换为可重定位目标文件（使用命令 <code>gcc –c hello.s –o hell.o</code>  或 或 <code>as hello.s –o hello.o</code>），即<code> .o</code> 文件，是一个不可读的二进制文件（是一种 ELF 文件），此文件可以使用 <code>objdump</code> 或 <code>readelf</code> 打开。这个过程会根据.s 文件中由编译器生成的符号构造一张符号表，内部包含符号表条目，用以链接使用，除此之外还会生成各个节。</p>
<h1 id="5-链接"><a href="#5-链接" class="headerlink" title="5.  链接"></a>5.  链接</h1><h2 id="5-1-链接的背景"><a href="#5-1-链接的背景" class="headerlink" title="5.1  链接的背景"></a>5.1  链接的背景</h2><p>在现代软件开发过程中，软件规模往往很大，如果都放在一个模块肯定无法想象，所以大型软件一般会拥有多个模块，这些模块之间相互依赖又相对独立。按照这种层次化和模块化存储组织源代码有很多好处，比如代码可读性较高，每个模块可单独开发，编译，测试，改变部分代码不需要编译整个程序等。</p>
<p>在一个程序被分割为多个模块后，这些模块如何组织形成一个单一的程序是必须解决的问题，模块之间如何组合的问题归结为模块之间如何通信的问题，最常见的是属于静态预言的 C/C++ 模块之间有两种通信方式，分别是函数调用和变量访问。函数访问必须知道目标函数的地址，变量访问也一样，所以这两种方式都可以归结为模块间的符号引用。</p>
<p>而链接的目的就是将模块组合成单一程序，并赋予这些符号地址，实现模块之间的通信，链接的最终产物是一个可执行文件（也是一种 ELF 文件）</p>
<h2 id="5-2-ELF-文件（Executable-Linkable-Format）"><a href="#5-2-ELF-文件（Executable-Linkable-Format）" class="headerlink" title="5.2  ELF 文件（Executable Linkable Format）"></a>5.2  ELF 文件（Executable Linkable Format）</h2><p>上面提到汇编和链接过程的产物是一种 ELF 文件，那么下面介绍一下 ELF 文件。</p>
<p>ELF 是一种文件格式，是 Linux 上默认的目标文件格式，ELF 文件可以分为以下几种，分别是：</p>
<ul>
<li>可重定位目标文件：包含了代码段和数据，可与其他 ELF 文件进行合并，创建一个可执行目标文件或共享目标文件，如 Linux 下的<code>.o</code> 文件，静态库也是这一类文件。</li>
<li>可执行目标文件：包含二进制代码和数据，可以被加载器加载执行，链接的最终产物就是一个可执行目标文件。</li>
<li>共享目标文件 ( <code>.so</code>)，在链接过程和运行过程两个阶段都需要被使用到：链接过程中，编译器将其他 Relocatable Object File 与存在调用关系的 Shared Object File 进行链接处理后，输出 Executable File；运行过程中，动态链接器处理加载后的 Executable file 查找其依赖的 Shared Object File，进行加载处理，创建整个进程的运行实例。</li>
<li>核心转储文件（<code>core</code> 文件），当程序崩溃时，会在核心文件中记录整个进程的镜像信息。</li>
</ul>
<p>ELF 文件格式提供了两种视图，分别是链接视图和执行视图：</p>
<p><img src="ELF%E9%93%BE%E6%8E%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E8%A7%86%E5%9B%BE.png" alt="img"></p>
<p>链接视图是以节（section）为单位，执行视图是以段（segment）为单位。接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。</p>
<p>目标文件<code>.o</code> 里的代码段 <code>.text</code> 是 section（汇编中.text 同理），当多个可重定向文件最终要整合成一个可执行的文件的时候（链接过程），链接器把目标文件中相同的 section 整合成一个 segment，在程序运行的时候，方便加载器的加载。</p>
<p>ELF 文件主要包含三个 header，描述文件格式构成。</p>
<h4 id="5-2-1-ELF-Header"><a href="#5-2-1-ELF-Header" class="headerlink" title="5.2.1 ELF Header"></a>5.2.1 ELF Header</h4><p>使用命令  <strong>readelf -h</strong> 可以查看一个 ELF 文件的 ELF Header 信息。</p>
<p><img src="ELF_Header%E5%AE%9E%E4%BE%8B.png" alt="img"></p>
<p>比较重要的成员有：<code>e_ident</code>（ELF 文件幻数）、<code>e_machine</code>（比如可执行文件 ET_EXEC）、<code>e_entry</code>（程序入口虚拟地址）等等。</p>
<p>ELF 头部定义如以下结构体所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /include/uapi/linux/elf.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_hdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span>	e_ident [EI_NIDENT];	<span class="comment">/* Magic number and other info */</span></span><br><span class="line">      Elf32_Half	e_type;			<span class="comment">/* Object file type */</span></span><br><span class="line">      Elf32_Half	e_machine;		<span class="comment">/* Architecture */</span></span><br><span class="line">      Elf32_Word	e_version;		<span class="comment">/* Object file version */</span></span><br><span class="line">      Elf32_Addr	e_entry;		<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">      Elf32_Off	e_phoff;		    <span class="comment">/* Program header table file offset */</span></span><br><span class="line">      Elf32_Off	e_shoff;		    <span class="comment">/* Section header table file offset */</span></span><br><span class="line">      Elf32_Word	e_flags;		<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">      Elf32_Half	e_ehsize;		<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">      Elf32_Half	e_phentsize;	<span class="comment">/* Program header table entry size */</span></span><br><span class="line">      Elf32_Half	e_phnum;		<span class="comment">/* Program header table entry count */</span></span><br><span class="line">      Elf32_Half	e_shentsize;	<span class="comment">/* Section header table entry size */</span></span><br><span class="line">      Elf32_Half	e_shnum;		<span class="comment">/* Section header table entry count */</span></span><br><span class="line">      Elf32_Half	e_shstrndx;		<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>

<p>简单归纳各字段</p>
<pre><code>elf header:
    magic num、version、arch、endian、flag、elf header size
    elf type: EXEC (Executable file)、REL (Relocatable file)、DYN (Shared object file)
    entry point: EXEC 文件才有，程序入口虚拟地址
    program hdr offset/size/num in file:
    section hdr offset/size/num in file:
    str table of section hdr idx:
</code></pre>
<h4 id="5-2-2-Section-Header"><a href="#5-2-2-Section-Header" class="headerlink" title="5.2.2 Section Header"></a>5.2.2 Section Header</h4><p>使用命令  <strong>readelf -S</strong> 可以查看一个 ELF 文件的 Section Header 信息。</p>
<p>![img](Section Header实例png.png)</p>
<p>一个 ELF 文件中到底有哪些具体的 sections，由包含在这个 ELF 文件中的 section head table (SHT) 决定。每个 section 描述了这个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其它属性。</p>
<p>下面介绍下常见和比较重要的 section：</p>
<table>
<thead>
<tr>
<th>sh_name</th>
<th>sh_type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>.text</td>
<td>SHT_PROGBITS</td>
<td>代码段，包含程序的可执行指令</td>
</tr>
<tr>
<td>.data</td>
<td>SHT_PROGBITS</td>
<td>包含初始化了的数据，将出现在程序的内存映像中</td>
</tr>
<tr>
<td>.bss</td>
<td>SHT_NOBITS</td>
<td>未初始化数据，因为只有符号所以</td>
</tr>
<tr>
<td>.rodata</td>
<td>SHT_PROGBITS</td>
<td>包含只读数据</td>
</tr>
<tr>
<td>.comment</td>
<td>SHT_PROGBITS</td>
<td>包含版本控制信息</td>
</tr>
<tr>
<td>.eh_frame</td>
<td>SHT_PROGBITS</td>
<td>它生成描述如何 unwind 堆栈的表</td>
</tr>
<tr>
<td>.debug</td>
<td>SHT_PROGBITS</td>
<td>此节区包含用于符号调试的信息</td>
</tr>
<tr>
<td>.dynsym</td>
<td>SHT_DYNSYM</td>
<td>此节区包含了动态链接符号表</td>
</tr>
<tr>
<td>.shstrtab</td>
<td>SHT_STRTAB</td>
<td>存放 section 名，字符串表。Section Header String Table</td>
</tr>
<tr>
<td>.strtab</td>
<td>SHT_STRTAB</td>
<td>字符串表</td>
</tr>
<tr>
<td>.symtab</td>
<td>SHT_SYMTAB</td>
<td>符号表</td>
</tr>
<tr>
<td>.got</td>
<td>SHT_PROGBITS</td>
<td>全局偏移表</td>
</tr>
<tr>
<td>.plt</td>
<td>SHT_PROGBITS</td>
<td>过程链接表</td>
</tr>
<tr>
<td>.relname</td>
<td>SHT_REL</td>
<td>包含了重定位信息，例如 .text 节区的重定位节区名字将是：.rel.text</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Section 头部定义如以下结构体所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /include/uapi/linux/elf.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_shdr</span> &#123;</span></span><br><span class="line">        Elf32_Word sh_name;     <span class="comment">// 节区名，名字是一个 NULL 结尾的字符串。</span></span><br><span class="line">        Elf32_Word sh_type;     <span class="comment">// 为节区类型</span></span><br><span class="line">        Elf32_Word sh_flags;    <span class="comment">// 节区标志</span></span><br><span class="line">        Elf32_Addr sh_addr;     <span class="comment">// 节区的第一个字节应处的位置。否则，此字段为 0。</span></span><br><span class="line">        Elf32_Off sh_offset;    <span class="comment">// 此成员的取值给出节区的第一个字节与文件头之间的偏移。</span></span><br><span class="line">        Elf32_Word sh_size;     <span class="comment">// 此成员给出节区的长度（字节数）。</span></span><br><span class="line">        Elf32_Word sh_link;     <span class="comment">// 此成员给出节区头部表索引链接。其具体的解释依赖于节区类型。</span></span><br><span class="line">        Elf32_Word sh_info;     <span class="comment">// 此成员给出附加信息，其解释依赖于节区类型。</span></span><br><span class="line">        Elf32_Word sh_addralign;    <span class="comment">// 某些节区带有地址对齐约束.</span></span><br><span class="line">        Elf32_Word sh_entsize;      <span class="comment">// 给出每个表项的长度字节数。</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>

<p>简单归纳各字段</p>
<pre><code>section header: （用于 link 的 elf 必须有，其他文件不是必要的）
    name（string tbl index）、offset、size、addr
    type:
        PROGBITS
        REL：重定位，如.rel.text
        NOBITS：
        STRTAB：字符串表，格式为 str1 \0 str2 \0 ... (其他使用该 str 时不需要记录 size)
        SYMTAB：格式
        
    flag: write、alloc、execute、merge、strings、info、exclude、group
    
    .rel.text：
         Offset     Info    Type            Sym.Value  Sym. Name
        00000038  00000e04 R_MIPS_26         00000000   b_func_1

    .symtab：
    val：取决 type，可能是地址（相对所在 section 的 offset）
    type 有 SECTION  OBJECT（变量） FUNC  NOTYPE（外部 sym） FILE（文件名 a.c）
    Ndx: ABS (文件名)  UND（外部 sym）其他为所在 section index
    Bind：LOCAL   GLOBAL（外部可见）
    例子：
        Num:    Value  Size Type    Bind   Vis      Ndx Name
        13: 00000000   200 FUNC    GLOBAL DEFAULT    1 a_func_1
        14: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND b_func_1
</code></pre>
<h4 id="5-3-3-Program-Header"><a href="#5-3-3-Program-Header" class="headerlink" title="5.3.3 Program Header"></a>5.3.3 Program Header</h4><p>使用命令  <strong>readelf -l</strong> 可以查看一个 ELF 文件的 Program Header 信息。</p>
<p><img src="ProgramHeader%E5%AE%9E%E4%BE%8B.png" alt="img"></p>
<p>程序头是一个结构的数组，每一个结构都表示一个段 (segments)。在可执行文件或者共享链接库中所有的节 (sections) 都被分为不同的几个段 (segments)。</p>
<p>程序头的索引地址 (e_phoff)、段数量 (e_phnum)、表项大小 (e_phentsize) 都是通过 ELF 头部信息获取的。</p>
<p>Program 头部定义如以下结构体所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /include/uapi/linux/elf.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_phdr</span> &#123;</span></span><br><span class="line">      Elf32_Word	p_type;    <span class="comment">/* Magic number and other info */</span></span><br><span class="line">      Elf32_Off	p_offset;</span><br><span class="line">      Elf32_Addr	p_vaddr;</span><br><span class="line">      Elf32_Addr	p_paddr;</span><br><span class="line">      Elf32_Word	p_filesz;</span><br><span class="line">      Elf32_Word	p_memsz;</span><br><span class="line">      Elf32_Word	p_flags;</span><br><span class="line">      Elf32_Word	p_align;</span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>

<p>简单归纳各字段</p>
<pre><code>Program Headers:（用于进程 img 加载，其他文件不是必要的）
    例子：
      Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
      REGINFO        0x000094 0x00400094 0x00400094 0x00018 0x00018 R   0x4
      LOAD           0x000000 0x00400000 0x00400000 0x003a0 0x003a0 R E 0x10000
      LOAD           0x0003a0 0x004103a0 0x004103a0 0x00020 0x00050 RW  0x10000

     Section to Segment mapping:
      Segment Sections...
       00     .reginfo
       01     .reginfo .text
       02     .data .sbss .bss
</code></pre>
<p>从加载的角度来看，ELF 文件被分成了许多段，ELF 文件中的代码，链接信息和注释都以段的形式存访。每个段在程序表头表中有一个描述项，分别包含段的类型，段的驻留位置相对于 ELF 文件开始处的偏移量，段在内存中的首地址，段的物理地址，段在文件中的大小，段在内存中的大小，段的对齐标志，如上图所示。</p>
<p>一个可执行文件至少要有一个可加载类型的段，这种类型的段会被装载或映射进内存中，这个会在后面分析程序加载流程时会描述到。</p>
<h2 id="5-3-符号和符号表"><a href="#5-3-符号和符号表" class="headerlink" title="5.3  符号和符号表"></a>5.3  符号和符号表</h2><h3 id="5-3-1-符号"><a href="#5-3-1-符号" class="headerlink" title="5.3.1  符号"></a>5.3.1  符号</h3><p>符号就是程序中的函数和变量，函数名或变量名就是符号名。每个 ELF 文件都有一个符号表，它包含了在此文件中定义和引用的符号，符号类型可以分为以下三类：</p>
<p>l Global symbols 即全局符号，是由当前文件定义并能被其他模块引用的符号；</p>
<p>l External symbols 即外部定义的全局符号，是由其他模块定义并被当前文件所引用的全局符号；</p>
<p>l Local symbols 即本模块的局部符号，仅由本模块定义的带有 static 的 C 函数和全局变量。</p>
<p>在编译器的代码里面。用下面结构体来描述一个符号，见下图</p>
<p><img src="%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="img"></p>
<h3 id="5-3-2-符号表"><a href="#5-3-2-符号表" class="headerlink" title="5.3.2  符号表"></a>5.3.2  符号表</h3><p>ELF 文件中的.symtab 节记录着符号表的信息，用 <code>readelf –s hello.o</code> 可以看到符号表的内容，当前 <code>hello.o </code>内的符号表信息如下图：</p>
<p><img src="hello%E7%9A%84%E7%AC%A6%E5%8F%B7%E8%A1%A8%E4%BF%A1%E6%81%AF.jpg" alt="img"></p>
<p>从上面的符号表信息中可以看到，当前有 10 个符号，其中符号 main 是 <code>hello.o</code> 内第 1 节（.text）偏移量为 0 的一个全局符号，占 21 字节，type 类型为 Func，其他的以此类推，上图中，ABS 表示不该被重定位，UND 表示未定义的含义。<code>hello.o</code> 中的节的信息如下：</p>
<p><img src="hello%E7%9A%84section%E4%BF%A1%E6%81%AF.jpg" alt="img"></p>
<h3 id="5-3-3-C-符号问题"><a href="#5-3-3-C-符号问题" class="headerlink" title="5.3.3 C++ 符号问题"></a>5.3.3 C++ 符号问题</h3><p>C++ 允许不同参数类型的函数拥有一样的函数名，这就是所谓的重载，那么 C++ 是如何来处理函数重载这一情况的呢？</p>
<p>答案是函数签名，函数签名包含了一个函数的信息，包括函数名，参数类型和名称空间及其他信息。函数签名用于识别不同的函数。在编译器及链接器处理符号时，他们使用某种名称修饰的方法，使得每个函数对应一个修饰后名称，以此来使得编译器和链接器都认为这些重载函数是不同的函数。</p>
<p>以 GCC 的修饰方法为例，当 GCC 按照一定的规则（不具体展开，不同编译器对名称的修饰方法可能不同）完成对 C++ 名称的修饰之后，就形成了对应的修饰名称。举例如下，下面是一段 C++ 代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span> <span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">func</span> <span class="params">(<span class="type">float</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span> (a);</span><br><span class="line">    <span class="built_in">func</span> (b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后查看符号表可以得到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ test.cpp -g -o <span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nm <span class="built_in">test</span> | grep func</span>    </span><br><span class="line">0000000000400945 t _GLOBAL__sub_I__Z4funci</span><br><span class="line">0000000000400896 T _Z4funcf</span><br><span class="line">000000000040086d T _Z4funci</span><br></pre></td></tr></table></figure>

<p>可以看到被修饰后的符号名称为 _Z4funcf 和 _Z4funci ，使用 c++filter 就可以解析对 func 修饰后的名称，解析结果为 func (int) ，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt  _Z4funcf</span>      </span><br><span class="line">func (float)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt  _Z4funci</span></span><br><span class="line">func (int)</span><br></pre></td></tr></table></figure>

<h2 id="5-4-链接脚本"><a href="#5-4-链接脚本" class="headerlink" title="5.4 链接脚本"></a>5.4 链接脚本</h2><p>每一个链接过程都由链接脚本 (linker script，一般以 lds 作为文件的后缀名) 控制。 链接脚本主要用于规定如何把输入文件内的 section 放入输出文件内，并控制输出文件内容各部分在程序地址空间内布局。链接器有个默认的内置链接脚本，可以使用 <code>ld -verbose</code> 查看。ld 链接选项 <code>-r</code> 和 <code>-N</code> 可以影响默认的链接脚本，-T 选项用以指定特定的链接脚本，它将代替默认的链接脚本。也可以使用暗含的链接脚本以增加自定义的链接命令。</p>
<h3 id="5-4-1-链接脚本举例分析"><a href="#5-4-1-链接脚本举例分析" class="headerlink" title="5.4.1  链接脚本举例分析"></a>5.4.1  链接脚本举例分析</h3><p>内核镜像的第一个名称为 vmlinux ，vmlinux 是通过源码编译，汇编，链接而成的 ELF 文件，因此这个文件包含了 ELF 文件应有的属性及各种调试信息（这个阶段的 vmlinux 特别大，不能直接在目标机器上运行，因此要进一步压缩），内核目录<code> /arch/arm/kerner/vmlinux.lds.S</code> 会在编译阶段根据宏定义和传入的参数构建出针对特定平台和架构的 <code>vmlinux.lds</code> 链接脚本，由此链接脚本来指导 <code>vmlinux</code> 的生成，下面我们分段来分析此 <code>vmlinux.lds.S</code> 的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH (arm)</span><br><span class="line">ENTRY (stext)</span><br></pre></td></tr></table></figure>

<p>这段脚本的含义是指定链输出文件的指令架构为 ARM，且入口函数为 <code>stext</code>，此函数可以在符号表内找到。在这里 <code>OUTPUT_ARCH</code> 用来指定输出架构，使用 <code>objdump –f vmlinux</code> 可以看出目标文件的体系架构；而 ENTRY 用来设置入口点，其参数为符号名称，有几种设置入口点的方法，如下：</p>
<p><img src="%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95.jpg" alt="img"></p>
<p>链接器会尝试上述几种方法来设置入口点，直到成功。</p>
<p>接下来进入 <code>SECTIONS</code> 命令，它告诉链接器如何将输入段映射到输出段，以及将如何将输出段放到内存中，其命令格式为：</p>
<p><img src="sections%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F.jpg" alt="img"></p>
<p>每个 sections-command 可能为：ENTRY 命令，符号赋值，输出段的描述等。一个输出段的完整描述如下图:</p>
<p><img src="%E8%BE%93%E5%87%BA%E6%AE%B5%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8F%8F%E8%BF%B0.jpg" alt="img"></p>
<p>其中，大部分属性在输出段中并不需要，我们会在下面的分析中看到，其中 section 后面必须跟一个空格，这样段名就没有歧义，另外，冒号和花括号是必须的。</p>
<p><img src="section%E5%90%8E%E9%9D%A2%E5%AF%B9%E7%A9%BA%E6%A0%BC%E7%9A%84%E8%A6%81%E6%B1%82.jpg" alt="img"></p>
<p>下面开始定义目标文件中的各个 section，首先对 “.” 进行赋值，它叫做位置计数器，对应内存里的一个虚拟地址，若不显式的为其赋值，则在每增加一个 <code>section</code> 后对其会自增。（可以看到当前内核的起始地址为 <code>PAGE_OFFSET</code>，它的值由内核宏定义控制，而 <code>TEXT_OFFSET</code> 为内核镜像加载的偏移量，中间预留的一部分内存用来做页表使用。）对 “.” 赋值后，开始对此位置的 <code>section</code> 进行描述。</p>
<p>第一个 section 为 .head.text ，在此 section 中对 <code>_text</code> 进行赋值，其中 <code>HEAD_TEXT</code> 为宏定义，它展开为 *(<code>.head.text</code>) ，即将所有的目标文件中的 .head.text 加载到此段。</p>
<p><img src="head.text%E4%B8%BE%E4%BE%8B.jpg" alt="img"></p>
<p>接下来加载 <code>.text</code> 段，用 <code>_stext</code> 和<code> _etext</code> 两个变量来记录 <code>.text</code> 的起始位置和结束位置， 他们可以在代码内进行访问，<code>ARM_TEXT</code> 为宏定义，展开后指向所有目标文件中与代码段相关的段，其中 <code>ALIGN</code> 的作用是将地址按指定字节进行对齐。</p>
<p><img src="text%E6%AE%B5%E4%B8%BE%E4%BE%8B.jpg" alt="img"></p>
<p>接下来加载 <code>_ex_tables</code> 段，其加载地址是按 4 字节进行对齐，用变量 <code>__start_ex_table</code> 和 <code>__stop_ex_table</code>来记录其齐时地址和结束地址，这块可以看到有个 <code>unwind</code> 段，此段是用来进行栈回溯的。</p>
<p><img src="ex_tables%E6%AE%B5%E4%B8%BE%E4%BE%8B.jpg" alt="img"></p>
<p>然后加载 init 段，从 __init_begin 开始到 __init_end 结束，在 Linux 初始化完成后，这个段内的内存会被清空释放，只需要在初始化时使用以此，没有必要再驻留再内存中。</p>
<p><img src="init%E6%AE%B5%E4%B8%BE%E4%BE%8B.jpg" alt="img"></p>
<p>进一步加载.data 段，即已经初始化的内核数据段，用 _sdata 和 _edata 来记录 .data 段的起始地址和结束地址。</p>
<p><img src="data%E6%AE%B5%E4%B8%BE%E4%BE%8B.jpg" alt="img"></p>
<p>加载 bss 段，即未初始化的内核数据段，<code>.end</code> 记录加载结束位置。</p>
<p>上面的汇编脚本经过编译后生成真正的链接脚本 <code>vmlinux.lds </code>，由其指导目标文件的链接，此链接脚本就是针对于特定平台而生成的，我们看一下最终生成 vmlinux 文件的各个段的排列如下图所示：</p>
<p><img src="vmlinux%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%84%E4%B8%AA%E6%AE%B5%E7%9A%84%E6%8E%92%E5%88%97.jpg" alt="img"></p>
<p>可以看到目标文件的布局是严格按照链接脚本生成的。</p>
<h2 id="5-5-链接的过程"><a href="#5-5-链接的过程" class="headerlink" title="5.5 链接的过程"></a>5.5 链接的过程</h2><p>上面讲过链接的过程就是把各个模块之间相互引用部分处理好，使得各个模块之间能够正确的衔接，最终形成可执行目标文件。链接的基本过程包含了两个步骤，分别是空间与地址分配，符号解析和重定位。</p>
<h3 id="5-5-1-空间与地址分配"><a href="#5-5-1-空间与地址分配" class="headerlink" title="5.5.1  空间与地址分配"></a>5.5.1  空间与地址分配</h3><p>空间与地址分配的主要过程是扫描所有的输入目标文件，获得他们的各个段的长度，属性和位置，将输入目标文件中的符号表与所有的符号定义和符号引用收集起来，统一放到一个全局符号表，计算出各个段合并后的长度和位置，建立映射关系。</p>
<p>经过这一步后，每个符号都有了对应的虚拟地址。</p>
<h3 id="5-5-2-符号解析"><a href="#5-5-2-符号解析" class="headerlink" title="5.5.2  符号解析"></a>5.5.2  符号解析</h3><p>符号解析就是将符号的引用和符号的定义建立关联，这个过程中链接器会查找所有输入目标文件的符号表组成的全局符号表，查找函数或变量是否有对应的定义，如果没有则抛出错误终止链接。具体是怎么做的呢？首先将定义三个集合 E（可重定位目标文件集合）, U（未解析符号集合）, D（已定义符号集合），然后对于每一个输入的目标文件，将其添加进 E 中，并更新 U 和 D 反映当前文件的符号定义和引用情况，不断重复此过程，直到 U 和 D 不再发生变化，如果链接器扫描完所有输入文件后，发现 U 是非空的，那么链接器会输出一个错误并终止，否则进行对 E 中目标文件进行合并，构建可执行目标文件。</p>
<h3 id="5-5-3-重定位"><a href="#5-5-3-重定位" class="headerlink" title="5.5.3  重定位"></a>5.5.3  重定位</h3><p>重定位就是在符号解析过程中将可执行文件中的符号引用处的地址修改为重定位后的地址。比如在 <code>hello.o</code> 文件内查看 main 的符号定义，其虚拟地址为 0，如下：</p>
<p><img src="main%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89.jpg" alt="img"></p>
<p>而在 hello 中可以看到 main 的地址见下</p>
<p><img src="hello%E4%B8%ADmain%E7%9A%84%E5%9C%B0%E5%9D%80.jpg" alt="img"></p>
<p>重定位完成后，最后生成的可执行目标文件中就不需要可重定位的条目，使用 readelf -r hello 可以看到，另外可以使用 objdum –h 命令，查看重定位后的各段的虚拟地址，如在 hello.o 中 ，.data 的地址为 0，因为还没有进行重定位，无法加载进内存运行，重定位后的结果见下图</p>
<p><img src="%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%90%8E%E5%9C%B0%E5%9D%80.jpg" alt="img"></p>
<p>根据链接发生时机，将链接分为静态链接和动态链接，下面分别描述。</p>
<h2 id="5-6-静态链接"><a href="#5-6-静态链接" class="headerlink" title="5.6 静态链接"></a>5.6 静态链接</h2><p>静态链接的核心内容就是将多个目标文件的相同段合并形成一个可执行文件，以 a.c 和 b.c 文件的链接过程为例，是在程序被加载进内存前。下面以一个例子来分析静态链接的过程。</p>
<h3 id="5-6-1-静态链接过程"><a href="#5-6-1-静态链接过程" class="headerlink" title="5.6.1  静态链接过程"></a>5.6.1  静态链接过程</h3><p>给出两个文件，a.c 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    swap (&amp;a, &amp;shared);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.c 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int shared = 1;</span><br><span class="line"></span><br><span class="line">void swap (int *a, int *b)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a.c 种引用了 b.c 文件种的 share 变量和函数，对上述两个使用命令 gcc -c a.c b.c 编译生成 a.o 和 b.o ，查看 a.o 内的符号表:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c a.c b.c </span><br><span class="line">$ readelf -s a.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 11 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     8: 0000000000000000    44 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND shared</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND swap</span><br></pre></td></tr></table></figure>

<p>可以看到 a.o 中引用的两个符号 shared、swap 是未定义的（UND），下面看一下 b.o 的符号表，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf -s b.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 10 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     8: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    2 shared</span><br><span class="line">     9: 0000000000000000    44 FUNC    GLOBAL DEFAULT    1 swap</span><br></pre></td></tr></table></figure>

<p>可以看到变量和函数名是存在的，不是未定义的，下面使用命令 ld a.o b.o -e main -o ab ，把两个目标文件合成一个可执行文件，其中 –e 是指定程序入口是 main 函数，-o 是表示链接后的文件名，看一下 ab 的符号表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ld a.o b.o -e main -o ab  </span><br><span class="line">$ readelf -s ab</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 14 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 00000000004000e8     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     2: 0000000000400140     0 SECTION LOCAL  DEFAULT    2 </span><br><span class="line">     3: 0000000000600198     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     6: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     7: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS </span><br><span class="line">     8: 0000000000400114    44 FUNC    GLOBAL DEFAULT    1 swap</span><br><span class="line">     9: 0000000000600198     4 OBJECT  GLOBAL DEFAULT    3 shared</span><br><span class="line">    10: 000000000060019c     0 NOTYPE  GLOBAL DEFAULT    3 __bss_start</span><br><span class="line">    11: 00000000004000e8    44 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    12: 000000000060019c     0 NOTYPE  GLOBAL DEFAULT    3 _edata</span><br><span class="line">    13: 00000000006001a0     0 NOTYPE  GLOBAL DEFAULT    3 _end</span><br></pre></td></tr></table></figure>

<p>可以看到 main，share， swap 三个符号都有，并且不再是 UND。上面提到静态链接规则其实是将目标文件的相似段进行合并，那么看一下是是如何进行合并的，以 text 段为例，a.o 的 text 段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objdump -h a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000002c  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  0000006c  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  0000006c  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      0000002c  0000000000000000  0000000000000000  0000006c  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000098  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000098  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure>

<p>可以看到该 text 段的大小为 2c，再来看一下 b.o 的 text 段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objdump -h b.o</span><br><span class="line"></span><br><span class="line">b.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000002c  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000004  0000000000000000  0000000000000000  0000006c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000070  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      0000002c  0000000000000000  0000000000000000  00000070  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000009c  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .eh_frame     00000038  0000000000000000  0000000000000000  000000a0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure>

<p>b.o 的 text 段大小为 2c，看一下链接形成的可执行文件 ab 的段信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objdump -h ab</span><br><span class="line"></span><br><span class="line">ab:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000058  00000000004000e8  00000000004000e8  000000e8  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .eh_frame     00000058  0000000000400140  0000000000400140  00000140  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .data         00000004  0000000000600198  0000000000600198  00000198  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  3 .comment      0000002b  0000000000000000  0000000000000000  0000019c  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>

<p>2c + 27 = 53，由此证明了链接的规则，同时在链接完成后，各个段的虚拟地址都已经被计算好了，为文件执行做准备，同时做一个简单计：在 ab 中，text 段的虚拟地址为 4000e8 ，因为 swap 在 b.o 中的偏移量为 0，所以进行相似段合并时，swap 的地址为 4000e8 + 27 = 40010f，查看 swap 的地址如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf -s ab</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 14 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 00000000004000e8     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     2: 0000000000400140     0 SECTION LOCAL  DEFAULT    2 </span><br><span class="line">     3: 0000000000600198     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     6: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     7: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS </span><br><span class="line">     8: 0000000000400114    44 FUNC    GLOBAL DEFAULT    1 swap</span><br><span class="line">     9: 0000000000600198     4 OBJECT  GLOBAL DEFAULT    3 shared</span><br><span class="line">    10: 000000000060019c     0 NOTYPE  GLOBAL DEFAULT    3 __bss_start</span><br><span class="line">    11: 00000000004000e8    44 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    12: 000000000060019c     0 NOTYPE  GLOBAL DEFAULT    3 _edata</span><br><span class="line">    13: 00000000006001a0     0 NOTYPE  GLOBAL DEFAULT    3 _end</span><br></pre></td></tr></table></figure>

<p>与预期计算相符，其他符号的地址都是这么计算出来的，链接后，每个符号的虚拟地址已经确定，那么在确定符号的虚拟地址后，链接器根据符号的地址对每个需要重定位的指令进行修正，用 objdump 反汇编编译出的指令，ab 的汇编如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objdump -d ab</span><br><span class="line"></span><br><span class="line">ab:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000004000e8 &lt;main&gt;:</span><br><span class="line">  4000e8:       55                      push   % rbp</span><br><span class="line">  4000e9:       48 89 e5                mov    % rsp,% rbp</span><br><span class="line">  4000ec:       48 83 ec 10             sub    $0x10,% rsp</span><br><span class="line">  4000f0:       c7 45 fc 64 00 00 00    movl   $0x64,-0x4 (% rbp)</span><br><span class="line">  4000f7:       48 8d 45 fc             lea    -0x4 (% rbp),% rax</span><br><span class="line">  4000fb:       be 98 01 60 00          mov    $0x600198,% esi</span><br><span class="line">  400100:       48 89 c7                mov    % rax,% rdi</span><br><span class="line">  400103:       b8 00 00 00 00          mov    $0x0,% eax</span><br><span class="line">  400108:       e8 07 00 00 00          callq  400114 &lt;swap&gt;</span><br><span class="line">  40010d:       b8 00 00 00 00          mov    $0x0,% eax</span><br><span class="line">  400112:       c9                      leaveq </span><br><span class="line">  400113:       c3                      retq   </span><br><span class="line">  </span><br><span class="line">  0000000000400114 &lt;swap&gt;:</span><br><span class="line">  400114:       55                      push   % rbp</span><br><span class="line">  400115:       48 89 e5                mov    % rsp,% rbp</span><br><span class="line">  400118:       48 89 7d e8             mov    % rdi,-0x18 (% rbp)</span><br><span class="line">  40011c:       48 89 75 e0             mov    % rsi,-0x20 (% rbp)</span><br><span class="line">  400120:       48 8b 45 e8             mov    -0x18 (% rbp),% rax</span><br><span class="line">  400124:       8b 00                   mov    (% rax),% eax</span><br><span class="line">  400126:       89 45 fc                mov    % eax,-0x4 (% rbp)</span><br><span class="line">  400129:       48 8b 45 e0             mov    -0x20 (% rbp),% rax</span><br><span class="line">  40012d:       8b 10                   mov    (% rax),% edx</span><br><span class="line">  40012f:       48 8b 45 e8             mov    -0x18 (% rbp),% rax</span><br><span class="line">  400133:       89 10                   mov    % edx,(% rax)</span><br><span class="line">  400135:       48 8b 45 e0             mov    -0x20 (% rbp),% rax</span><br><span class="line">  400139:       8b 55 fc                mov    -0x4 (% rbp),% edx</span><br><span class="line">  40013c:       89 10                   mov    % edx,(% rax)</span><br><span class="line">  40013e:       5d                      pop    % rbp</span><br><span class="line">  40013f:       c3                      retq  </span><br></pre></td></tr></table></figure>

<p>这就是重定位，还有一个问题是链接器是怎么知道哪些指令要进行重定位呢？在 ELF 文件内有一个重定位表的结构专门用来保存这些与重定位相关的信息，使用 readelf –r a.o 可以看到目标文件的重定位表，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objdump -r a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000014 R_X86_64_32       shared</span><br><span class="line">0000000000000021 R_X86_64_PC32     swap-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure>

<p>其中 “<code>0000000000000021 R_X86_64_PC32     swap-0x0000000000000004</code>“ 表示 swap 在 text 段内被引用了，需要进行重定位，重定位地址为 text 段偏移量为 21 字节处，看一下 a.o 的反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objdump  -D a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   55                      push   % rbp</span><br><span class="line">   1:   48 89 e5                mov    % rsp,% rbp</span><br><span class="line">   4:   48 83 ec 10             sub    $0x10,% rsp</span><br><span class="line">   8:   c7 45 fc 64 00 00 00    movl   $0x64,-0x4 (% rbp)</span><br><span class="line">   f:   48 8d 45 fc             lea    -0x4 (% rbp),% rax</span><br><span class="line">  13:   be 00 00 00 00          mov    $0x0,% esi</span><br><span class="line">  18:   48 89 c7                mov    % rax,% rdi</span><br><span class="line">  1b:   b8 00 00 00 00          mov    $0x0,% eax</span><br><span class="line">  20:   e8 00 00 00 00          callq  25 &lt;main+0x25&gt;</span><br><span class="line">  25:   b8 00 00 00 00          mov    $0x0,% eax</span><br><span class="line">  2a:   c9                      leaveq </span><br><span class="line">  2b:   c3                      retq   </span><br></pre></td></tr></table></figure>

<p>偏移的 21 字节刚好是 e8 （call 指令）后的位置，这里的 21 也叫做重定位入口。（在重定位段中，swap 的 TYPE 属性是 R_X86_64_PC32，这个表示的是，不要在重定位入口处直接填写 swap 的虚拟内存地址，而要填 swap 相对 call 指令下一条指令的偏移量。R_X86_64_PC32 这里也叫做重定位入口类型。</p>
<p>如果我们在链接指令<code> ld a.o b.o –e main –o ab</code> 中，不链接 b.o ，则会出现如下错误，这是静态链接常见的一种编译报错，即符号未定义引起的报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ld a.o -e main -o ab</span><br><span class="line">a.o: In function `main&#x27;:</span><br><span class="line">a.c:(.text+0x14): undefined reference to `shared&#x27;</span><br><span class="line">a.c:(.text+0x21): undefined reference to `swap</span><br></pre></td></tr></table></figure>

<h2 id="5-7-动态链接"><a href="#5-7-动态链接" class="headerlink" title="5.7 动态链接"></a>5.7 动态链接</h2><h3 id="5-7-1-动态链接的背景"><a href="#5-7-1-动态链接的背景" class="headerlink" title="5.7.1  动态链接的背景"></a>5.7.1  动态链接的背景</h3><p>上面分析了静态链接的过程，可以看到静态链接有一个明显的特点就是必须是在程序运行前完成。这样会存在以下两个缺点：</p>
<ul>
<li>版本更新麻烦。静态库和所有的软件一样，需要定期维护和更新。如 lib 更新了，还需要重新编译可执行文件，尽管可能是一个很小的改动，却导致整个程序需要重新下载，全量更新。</li>
<li>内存空间浪费。几乎每个 C 程序都使用标准 I/O 函数，比如 printf 和 scanf 在运行时，这些函数的代码会被复制到每个运行进程的文本段中。在一个运行 50-100 个进程的典型系统上，这会是对稀少的存储器系统资源的极大浪费。</li>
</ul>
<p>为了解决以上问题，引入了共享库和动态链接。共享库是致力于解决静态库缺陷的一个现代创新产物，它是一个目标模块，在运行时，可以加载到任意的存储器地址，并在存储器中和一个程序链接起来，这个过程称为动态链接，是由一个叫做动态链接器的程序来执行的。</p>
<p>在任何给定的文件系统中，对于一个库只有一个共享库文件。 所有引用该库的可执行目标文件共享这个共享库文件中的代码和数据，而不是像静态库的内容那样被拷贝和嵌入到引用它们的可执行的文件中；在存储器中，一个共享库的.text 节只有一个副本可以被不同的正在运行的进程共享。</p>
<p>这样一来，既节省了磁盘空间和内存空间，又使得程序的升级更容易进行，不用再重新编译整个代码，只需要对原有旧目标进行替换即可。</p>
<h3 id="5-7-2-动态链接原理分析"><a href="#5-7-2-动态链接原理分析" class="headerlink" title="5.7.2 动态链接原理分析"></a>5.7.2 动态链接原理分析</h3><p>动态链接的基本步骤分为以下几步：</p>
<ul>
<li>动态链接器的自举（动态链接器即 ld.so 本身也是一个共享对象，但是它不依赖于任何共享对象，如下图所示，其次动态链接器本身所需的全局变量和静态变量的重定位由其自己完成，这就是动态链接器的自举，就像内核的自我解压）</li>
</ul>
<p>动态链接的基本步骤分为一下几步：</p>
<p>（1）动态链接器的自举（动态链接器即 ld.so 本身也是一个共享对象，但是它不依赖于任何共享对象，如下图所示，其次动态链接器本身所需的全局变量和静态变量的重定位由其自己完成，这就是动态链接器的自举，就像内核的自我解压）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ldd /lib/x86_64-linux-gnu/ld-2.19.so </span><br><span class="line">        statically linked</span><br></pre></td></tr></table></figure>

<ul>
<li> 动态链接装载共享对象，即动态链接器将可执行文件依赖的代码段和数据段映射到进程的地址空间中，直到所有的依赖对象都被装载成功。</li>
<li> 符号的重定位。</li>
</ul>
<p>完成以上步骤后，动态链接器将控制权移交给进程，进程开始运行。</p>
<p>我们重点分析动态链接时，其符号是如何被重定位的，介绍 GOT，PLT 等相关内容，同时举例分析重定位是如何一步一步实现的。</p>
<h3 id="5-7-3-地址无关代码（Position-independent-Code）"><a href="#5-7-3-地址无关代码（Position-independent-Code）" class="headerlink" title="5.7.3 地址无关代码（Position-independent Code）"></a>5.7.3 地址无关代码（Position-independent Code）</h3><p>当动态链接模块被装载进内存空间后，指令部分在多个进程间共享，若使用重新装载的方法，需要修改指令（像静态链接一样），没有办法做到同一份指令被多个进程共享，因为重定位后的指令对于每个进程来讲是不一样的，它不像动态链接库中的可修改数据部分，对每个进程来讲都有一份拷贝，可以使用装载时重定位的方法。</p>
<p>那么如何处理这种动态库的指令部分不能共享的问题呢？我们希望的是程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现方法就是把指令中需要修改的部分分离出来，跟数据部分放在一块，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本，这就是地址无关代码，这就保证了二进制文件不论被加载到哪个位置，都可以正确执行。</p>
<p>我们将共享对象模块种的地址引用按照是否跨模块分为两类，模块内部引用和模块外部引用，按照不同的引用方式又可以分为指令引用和数据访问，同时给出其地址引用方式</p>
<table>
<thead>
<tr>
<th>各种地址引用方式</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>指令跳转，引用</td>
<td>数据访问</td>
</tr>
<tr>
<td>模块内部</td>
<td>相对跳转和调用</td>
<td>相对地址访问</td>
</tr>
<tr>
<td>模块外部</td>
<td>间接跳转和调用（GOT）</td>
<td>间接访问（GOT）</td>
</tr>
</tbody></table>
<p>其中模块内部的指令引用和数据访问都可以使用相对偏移来进行计算，因为模块内部之间他们的相对偏移是固定的，而模块外部的函数调用需要使用 GOT 进行间接跳转。</p>
<h3 id="5-7-4-GOT（GLOBAL-Offset-Table）"><a href="#5-7-4-GOT（GLOBAL-Offset-Table）" class="headerlink" title="5.7.4 GOT（GLOBAL Offset Table）"></a>5.7.4 GOT（GLOBAL Offset Table）</h3><p>在进行动态链接时，程序的代码段是只读属性，在重定位过程中是不能被修改的，因为多个进程是共享动态库中的指令部分，但是每个进程却拥有动态共享库的数据部分，那就只能通过修改数据部分来完成重定位过程。</p>
<p>GOT 即全局偏移表，它是 ELF 在其数据段内建立一个指向被引用的外部变量的指针数组，保存了所有外部符号的地址信息，GOT 被保存在数据段，所以可以在装载时被修改，并且每个进程都有独立的副本，互不影响。假如在执行的指令中，需要引用符号 A，但是 A 存在于动态库中，链接过程并不知道它的地址，于是将 A 的地址部分改写为 GOT 表中的一项，在编译阶段 GOT 表中没有真实数据的，但是在动态链接阶段，动态链接器可以将符号 A 的真实地址写到 GOT 表中对应的数据项，这样就产生流对指令 A 的正确引用，GOT 表中的每一个表项表示的是运行时的符号的真实地址。</p>
<p>这就是引入 GOT 表的原因。</p>
<h3 id="5-7-5-PLT（Procedure-Linkage-Table）"><a href="#5-7-5-PLT（Procedure-Linkage-Table）" class="headerlink" title="5.7.5 PLT（Procedure Linkage Table）"></a>5.7.5 PLT（Procedure Linkage Table）</h3><p>相对于静态链接而言，动态链接比较灵活，当然也带来了性能上的一些损失，ELF 程序在静态链接下要比动态链接要快，大约 1%~5%，当然这也取决于程序的运行环境。但如果在动态链接的时候，没有被用到的函数也被重定位，则会延长链接时间，所以 ELF 采用了一种延迟绑定（Lazy Binding）策略，基本思想就是在函数第一次被用到时才进行绑定，如果没有用到则不被绑定。所以程序开始执行时，模块间的函数都没有被绑定，而是需要时才由动态链接器来负责绑定，这种做法可以加快程序启动速度。</p>
<p>而延迟绑定的实现是由 PLT 表来实现，ELF 文件中，PLT 表和 GOT 表几乎是同时存在，因为运行时不能修改指令，所以通过数据部分的 GOT 表来传递运行时符号的真实地址，而 PLT 是一小段跳转指令，来实现函数的间接调用。</p>
<p>下面举例来分析一下 PLT 和 GOT 是如何配合来实现函数的间接调用的。</p>
<h3 id="5-7-6-举例分析"><a href="#5-7-6-举例分析" class="headerlink" title="5.7.6 举例分析"></a>5.7.6 举例分析</h3><p>回到我们最初的 hello world 程序，其虚拟空间地址空间内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/15457/maps</span></span><br><span class="line">00400000-00401000 r-xp 00000000 08:13 2883925                            /home/yw/mywork/my_programe/test</span><br><span class="line">00600000-00601000 r--p 00000000 08:13 2883925                            /home/yw/mywork/my_programe/test</span><br><span class="line">00601000-00602000 rw-p 00001000 08:13 2883925                            /home/yw/mywork/my_programe/test</span><br><span class="line">7fccada35000-7fccadbf3000 r-xp 00000000 08:13 1310823                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7fccadbf3000-7fccaddf3000 ---p 001be000 08:13 1310823                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7fccaddf3000-7fccaddf7000 r--p 001be000 08:13 1310823                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7fccaddf7000-7fccaddf9000 rw-p 001c2000 08:13 1310823                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7fccaddf9000-7fccaddfe000 rw-p 00000000 00:00 0 </span><br><span class="line">7fccaddfe000-7fccade21000 r-xp 00000000 08:13 1310820                    /lib/x86_64-linux-gnu/ld-2.19.so</span><br><span class="line">7fccae005000-7fccae008000 rw-p 00000000 00:00 0 </span><br><span class="line">7fccae01f000-7fccae020000 rw-p 00000000 00:00 0 </span><br><span class="line">7fccae020000-7fccae021000 r--p 00022000 08:13 1310820                    /lib/x86_64-linux-gnu/ld-2.19.so</span><br><span class="line">7fccae021000-7fccae022000 rw-p 00023000 08:13 1310820                    /lib/x86_64-linux-gnu/ld-2.19.so</span><br><span class="line">7fccae022000-7fccae023000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffefa50c000-7ffefa52d000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffefa571000-7ffefa574000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffefa574000-7ffefa576000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure>

<p>因为可执行代码要调用 printf 函数，所以要在运行时链接 libc.so ，那么其最终是怎么使用到 printf 的呢，用 gdb 调试一下，可以看到其最终调用了跳入了地址 0x400410，进入了 puts 的 plt 表项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble </span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x000000000040052d &lt;+0&gt;:     push   % rbp</span><br><span class="line">   0x000000000040052e &lt;+1&gt;:     mov    % rsp,% rbp</span><br><span class="line">=&gt; 0x0000000000400531 &lt;+4&gt;:     mov    $0x4005d4,% edi</span><br><span class="line">   0x0000000000400536 &lt;+9&gt;:     callq  0x400410 &lt;puts@plt&gt;</span><br><span class="line">   0x000000000040053b &lt;+14&gt;:    mov    $0x0,% eax</span><br><span class="line">   0x0000000000400540 &lt;+19&gt;:    pop    % rbp</span><br><span class="line">   0x0000000000400541 &lt;+20&gt;:    retq   </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<p>因为可执行代码要调用 printf 函数，所以要在运行时链接 libc.so ，那么其最终是怎么使用到 printf 的呢，用 gdb 调试一下，可以看到其最终调用了跳入了地址 0x400410，进入了 puts 的 plt 表项，反汇编这个地址，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble 0x400410</span><br><span class="line">Dump of assembler code for function puts@plt:</span><br><span class="line">   0x0000000000400410 &lt;+0&gt;:     jmpq   *0x200c02 (% rip)        # 0x601018 &lt;puts@got.plt&gt;</span><br><span class="line">   0x0000000000400416 &lt;+6&gt;:     pushq  $0x0</span><br><span class="line">   0x000000000040041b &lt;+11&gt;:    jmpq   0x400400</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>可以看到 0x40010 中是 plt 表中的内容，这里存放着三行代码。可以看到 plt 中又直接跳转到了 *0x200c02 (% rip) 中，跳转到 (0x200c02 + rip) 中存放的数据，接着看一下 (0x200c02 + rip) 中存放了什么，在 x86 汇编中 rip 是指向下一条指令的地址，所以是 0x601018，上面这条指令右边的注释已经帮我们标明了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) print /x *0x601018</span><br><span class="line">$1 = 0x400416</span><br></pre></td></tr></table></figure>

<p>可以看到值为 0x400416, 正是当前指令的下一条指令 pushq $0x0。0x601018 存放的地址是 puts 函数的地址，如果链接器在初始化阶段已经初始化该项，并且将 puts 的地址填入该项，那么这个跳转指令就是我们所期望的，实现函数的正确调用，但是为了实现延迟绑定，链接器在初始化阶段并没有将 puts 的地址填入到该项，而是将上面 0x400416 指令 pushq 填入到了 <a href="mailto:&#112;&#117;&#x74;&#115;&#x40;&#x67;&#x6f;&#x74;&#46;&#112;&#108;&#x74;">&#112;&#117;&#x74;&#115;&#x40;&#x67;&#x6f;&#x74;&#46;&#112;&#108;&#x74;</a>，所以我们看到 * 0x601018 的值为 0x400416。</p>
<p>0x400416 下面接着的指令是 jmpq 0x400400，用 <code>x /5i 0x400400</code> 指令 查看（不知道为啥 disassemble 指令不起作用，所以直接看内存）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x /5i 0x400400</span><br><span class="line">   0x400400:    pushq  0x200c02 (% rip)        # 0x601008</span><br><span class="line">   0x400406:    jmpq   *0x200c04 (% rip)        # 0x601010</span><br><span class="line">   0x40040c:    nopl   0x0 (% rax)</span><br><span class="line">   0x400410 &lt;puts@plt&gt;: jmpq   *0x200c02 (% rip)        # 0x601018 &lt;puts@got.plt&gt;</span><br><span class="line">   0x400416 &lt;puts@plt+6&gt;:       pushq  $0x0</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<p>第一个 <code>pushq 0x200c02 (% rip)</code> 将 <code>link_map</code> 的地址入栈，<code>jmpq *0x200c04 (% rip)</code> 跳转到 <code>dl_runtime_reslove</code> 中解析函数，解析完毕，再将解析到的函数地址，填到对应的 got 表项中。每个外部函数第一次调用都要进行这样一次函数的查找，并将地址填到 got 表项中，这样下次调用的时候，就无需查找了，直接跳转到外部函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p /x *0x601018</span><br><span class="line">$6 = 0xf7a80d60</span><br></pre></td></tr></table></figure>

<h3 id="5-7-7-动态库的编译"><a href="#5-7-7-动态库的编译" class="headerlink" title="5.7.7  动态库的编译"></a>5.7.7  动态库的编译</h3><p>动态链接的基本思想就是把程序按照模块拆分为各个相对独立的部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独可执行文件，当前 Linux 中，ELF 动态链接文件被称为动态共享对象（Dynamic Shared Objects），一般都是以.so 结尾，windos 下常见的就是.dll 结尾的文件。</p>
<p>我们依旧以一个例子展开描述动态链接的基本步骤。</p>
<p>程序 p1.c 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    foobar (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序 p2.c 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    foobar (<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两端代码都引用了 Lib.c 里面的 foobar 函数，为了在内存中加载一次 Lib.c ，使得 p1 和 p2 共享，将 Lib.c 编译成共享对象。</p>
<p>程序 Lib.c 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Printing from Lib.so % d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先使用命令 gcc -fpic -shared -o Lib.so Lib.c  将 Lib.c 编译为共享对象，-shared 表示产生共享对象，-fpic 表示产生地址无关代码（还有一个 –fPIC 区别在于这个参数产生的代码大一点，而 - fpic 产生的代码小一点，还有一点 - fpic 在某些平台上会有限制，比如全局符号的梳理或代码长度，而而 –FPIC 则没有此限制，一般情况下都用大写的来产生地址无关代码）然后我们得到了一个 Lib.so 的文件，然后我们分别编译链接 p1.c 和 p2.c </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o p1 p1.c ./Lib.so</span><br><span class="line">gcc -o p2 p2.c ./Lib.so</span><br></pre></td></tr></table></figure>

<p>这样我们得到了两个可执行文件 p1 和 p2 ，基本过程如下：</p>
<p><img src="%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B.jpg" alt="img"></p>
<p>与静态链接不同的地方在于 program1.o 和 Lib.o 会被链接在一起，产生可执行文件，但是动态链接的输入只有 program1.o ，在链接执行过程中，链接器会将 foobar 标记为一个动态链接的符号，不对它进行重定位，把这个过程留到装载时再执行，这就是要在编译时带上 Lib.so 的原因（Lib.so 内保存了完整的符号信息），执行 p1，输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./p1</span>     </span><br><span class="line">Printing from Lib.so 1</span><br></pre></td></tr></table></figure>

<p>在执行 p1 时，进程的虚拟地址空间布局如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/24125/maps</span></span><br><span class="line">00400000-00401000 r-xp 00000000 08:13 2883957                            /home/yw/mywork/my_programe/p1</span><br><span class="line">00600000-00601000 r--p 00000000 08:13 2883957                            /home/yw/mywork/my_programe/p1</span><br><span class="line">00601000-00602000 rw-p 00001000 08:13 2883957                            /home/yw/mywork/my_programe/p1</span><br><span class="line">7f934331f000-7f93434dd000 r-xp 00000000 08:13 1310823                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7f93434dd000-7f93436dd000 ---p 001be000 08:13 1310823                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7f93436dd000-7f93436e1000 r--p 001be000 08:13 1310823                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7f93436e1000-7f93436e3000 rw-p 001c2000 08:13 1310823                    /lib/x86_64-linux-gnu/libc-2.19.so</span><br><span class="line">7f93436e3000-7f93436e8000 rw-p 00000000 00:00 0 </span><br><span class="line">7f93436e8000-7f93436e9000 r-xp 00000000 08:13 2883937                    /home/yw/mywork/my_programe/Lib.so</span><br><span class="line">7f93436e9000-7f93438e8000 ---p 00001000 08:13 2883937                    /home/yw/mywork/my_programe/Lib.so</span><br><span class="line">7f93438e8000-7f93438e9000 r--p 00000000 08:13 2883937                    /home/yw/mywork/my_programe/Lib.so</span><br><span class="line">7f93438e9000-7f93438ea000 rw-p 00001000 08:13 2883937                    /home/yw/mywork/my_programe/Lib.so</span><br><span class="line">7f93438ea000-7f934390d000 r-xp 00000000 08:13 1310820                    /lib/x86_64-linux-gnu/ld-2.19.so</span><br><span class="line">7f9343af0000-7f9343af3000 rw-p 00000000 00:00 0 </span><br><span class="line">7f9343b0a000-7f9343b0c000 rw-p 00000000 00:00 0 </span><br><span class="line">7f9343b0c000-7f9343b0d000 r--p 00022000 08:13 1310820                    /lib/x86_64-linux-gnu/ld-2.19.so</span><br><span class="line">7f9343b0d000-7f9343b0e000 rw-p 00023000 08:13 1310820                    /lib/x86_64-linux-gnu/ld-2.19.so</span><br><span class="line">7f9343b0e000-7f9343b0f000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffe39932000-7ffe39953000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffe3998d000-7ffe39990000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffe39990000-7ffe39992000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure>

<p>可以看到整个进程的虚拟地址空间，多出来几个文件的映射，同时看到 p1 还引用了动态链接形式的 C 语言运行时库 libc-2.19.so ，还有一个对象是 ld-2.19.so，它是 Linux 下的动态链接器。动态链接器与普通共享对象一起被映射进进程的地址空间，在系统开始运行 p1 之前，首先会把控制权交给动态链接器，由其完成动态链接工作以后，再把控制权交给 p1。</p>
<p>Lib.so 的属性如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -l Lib.so</span> </span><br><span class="line"></span><br><span class="line">Elf file type is DYN (Shared object file)</span><br><span class="line">Entry point 0x5e0</span><br><span class="line">There are 7 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x000000000000078c 0x000000000000078c  R E    200000</span><br><span class="line">  LOAD           0x0000000000000e00 0x0000000000200e00 0x0000000000200e00</span><br><span class="line">                 0x0000000000000238 0x0000000000000240  RW     200000</span><br><span class="line">  DYNAMIC        0x0000000000000e18 0x0000000000200e18 0x0000000000200e18</span><br><span class="line">                 0x00000000000001c0 0x00000000000001c0  RW     8</span><br><span class="line">  NOTE           0x00000000000001c8 0x00000000000001c8 0x00000000000001c8</span><br><span class="line">                 0x0000000000000024 0x0000000000000024  R      4</span><br><span class="line">  GNU_EH_FRAME   0x000000000000070c 0x000000000000070c 0x000000000000070c</span><br><span class="line">                 0x000000000000001c 0x000000000000001c  R      4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     10</span><br><span class="line">  GNU_RELRO      0x0000000000000e00 0x0000000000200e00 0x0000000000200e00</span><br><span class="line">                 0x0000000000000200 0x0000000000000200  R      1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   01     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss </span><br><span class="line">   02     .dynamic </span><br><span class="line">   03     .note.gnu.build-id </span><br><span class="line">   04     .eh_frame_hdr </span><br><span class="line">   05     </span><br><span class="line">   06     .init_array .fini_array .jcr .dynamic .got</span><br></pre></td></tr></table></figure>

<p>可以看到其加载段的虚拟地址为 0，需要在装载时由装载器根据当前地址情况，分配足够大小的虚拟地址空间给相应的共享对象。</p>
<p>如果当前可执行文件的所在的目录缺少 Lib.so，则会报错，执行 p1 时，会有 动态链接报错，这是一种常见的动态链接报错的形式，找不到动态库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> Lib.so Lib.so.bak</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./p1</span></span><br><span class="line">./p1: error while loading shared libraries: ./Lib.so: cannot open shared object file: No such file or directory</span><br><span class="line"><span class="meta prompt_">$ </span></span><br></pre></td></tr></table></figure>

<h2 id="5-8-显式运行时链接"><a href="#5-8-显式运行时链接" class="headerlink" title="5.8 显式运行时链接"></a>5.8 显式运行时链接</h2><p>支持动态链接的系统都支持一种更加灵活的模块加载方式，叫做显式运行时链接，也叫做运行时加载，也就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块时将其卸载。如果动态链接器可以在运行时将共享模块载入内存并且可以进行重定位操作，那么这种运行时加载在理论上也很容易实现，而且一般的共享对象不需要进行任何修改就可以进行运行时装载，这种共享对象往往被叫做动态装载库，和一般的共享对象没有什么区别。</p>
<p>对于 Linux 来讲，动态库跟一般的共享对象的主要区别在于共享对象是由动态链接器在程序启动之前负责装载和链接的，这一系列步骤由动态链接器自动完成，对于程序本身来讲是透明的；而动态链接库的装载则是通过一系列由动态链接器提供的 API 完成，详细可以参考 dlopen，dlsym，dlerror，dlclose 这几个函数的用法。</p>
<h1 id="6-加载"><a href="#6-加载" class="headerlink" title="6. 加载"></a>6. 加载</h1><h3 id="6-1-进程地址空间"><a href="#6-1-进程地址空间" class="headerlink" title="6.1 进程地址空间"></a>6.1 进程地址空间</h3><p>Linux 进程地址空间由多个 segments 构成，不同的 segments 具备不同的属性（读、写、执行）以及具备不同的特征（静态、动态），完成不同的功能。</p>
<p>具体以 32bit 处理器为例，地址空间 layout 布局如下图所示：</p>
<p><img src="%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="img"></p>
<p>从地址由小递增而看，分析各个 segments 具备的特征属性及实现功能，其中‘r’表示可读，‘w’表示可写，‘x’表示可执行，‘p’表示 private 私有，‘s’表示 shared 共享：</p>
<p><strong>Text segment：</strong> 代码段，存放程序指令，通常为权限为‘rxp’</p>
<p><strong>Data segment：</strong> 数据段，存放程序初始化后的全局及静态变量，通常为权限为‘rxp’</p>
<p><strong>BSS segment：</strong> 数据段，存放程序未初始化或初始化为 0 的全局及静态变量，通常为权限为‘rxp’</p>
<p>以上三个 segments 的特征为静态的，即对于一个程序而言在编译后大小是固定的，所以这三个 segments 连续存储排布。</p>
<p><strong>Heap segment：</strong> 堆，用于进程动态分配内存，通常为权限为‘rwp’</p>
<p><strong>Mem map segment：</strong>Map 段，mmap 系统调用后申请的段，可以用于存储动态库、匿名页等等</p>
<p><strong>Stack segment：</strong> 栈，用于函数调用过程栈生长及收缩，通常为权限为‘rwp’</p>
<p>对于一个进程实例，可以通过 <strong><code>cat /proc/&#123;PID&#125;/maps</code></strong> 查看该进程的内存地址空间布局，下图为一个进程实例：</p>
<p><img src="%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AE%9E%E4%BE%8B.png" alt="img"></p>
<p>上图包含了一个进程实例的以下关键信息：</p>
<ol>
<li>进程地址空间 segments 构成</li>
<li>各 segments 占用的地址范围，具备的属性特征</li>
<li>各 segment 是匿名段还是命名段，如果是命名段，其指向的具体文件</li>
</ol>
<h3 id="6-2-程序加载过程"><a href="#6-2-程序加载过程" class="headerlink" title="6.2 程序加载过程"></a>6.2 程序加载过程</h3><p>从编译链接的角度看，可以分为静态链接和动态链接。</p>
<p>同样，对于一个执行文件的加载运行过程，静态链接程序和动态链接程序存在差异：</p>
<ol>
<li>静态链接程序：运行加载过程无需进行动态 lib 库的加载链接，静态链接程序运行时地址空间如下图所示：</li>
</ol>
<p><img src="%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%A8%8B%E5%BA%8F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="img"></p>
<ol start="2">
<li>动态链接程序：运行加载过程需要进行动态 lib 库的加载链接，动态链接程序运行时地址空间如下图所示：</li>
</ol>
<p><img src="%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%A8%8B%E5%BA%8F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="img"></p>
<p>程序运行过程主要完成以下三部分流程：</p>
<ol>
<li><p>创建一个独立的虚拟地址空间。</p>
</li>
<li><p>读取可执行文件，并且建立虚拟空间与可执行文件的映射关系。</p>
</li>
<li><p>将 CPU 的 PC 寄存器设置成可执行文件的入口地址，启动运行新进程。</p>
</li>
</ol>
<p>以下更为详细的介绍 ELF 可执行程序的加载流程：</p>
<ol>
<li><p>读取并检查目标执行程序 ELF 头部</p>
</li>
<li><p>加载及解析目标程序的 Program Header</p>
</li>
<li><p>如果需要动态链接，则寻找和处理解释器段。<strong>INTERP</strong> 是解释器段类型，需要加载解析器段，用于加载共享库。找到后就根据其位置的 p_offset 和大小 p_filesz 把整个” 解释器” 段的内容读入缓冲区。</p>
</li>
</ol>
<p><img src="ProgramHeader%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E4%BF%A1%E6%81%AF.png" alt="img"></p>
<p>​    通过命令   <strong><code>readelf -S</code></strong> 可以看到动态链接程序使用的解释器，如上图红框所示。而静态链接程序无此内容。</p>
<ol start="4">
<li><p>装入目标程序的段 segment</p>
<p>从目标映像的程序头中搜索类型为 PT_LOAD 的段（Segment）。在二进制映像中，只有类型为 PT_LOAD 的段才是需要装入的。确定了装入地址后，建立用户空间虚拟地址空间与目标映像文件中某个连续区间之间的映射。</p>
<p>有一点需要注意，在映射到进程的虚拟地址空间时，栈、堆、mmap、** 解析器 ** 段 的起始地址往往加上一个 <strong>随机偏移量</strong>。因为在 i386 系统上，文本基地址（.text）固定为 0x08048000，敏感的堆栈区域容易被推算出入口地址，从而被黑客攻击。</p>
</li>
<li><p>获取程序的入口地址</p>
<p>完成了目标程序和解释器的加载，各个段的内容已经加载到内存了。</p>
<p>1）如果需要装入解释器，则进入用户空间的入口地址设置成 l 解释器映像的入口地址。这样返回用户空间时先执行解析器程序，将需要的 share lib 映射到进程的 mmap 虚拟地址空间中；可通过 ldd 命令查看依赖动态库。</p>
<p>2）若不需要装入解释器，那么这个入口地址就是目标映像本身的入口地址。</p>
</li>
<li><p>需要准备目标文件的参数环境变量等必要信息</p>
<p>从 execve 系统调用拿到的参数、环境变量等等，还有一些 “辅助向量，经过一些设置后，压入进程栈中。</p>
<p>这些信息需要复制到用户空间，使它们在 CPU 进入解释器或目标映像的程序入口时出现在用户空间堆栈上。</p>
</li>
</ol>
<p><strong>进程加载段（segment）的类型定义如下</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PT_NULL    0	             <span class="comment">/* 未定义的条目 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOAD    1	             <span class="comment">/* 可加载的段 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_DYNAMIC 2	             <span class="comment">/* 动态链接相关信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_INTERP  3	             <span class="comment">/* 解析器段 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_NOTE    4	             <span class="comment">/* 附加信息的位置和大小 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SHLIB   5	             <span class="comment">/* 预留类型，无意义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_PHDR    6	             <span class="comment">/* 指出该程序头表在文件和内存映像中的位置和大小 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TLS     7		         <span class="comment">/* Thread local storage segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOOS    0x60000000	     <span class="comment">/* OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HIOS    0x6fffffff	     <span class="comment">/* OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOPROC  0x70000000	     <span class="comment">/* 体系相关信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HIPROC  0x7fffffff	     <span class="comment">/* 体系相关信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_EH_FRAME  0x6474e550            <span class="comment">/* 供栈回溯的信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_STACK	(PT_LOOS + 0x474e551)  <span class="comment">/* 栈 */</span></span></span><br></pre></td></tr></table></figure>

<h1 id="7-编译、链接工具使用举例"><a href="#7-编译、链接工具使用举例" class="headerlink" title="7. 编译、链接工具使用举例"></a>7. 编译、链接工具使用举例</h1><p><strong>gcc</strong></p>
<p>以下是我们 TDMP 平台的一条编译命令，输入文件为 specialDial.c，输出为 specialDial.o：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-openwrt-linux-muslgnueabi-gcc -Os -pipe -march=armv7-a -mtune=cortex-a7 -g3 -fno-caller-saves -Wa,--noexecstack -fhonour-copts -mfloat-abi=soft -fPIC -fstack-protector -D_FORTIFY_SOURCE=2 -Wl,-z,now -Wl,-z,relro -DMANUFACTURER_VENDOR_TPLINK -DTP_MESH_TPLINK -DINCLUDE_TPDDNS_FUNC -DVENDOR_WLAN_DRIVER_qca -DVENDOR_ETHERNET_ipq5018 -DCONFIG_LAN_ETH_NAME_PREFIX=\&quot;eth0.\&quot; -DCONFIG_APS_BUILT_IN -DCONFIG_PS_FAST_FORWARD_SUPPORT -DINCLUDE_APP_MARKET -DFACBOOT_UPGRADE_SUPPORT -DTP_FEATURE_MESH -DTP_WPS_ENROLLEE_SUPPORT -DTP_FEATURE_DFS_SUPPORT -DMESH_WPS_STA_SUPPORT -DWIFISON_FACTORY_PAIR -DTP_WPS_FRAG_SUPPORT -DTP_FEATURE_DUALBAND_BH -DTP_FEATURE_WPS -DINET6 -DHTTP_IPV6_MANAGEMENT -DCONFIG_STATISTICS_IPV6_SUPPORT -DIPV6_AUTO_DIAL -DCONFIG_SINGLE_WAN_NAT66 -DCONFIG_IPV6_DIAL_FOLLOW_IPV4 -DCONFIG_DNS_PROXY_IPV6_SUPPORT -DGPIO_SYS_LED=38 -DGPIO_MESH_LED_RED=19 -DGPIO_PAIR_BUTTON=31 -DCONFIG_GPIO_LED_ACTIVE_MODE=0 -DGPIO_RESET_BUTTON=32 -DTP_FEATURE_EVENT_ENHANCE -DTP_FEATURE_EVENT_ENHANCE_IN_INETD -DHTTP_MAX_CONTENT=0x1200000 -DCONFIG_VLAN_PER_PORT -DCONFIG_WAN_AT_NOPORT -DWLAN_5G_BAND1_SUPPORT -DWLAN_2G_11AX_SUPPORT -DMAPD_SUPPORT_802_11_AX -DWLAN_5G_11AX_SUPPORT -DMAPD_SUPPORT_802_11_AX -DWLAN_OFDMA_DEFAULT_CONFIG_DISABLED -DWLAN_5G_BAND1_BAND2_SUPPORT -DWLAN_5G_BW160_SUPPORT -DWLAN_CONFIG_BANDWIDTH_SUPPROT_160M -DPHY_SPEED_1000M -DTP_FEATURE_WAN_PORT_DETECT -DFIX_WAN_PORT=3 -DSWITCH_PHY_NUM=4 -DTP_FEATURE_POWER_POSITION_LEFT -DDM_ARRAY_OPTION_SUPPORT -DTP_WAN_PORT_DETECT_PROTOCOL=0x7878 -DDMS_PLUGIN_BUILTIN -DDEV_MAIN_VER=0x50010000 -DDEV_MINOR_VER=0x0000 -DSWITCH_PORT_MASK=0xF -DLAN_WAN_PARTITION_BY_VLAN_TAG -DWLAN_DUAL_BAND -DGUEST_5G_SUPPORT -DGUEST_SSIDBRD_SUPPORT -DWLAN_SECURITY_SUPPORT -DWLAN_DOT11_SAE -DWLAN_MULTI_SSID_SUPPORT -DWLAN_WIFI5_COMPATIBLE_BSS_SUPPORT -DWLAN_WIFI5_BSS_DEFAULT_SUFFIX=\&quot;_WiFi5\&quot; -DMAP_BSS_MAX_NUM=6 -DWLAN_EXTEND_MSSID_NUM=3 -DCTCFG_WLAN_SWITCH_SUPPORT -DUSE_DHCP_DETECT=1 -DCTCFG_TP_FEATURE_RSSI_DETECT -DBUILD_DATE=220828 -DBUILD_DATE_YEAR=22 -DBUILD_DATE_MON=8 -DBUILD_DATE_MDAY=28 -DBUILD_DATE_HOUR=11 -DBUILD_DATE_MIN=5 -DBUILD_DATE_SEC=7 -DCONFIG_PS_PORT_MAX=32 -DCTCFG_SUPPORT -DPLATFORM_TDMP -DDUAL_FREQ -DCTCFG_WAN_BRIDGE -DDEFAULT_SYS_MODE=0 -DCTCFG_NETSTAT_SUPPORT -DCTCFG_ROLE_SWITCH_SUPPORT -DCTCFG_MAPD_SERVER_DOMAINS=\&quot;wifiserver.smartont.net:NULL\&quot; -DCONFIG_CUEI_SUPPORT -DELINK_SUPPORT -DELINK_SYNC_DISABLE -DCTCFG_WLAN_EXT -DCTCFG_TRAFFIC_STATISTIC_EX -DCTCFG_MAC_FILTER_SUPPORT -DCTCFG_IPTV_SUPPORT -DIPTV_LAN1_PORT_INDEX=2 -DIPTV_LAN2_PORT_INDEX=1 -DIPTV_LAN3_PORT_INDEX=0 -DELINK_V1 -DCT_WOCLIENT_SUPPORT -DWOLINK_FEATURE -DCT_SOHO_SDK_API -DCT_SPEED_LIMIT_BITS -DHAVE_CYASSL -DCT_WOCLIENT_SCRAM_SUPPORT -DDUAL_IMAGE -DUSE_NAND_FLASH -DCONFIG_MTD_SPI_NOR_UC_USE_4K_SECTORS -DCTCFG_GET_LAN_BY_MAC -DCPU_INFO_SUPPORT -DCTCFG_TELNET_SUPPORT -DCTCFG_TELNET_USERNAME=\&quot;useradmin\&quot; -DCTCFG_TELNET_PASSWD=\&quot;123456\&quot; -DCTCFG_TELNET_ENABLE=0 -DDMS_FEATURE_ATED_FIRSTBOOT_LIMIT -DDMS_FEATURE_TMP_FIRSTBOOT_LIMIT -DCTCFG_FACTORY_TEST_STATUS_SUPPORT -DCT_WPS_PIN_BAND_SUPPORT -DCTCFG_LAN_CONNECT_TRIGGER_PAIRING -DTP_FEATURE_REMOTE_DM -DCONFIG_USE_kmod_wlan_access_mng_notify -DCTCFG_MULTI_DOMAIN_SUPPORT -DFPIVOT_PATH_LOCK -DCONFIG_SET_SWITCH_FC_PARAM_BY_PORT_NUM -DTP_FEATURE_CFG80211 -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/staging_dir/target-arm_cortex-a7_musl-1.1.16_eabi/usr/include/libnl -DTP_FEATURE_ANI_ENHANCE -DTP_FEATURE_ANI_DESENSE_LEVEL_LOWER_BOUND=-5 -DTP_FEATURE_ANI_DESENSE_LEVEL_UPPER_BOUND=25 -DTP_FEATURE_ANI_DESENSE_LEVEL_ERROR_SCALE_MASK=0x00880004 -DTP_FEATURE_ANI_DYNAMIC_EDCCA -DTP_FEATURE_ANI_DYNAMIC_EDCCA_UPPER_BOUND=0x26 -DTP_FEATURE_ANI_DYNAMIC_EDCCA_SCALE_MASK=0x1 -DTP_FEATURE_ANI_DYNAMIC_NF -DTP_FEATURE_ANI_DYNAMIC_NF_THESHOLD=15 -DTMP_WLAN_INFO_SUPPORT -DSUPPORT_ENTER_ART -DCONFIG_LOCAL_MAX_STA_NUM=256 -DCONFIG_REMOTE_MAX_STA_NUM=256 -DCONFIG_MANAGE_MAX_STA_NUM=128 -DCONFIG_TOPOLOGY_MAX_STA_LIMIT=256 -DHOST_NUM_2G=128 -DHOST_NUM_5G=128 -DWLAN_BAND_MAX_STA_NUM=128 -DWAN_MAX_PHY_NUM=1 -DTOPOLOGY_UPDATE_AP_PHY_ATTR_BY_NOTIFY -DCONFIG_RTNL_LOCAL_FDB_HANDLE -DCONFIG_GET_SWITCH_PORT_FLOW_STAT -DCONFIG_SUPPORT_QCA_NSS -DCTCFG_FAC_MAC_BOTH_USE_FOR_LAN_WAN -DCONFIG_DEFAULT_QUERY_ENABLE_VALUE -ffunction-sections -fdata-sections -Werror=implicit-function-declaration -Werror=format-extra-args -Werror=switch -Werror=implicit-int -Werror=return-type -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/build_dir/target-arm_cortex-a7_musl-1.1.16_eabi/dms/include/-I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/staging_dir/target-arm_cortex-a7_musl-1.1.16_eabi/tdmp/usr/include -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/staging_dir/target-arm_cortex-a7_musl-1.1.16_eabi/usr/include -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/staging_dir/target-arm_cortex-a7_musl-1.1.16_eabi/include -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/staging_dir/toolchain-arm_cortex-a7_gcc-5.2.0_musl-1.1.16_eabi/usr/include -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/staging_dir/toolchain-arm_cortex-a7_gcc-5.2.0_musl-1.1.16_eabi/include  -fpic -Wall -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/build_dir/target-arm_cortex-a7_musl-1.1.16_eabi/dms -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/build_dir/target-arm_cortex-a7_musl-1.1.16_eabi/dms/include -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/build_dir/target-arm_cortex-a7_musl-1.1.16_eabi/dms/framework/standardApi -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/staging_dir/target-arm_cortex-a7_musl-1.1.16_eabi/tdmp/usr/include -DcreationDate=&quot;\&quot;Aug 28 2022, 11:13:39\&quot;&quot; -DEXCLUDE_RADIUS -DTP_FEATURE_STEER -DWLAN_DUAL_BAND -DLINUX -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/build_dir/target-arm_cortex-a7_musl-1.1.16_eabi/dms/libs/libct/ct_sohojsonapi/src/soho_json_api_impl/sdmp/include -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/build_dir/target-arm_cortex-a7_musl-1.1.16_eabi/dms/libs/libct/ct_sohosdkapi/src/platform/sdmp/include -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/build_dir/target-arm_cortex-a7_musl-1.1.16_eabi/dms/libs/libct/ct_sohojsonapi/src/include -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/build_dir/target-arm_cortex-a7_musl-1.1.16_eabi/dms/libs/libct/ct_utilitylib/src/include -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/build_dir/target-arm_cortex-a7_musl-1.1.16_eabi/dms/libs/libct/ct_sdk_api/src/platform/sdmp/include -I/var/lib/jenkins/workspace/soho4_tdmp_qca_ax3000_release/torchlight/build_dir/target-arm_cortex-a7_musl-1.1.16_eabi/dms/libs/libct/ct_sdk_api/src/platform/sdmp/soho_json_api_impl/include -c -o specialDial.o specialDial.c</span><br></pre></td></tr></table></figure>

<p>看此很长，但很多是重复项，一般来说，我们需要重点关心的有以下几项：</p>
<ul>
<li><code>-Os</code>，编译优化等级，介于 <code>-O2</code> 和 <code>-O3</code> 之间，如果遇到问题，怀疑是编译器优化造成的，可以将其改为 - O0。</li>
<li><code>-Wa</code>，开启所有警告，平时要重视所有的警告信息。</li>
<li><code>-Wl,-z,now -Wl</code>，两个 <code>-Wl</code>，代表中间的参数是需要传递给链接器的参数。</li>
<li><code>-D</code>，一些宏的定义，一般通过变量 <code>CFLAGS</code> 传进来。</li>
<li><code>-I</code>，头文件的搜索路径，当我们写<code> #include xxx.h</code> 时，编译时需要将<code>xxx.h</code>的路径通过<code> -Ipath</code> 告诉编译器，一般也是通过变量 <code>CFLAGS</code> 传进来的，如果找不到头文件，优先考虑排查这个参数。</li>
<li><code>-o</code>，输出文件的名字</li>
</ul>
<p><strong>ld</strong></p>
<p>以下是 SDMP 平台链接命令，链接生成最终的可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldarm -EL -X -N -gc-sections -e sysInit -Ttext 40205000 D:\jenkins\workspace\soho4_sdmp_mtk_arm_non_smart_router_release/image/mt7626/vxbin/basicRouter/dataSegPad.o D:\jenkins\workspace\soho4_sdmp_mtk_arm_non_smart_router_release/image/mt7626/vxbin/basicRouter/partialImage.o \</span><br><span class="line">D:\jenkins\workspace\soho4_sdmp_mtk_arm_non_smart_router_release/image/mt7626/vxbin/basicRouter/ctdt.o -T D:/jenkins/workspace/Tornado/Toolchain_4.1.2_ARMv7_Build_SDMP_Kernel_Mesh_IPv6_T4/target/h/tool/gnu/ldscripts/link.RAM -o D:\jenkins\workspace\soho4_sdmp_mtk_arm_non_smart_router_release/image/mt7626/vxbin/basicRouter/vxWorks</span><br></pre></td></tr></table></figure>

<p>平时我们基本不会遇到该命令相关的错误，但还是了解一下其中的参数：</p>
<ul>
<li><code>-EL</code>，小端模式，对应的，-EB 为大端模式。</li>
<li><code>-X</code>，不保留临时符号。</li>
<li><code>-gc-sections</code> 去除没有用到的 sections，该选项配合编译选项 - ffunction-sections -fdata-sections，可以去除没有被调用的函数和数据，节省 flash 空间。</li>
<li><code>-e</code> 设置第一个函数。</li>
<li><code>-Ttext 40205000</code> 设置 text 段的其实地址为 0x40205000 。</li>
<li><code>-T</code> <code>D:/jenkins/workspace/Tornado/Toolchain_4.1.2_ARMv7_Build_SDMP_Kernel_Mesh_IPv6_T4/target/h/tool/gnu/ldscripts/link.RAM</code> 链接脚本，链接脚本上文已经有介绍，这里不再介绍。</li>
<li><code>-o</code> <code>D:\jenkins\workspace\soho4_sdmp_mtk_arm_non_smart_router_release/image/mt7626/vxbin/basicRouter/vxWorks</code> 最终生成的文件。</li>
</ul>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>《程序要的自我修养》</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 介绍和命令</title>
    <url>/2021/08/09/OS/OS-Linux-Command/</url>
    <content><![CDATA[<h1 id="查看PID所在的文件夹"><a href="#查看PID所在的文件夹" class="headerlink" title="查看PID所在的文件夹"></a>查看PID所在的文件夹</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /proc/23333  </span><br><span class="line"><span class="built_in">ls</span> -al</span><br></pre></td></tr></table></figure>

<h1 id="1-Ubuntu-Linux-系统的介绍"><a href="#1-Ubuntu-Linux-系统的介绍" class="headerlink" title="1. Ubuntu Linux 系统的介绍"></a>1. Ubuntu Linux 系统的介绍</h1><h2 id="1-1-Linux-操作系统的概述"><a href="#1-1-Linux-操作系统的概述" class="headerlink" title="1.1. Linux 操作系统的概述"></a>1.1. Linux 操作系统的概述</h2><p>Linux 是一种自由和开源的 UNIX 类操作系统，其源代码可以被公开研究、更改和分发。Linux 由芬兰的 Linus Benedict Torvalds 于 1991 年首次发布，其设计遵循了 POSIX 和 Unix 的标准。</p>
<p>Linux 是一个多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 UNIX 工具软件、应用程序和网络协议，也支持 32 位和 64 位硬件。</p>
<p>Linux 的内核原始代码由 Linus Benedict Torvalds 撰写，但现在世界各地的程序员都参与了 Linux 的开发。根据开放源代码的特性，任何人都可以修改和改进 Linux，并且这种改动可以被广泛传播，让其他人也能从中受益。</p>
<h2 id="1-2-Linux-和-Windows-的主要区别"><a href="#1-2-Linux-和-Windows-的主要区别" class="headerlink" title="1.2. Linux 和 Windows 的主要区别"></a>1.2. Linux 和 Windows 的主要区别</h2><p>对于 C 开发者来说，Linux 和 Windows 的主要区别体现在以下几个方面：</p>
<p><strong>开发环境</strong>：Linux 提供了强大的终端和命令行工具，如 Bash Shell、sed、awk、grep 等，这些工具可以极大提高 C 程序员的生产力。另外，Linux 还支持了许多开源的编程工具，如 GCC、GDB、Valgrind 等。而在 Windows，这些工具可能需要额外安装，且可能不提供与 Linux 完全相同的功能。</p>
<p><strong>系统调用和库</strong>：Linux 遵循 POSIX 标准，其系统调用和库与 Unix 和其他 Unix-like 系统（如 macOS）高度兼容。这意味着，基于 POSIX 的 C 程序可以在这些系统之间轻松迁移。而 Windows 的系统调用和库则有很大不同，需要使用 Windows API，这可能导致移植性问题。</p>
<p><strong>文件系统</strong>：Linux 使用区分大小写的文件系统，而 Windows 默认不区分大小写。这可能在处理文件名时造成一些差异。此外，Linux 中所有内容都组织在一个单一的目录树下，包括文件、目录、设备等，这与 Windows 的驱动器字母（如 <code>C:</code>、<code>D:</code>）有很大不同。</p>
<h2 id="1-3-Linux-常见目录结构和作用"><a href="#1-3-Linux-常见目录结构和作用" class="headerlink" title="1.3. Linux 常见目录结构和作用"></a>1.3. Linux 常见目录结构和作用</h2><p>在 Linux 系统中，文件和目录的组织方式遵循了一种标准，称为文件系统层次结构标准（Filesystem Hierarchy Standard，FHS）。理解这些目录结构以及其各自的作用对于有效地使用和管理 Linux 系统是非常重要的。以下是 Linux 中一些最常见的目录及其作用：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>/</code></td>
<td>根目录，所有的目录都从这里开始。</td>
</tr>
<tr>
<td><code>/bin</code></td>
<td>包含了用户级别的基本命令，如 <code>ls</code>、<code>cp</code>、<code>rm</code> 等。</td>
</tr>
<tr>
<td><code>/sbin</code></td>
<td>包含了系统级别的命令，只有 root 用户可以执行。</td>
</tr>
<tr>
<td><code>/etc</code></td>
<td>包含所有系统管理所需要的配置文件和子目录。</td>
</tr>
<tr>
<td><code>/home</code></td>
<td>普通用户的主目录，例如 <code>/home/john</code> 是用户 john 的主目录。</td>
</tr>
<tr>
<td><code>/root</code></td>
<td>root 用户（系统管理员）的主目录。</td>
</tr>
<tr>
<td><code>/var</code></td>
<td>存储着在正常运行中的系统不断增加的文件。</td>
</tr>
<tr>
<td><code>/usr</code></td>
<td>存放和共享只读的数据，包括很多用户级别的应用程序、库等。</td>
</tr>
<tr>
<td><code>/tmp</code></td>
<td>用于存放临时文件，这些文件在系统重启后会被删除。</td>
</tr>
<tr>
<td><code>/lib</code></td>
<td>包含系统最基本的动态链接共享库。</td>
</tr>
<tr>
<td><code>/opt</code></td>
<td>用于存放所有的可选应用软件包。</td>
</tr>
<tr>
<td><code>/dev</code></td>
<td>包含所有的设备文件，硬件设备被视为文件，可以像操作文件一样操作这些设备。</td>
</tr>
</tbody></table>
<h2 id="1-4-Ubuntu-的特点和优势"><a href="#1-4-Ubuntu-的特点和优势" class="headerlink" title="1.4. Ubuntu 的特点和优势"></a>1.4. Ubuntu 的特点和优势</h2><p>Ubuntu 以其易用性、稳定性、丰富的软件和社区支持，以及强大的商业支持赢得了用户的喜爱。不少供应商的 SDK 需要在特定版本的 Ubuntu 下构建，这也是许多公司选择 Ubuntu 的原因之一。公司可以通过维护内部的镜像源，用户可以将 apt 源设置为公司的镜像源，这将显著提升 deb 包的下载速度，有效提高工作效率。</p>
<h2 id="1-5-Ubuntu-的配置"><a href="#1-5-Ubuntu-的配置" class="headerlink" title="1.5. Ubuntu 的配置"></a>1.5. Ubuntu 的配置</h2><p>运行在 VirtualBox 环境下的 Ubuntu 可以通过多种配置技巧来提升开发效率，以下是一些常见的配置方法：</p>
<p><strong>关闭屏幕锁定</strong>：在 Ubuntu 中，屏幕锁定功能可能会在你不操作电脑一段时间后自动启动，这可能会带来一些不便，因此建议关闭屏幕锁定。虽然这样可能会降低一些安全性，但如果你在已经给宿主机设置了密码和屏幕锁定的情况下，则已经处于一个安全的环境中，因此可以关闭虚拟机的屏幕锁定，这可以提高你的工作效率。</p>
<p><strong>安装增强功能套件</strong>：VirtualBox 的 “增强功能套件” 可以提供更好的视频性能，更强大的虚拟机控制，以及文件和文件夹的拖放功能。在 VirtualBox 的 “设备” 菜单中选择 “安装增强功能”，然后在虚拟机中运行自动启动的安装程序。</p>
<p><strong>设置共享文件夹</strong>：在主机和虚拟机之间共享文件可以大大提高工作效率。在 VirtualBox 的设置中，你可以为虚拟机设置一个或多个共享文件夹。</p>
<p><strong>使用双向剪贴板</strong>：在主机和虚拟机之间共享剪贴板可以让你在两个环境中更轻松地复制和粘贴文本。在 VirtualBox 的设置中，选择 “常规”，然后在 “高级” 选项卡中设置 “双向” 剪贴板。</p>
<p><strong>调整处理器分配</strong>：如果你的主机有多个处理器核心，你可以调整虚拟机使用的核心数，以获得更好的性能。在 VirtualBox 的设置中，选择 “系统”，然后在 “处理器” 选项卡中设置核心数。</p>
<p><strong>调整内存分配</strong>：可以调整虚拟机使用的内存数，以获得更好的性能。通常，根据你的电脑的硬件配置和你要运行的任务，你可以设置为你电脑 RAM 的一半。</p>
<p><strong>通过 SSH 连接到虚拟机</strong>：，如果你主要用命令行进行工作，完全可以关闭图形界面以节省资源。你可以通过 SSH 连接到虚拟机，这样可以显著减少内存的使用，从而提高系统的整体性能。建议在熟悉 Samba 和共享文件夹的操作后，有余力和有需要的情况下再开展。下面是如何进行这些操作的步骤：</p>
<ol>
<li><strong>关闭图形界面</strong>：Ubuntu 默认启动图形用户界面，但是我们可以设置为命令行模式，以下是如何设置的步骤：<ul>
<li>打开终端。</li>
<li>输入 <code>sudo systemctl set-default multi-user.target</code> 并回车。你可能需要输入你的密码。</li>
<li>重启你的系统，你会发现系统启动后进入命令行模式。</li>
</ul>
</li>
<li><strong>设置 SSH 连接</strong>：为了远程访问你的 Ubuntu 系统，你需要安装并设置 SSH 服务，以下是如何设置的步骤：</li>
</ol>
<p>在你的 Ubuntu 系统中，打开终端。</p>
<ul>
<li>输入 <code>sudo apt-get update</code> 来更新你的包列表。</li>
<li>输入 <code>sudo apt-get install openssh-server</code> 来安装 SSH 服务器。</li>
<li>输入 <code>sudo systemctl start ssh</code> 来启动 SSH 服务。</li>
<li>输入 <code>sudo systemctl enable ssh</code> 来设置 SSH 服务在启动时自动运行。</li>
</ul>
<p>现在你可以从你的主机或其他电脑通过 SSH 连接到你的 Ubuntu 系统了，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh username@ip-address</span><br></pre></td></tr></table></figure>

<p>其中，username 是你的 Ubuntu 用户名，ip-address 是你的 Ubuntu 系统的 IP 地址。</p>
<ol>
<li><strong>调整内存分配</strong>：现在你可以进一步调整内存分配了。现在你可以设置的更小一些，因为你关闭了图形界面。</li>
</ol>
<p>通过关闭图形界面并使用 SSH 连接，你可以使你的 Ubuntu 虚拟机更高效地使用资源。</p>
<p>如果你之后需要再次使用 Ubuntu 的图形界面，你可以按照以下步骤操作：</p>
<ol>
<li>打开虚拟机内的终端。</li>
<li>输入以下命令并回车：<code>sudo systemctl set-default graphical.target</code>。这将把默认目标设置回图形用户界面。</li>
<li>重启你的系统。你可以输入 <code>sudo reboot</code> 命令并回车来重启你的系统。</li>
</ol>
<p>重启后，你的 Ubuntu 系统会启动到图形用户界面。</p>
<h1 id="2-Ubuntu-Linux-环境的基本操作"><a href="#2-Ubuntu-Linux-环境的基本操作" class="headerlink" title="2. Ubuntu Linux 环境的基本操作"></a>2. Ubuntu Linux 环境的基本操作</h1><h2 id="2-1-Nautilus-文件管理器"><a href="#2-1-Nautilus-文件管理器" class="headerlink" title="2.1. Nautilus 文件管理器"></a>2.1. Nautilus 文件管理器</h2><p>Nautilus 是 Ubuntu 系统中默认的文件管理器，提供了强大的文件浏览和管理功能。</p>
<h3 id="Nautilus-基础用法"><a href="#Nautilus-基础用法" class="headerlink" title="Nautilus 基础用法"></a>Nautilus 基础用法</h3><p>Nautilus 文件管理器允许你浏览和管理文件和目录。你可以通过双击桌面上的 “文件” 图标，或者在 Dash（Ubuntu 默认的应用启动器）中搜索 “文件” 来打开 Nautilus。</p>
<p>Nautilus 的主窗口分为三个主要部分：</p>
<ul>
<li>左侧的边栏显示了你的文件系统的各个位置，包括你的主目录、网络位置、已连接的设备和书签。</li>
<li>中央的主视图显示了当前选定位置的文件和目录。</li>
<li>顶部的工具栏提供了各种文件操作的按钮，如创建新文件夹、改变视图模式、搜索文件等。</li>
</ul>
<h3 id="Nautilus-快捷键"><a href="#Nautilus-快捷键" class="headerlink" title="Nautilus 快捷键"></a>Nautilus 快捷键</h3><p>Nautilus 提供了许多快捷键以便更快速、更有效地进行文件操作。以下是一些常用的快捷键：</p>
<ul>
<li><code>Ctrl+H</code>：显示或隐藏隐藏文件。在 Linux 中，隐藏文件的文件名是以 “.” 开头的。</li>
<li><code>Ctrl+L</code>：高亮地址栏，让你可以输入路径或 URL，这对于访问网络位置非常有用。</li>
<li><code>Ctrl+N</code>：打开新的 Nautilus 窗口。</li>
<li><code>Ctrl+T</code>：在当前 Nautilus 窗口中打开新的标签。</li>
<li><code>Ctrl+W</code>：关闭当前 Nautilus 窗口或标签。</li>
<li><code>Ctrl+D</code>：将当前位置添加到书签。</li>
<li><code>Ctrl+1</code>和 <code>Ctrl+2</code>：在图标视图和列表视图之间切换。</li>
</ul>
<h3 id="通过-SMB-协议访问特定-URL"><a href="#通过-SMB-协议访问特定-URL" class="headerlink" title="通过 SMB 协议访问特定 URL"></a>通过 SMB 协议访问特定 URL</h3><p>Nautilus 支持通过多种协议来访问网络位置，包括 SMB、FTP、SFTP 等。你可以直接在地址栏中输入 URL 来访问这些位置。</p>
<p>以下是通过 SMB 协议访问特定 URL 的步骤：</p>
<ol>
<li>打开 Nautilus 并按 <code>Ctrl+L</code> 来高亮地址栏。</li>
<li>在地址栏中输入 SMB URL，格式为 <code>smb://hostname_or_IP/shared_folder</code>。例如，如果你想访问名为 “file.com” 的主机上的 “Public” 共享文件夹，你应该输入 <code>smb://file.com/Public</code>。</li>
<li>按 Enter 键。如果需要，输入你的用户名和密码，然后点击 “连接”。</li>
</ol>
<p>这样，你就可以在 Nautilus 中浏览和管理 SMB 共享的文件和目录了。</p>
<h2 id="2-2-命令语法"><a href="#2-2-命令语法" class="headerlink" title="2.2. 命令语法"></a>2.2. 命令语法</h2><p>Bash 命令的基本语法是 <code>command [options] [arguments]</code>。</p>
<ul>
<li><code>command</code> 是想要执行的命令的名称。</li>
<li><code>[options]</code> 是可选的，用于修改命令的行为。它们通常以破折号 <code>-</code> 开始。例如，<code>ls -l</code> 中的 <code>-l</code> 是一个选项，它告诉 <code>ls</code> 以列表形式显示文件。</li>
<li><code>[arguments]</code> 也是可选的，它们是命令要操作的对象。例如，<code>cd /path/to/directory</code> 中的 <code>/path/to/directory</code> 是一个参数，它告诉 <code>cd</code> 要切换到哪个目录。</li>
</ul>
<h2 id="2-3-命令提示符"><a href="#2-3-命令提示符" class="headerlink" title="2.3. 命令提示符"></a>2.3. 命令提示符</h2><p>在 Bash shell 中，命令提示符是出现在每行命令前的字符或一组字符。它通常用于提供有关环境或当前状态的信息。</p>
<p>默认的 Bash 命令提示符是一个美元符号 <code>$</code>。对于 root 用户，命令提示符是井号 <code>#</code>。</p>
<p>你可以通过修改 <code>PS1</code> 环境变量来自定义命令提示符。例如，如果你想让命令提示符显示当前目录，你可以输入 <code>export PS1=&#39;\w\$ &#39;</code>。这将使命令提示符显示当前工作目录的完整路径。</p>
<p>你可以通过编辑 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 文件（取决于你的系统和特定的环境）来使改变的命令提示符在每次新开启的 Bash 会话中都自动显示当前目录。</p>
<p>下面是具体步骤：</p>
<ol>
<li>使用文本编辑器打开 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 文件。例如，你可以在 Bash 中输入 <code>nano ~/.bashrc</code> 或 <code>nano ~/.bash_profile</code>。</li>
<li>在文件的末尾添加以下行：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PS1=&#x27;\w\$ &#x27;</span><br></pre></td></tr></table></figure>

<ol>
<li>保存并关闭文件。</li>
<li>为了让改变立即生效，你需要在 Bash 中输入 <code>source ~/.bashrc</code> 或 <code>source ~/.bash_profile</code>。或者，你可以通过关闭并重新打开 Bash 会话来让改变生效。</li>
</ol>
<p>这样，每次新开启的 Bash 会话都将显示当前目录在命令提示符中。</p>
<p>请注意，<code>~/.bashrc</code> 文件通常用于非登录 shell （例如，新打开的终端窗口），而 <code>~/.bash_profile</code> 文件通常用于登录 shell （例如，通过 SSH 登录）。在某些系统中，可能只有其中一个文件存在。如果都存在，可以选择一个进行编辑，或者在 <code>~/.bash_profile</code> 中添加一行 <code>source ~/.bashrc</code>，以确保无论使用哪种类型的 shell，都会读取 <code>~/.bashrc</code> 中的设置。</p>
<h2 id="2-4-系统操作"><a href="#2-4-系统操作" class="headerlink" title="2.4. 系统操作"></a>2.4. 系统操作</h2><p>正确地管理虚拟机的状态是非常重要的，以确保数据的完整性和系统的稳定性。以下是一些关于管理虚拟机状态的建议：</p>
<ol>
<li><strong>保存状态</strong>：在 VirtualBox 中，你可以选择保存虚拟机的当前状态，而不是完全关闭虚拟机。这就像是在物理机上休眠。当你下次启动虚拟机时，它会恢复到你保存状态时的情况。你可以在 VirtualBox 的 “机器” 菜单中选择 “保存状态” 来进行这个操作。</li>
<li><strong>优雅地关机</strong>：如果你需要完全关闭虚拟机，你应该在虚拟机内部执行关机命令，而不是强制关闭虚拟机。在 Ubuntu 中，你可以输入 <code>sudo poweroff</code> 命令来优雅地关机。这会让系统有足够的时间来正确地关闭所有的进程和服务，然后安全地关机。</li>
</ol>
<p>强制关闭虚拟机（就像物理机突然断电一样）可能会导致数据丢失或系统错误。因此，你应该尽量避免这样做，除非你没有其他选择。</p>
<p>通过正确地管理虚拟机的状态，你可以最大限度地保护你的数据，并确保系统的稳定性和可靠性。</p>
<p>如果你的磁盘空间不足，你需要找到占用大量空间的文件或目录。</p>
<ul>
<li>检查磁盘使用情况：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># df = disk free</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>

<ul>
<li>目录大小统计</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># du = disk usage 磁盘使用率</span><br><span class="line">du -sh</span><br><span class="line"># 查看当前目录各级子目录空间占用情况</span><br><span class="line">du -sh .</span><br><span class="line"># 查看当前目录下一级子文件和子目录占用的磁盘容量</span><br><span class="line">du -lh --max-depth=1</span><br></pre></td></tr></table></figure>

<h2 id="2-5-环境变量"><a href="#2-5-环境变量" class="headerlink" title="2.5. 环境变量"></a>2.5. 环境变量</h2><p>在 Linux 操作系统中，环境变量是用户和系统进程之间的一种信息交互方式，它们包含了诸多用于控制系统行为的重要数据。环境变量的值可以在当前 Shell 会话以及其启动的任何子进程中被访问和使用。环境变量可包含诸如软件安装的路径、当前用户的主目录或者可执行文件的默认位置等信息。下面我们将以 PATH 环境变量为例，来讲解如何在 Linux 中定义和修改环境变量。</p>
<p>PATH 是一个在 Linux 和其他 Unix-like 系统中非常关键的环境变量，它决定了 Shell 在哪些目录下查找用户输入的命令。当你在终端输入一个命令，Shell 将在 PATH 变量指定的目录中，依次查找对应的可执行文件。</p>
<p>你可以使用 <code>echo</code> 命令查看当前的 PATH 变量值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

<p>此命令会返回一个由冒号（:）分隔的目录列表，这些目录就是 Shell 查找命令的路径。</p>
<p>如果你想修改 PATH 变量，有两种方式：一种是临时修改，另一种是永久修改。</p>
<p><strong>临时修改</strong>：此种修改方式只在当前的 Shell 会话中有效。当你关闭终端或启动新的 Shell 会话时，修改不会被保存。例如，你可以使用下列命令临时添加一个目录到 PATH 变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/path/to/your/dir</span><br></pre></td></tr></table></figure>

<p>在上述命令中，<code>/path/to/your/dir</code> 是你希望添加的新目录路径。</p>
<p><strong>永久修改</strong>：如果你希望修改的 PATH 变量能在新的 Shell 会话或系统重启后仍然有效，你应该在 Shell 的配置文件中修改 PATH 变量。对于 Bash Shell，你可以在用户的 home 目录下的 <code>.bashrc</code> 或 <code>.bash_profile</code> 文件中修改 PATH 变量。如下所示：</p>
<p>打开 <code>.bashrc</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nano ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>在文件的末尾添加下列行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/path/to/your/dir</span><br></pre></td></tr></table></figure>

<p>保存并关闭文件。然后，你可以通过执行下列命令使更改立即生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>以上就是如何在 Linux 中定义和修改 PATH 环境变量的过程。对于其他环境变量，你可以采取类似的步骤来进行修改和定义。在实际应用中，你应当根据实际需求来设置和使用环境变量。</p>
<h2 id="2-6-文件和目录操作"><a href="#2-6-文件和目录操作" class="headerlink" title="2.6. 文件和目录操作"></a>2.6. 文件和目录操作</h2><p>在 Ubuntu Linux 中，有一系列的命令用于管理文件和目录：</p>
<p>下面是对以上每个命令的详细介绍，包括常见的选项和操作技巧：</p>
<p>**<code>ls</code>**：这个命令用于列出当前目录的内容。常用的选项包括：</p>
<ul>
<li><code>-l</code>：以详细格式列出文件 / 目录信息，包括权限、所有者、大小、修改时间等。</li>
<li><code>-a</code>：显示所有文件，包括隐藏文件（以 <code>.</code> 开头的文件）。</li>
<li><code>-h</code>：以易读的格式显示文件大小（例如，显示 <code>1K</code> <code>234M</code> <code>2G</code>）。</li>
<li><code>-1</code>：以一列的方式显示文件和目录，这在需要清晰看到每个文件和目录时非常有用。</li>
</ul>
<p>例如，<code>ls -lha</code> 会以详细格式列出所有文件，包括隐藏文件，并以易读的格式显示文件大小。</p>
<p>此外，<code>ls</code> 命令可以与管道 <code>|</code> 和 <code>grep</code> 命令结合使用来过滤输出结果。例如，如果你只想列出所有 <code>.txt</code> 文件，你可以使用 <code>ls | grep .txt</code> 命令。这里，<code>grep .txt</code> 会过滤出包含 <code>.txt</code> 的行。</p>
<p>**<code>tree</code>**：这个命令用于以树状图列出目录的内容。常用的选项包括：</p>
<ul>
<li><code>-f</code>：在每个文件或目录前面显示完整的路径前缀。这会使得每个文件名前面都有一个对应的路径。</li>
<li><code>-i</code>：不显示树状图结构。只显示文件和目录的名称。这个选项通常用来提供一个非分层的文件列表。</li>
<li><code>-n</code>：禁止打印文件和目录名的颜色。默认情况下，tree命令会使用颜色来标记文件和目录的类型，例如目录、符号链接、文件等。使用 <code>-n</code> 选项，tree将只以纯文本的形式打印名称。</li>
<li><code>-d</code>：只显示目录，不显示文件。这可以帮助你快速查看目录的结构，而忽略其中的文件。</li>
</ul>
<p>例如，<code>tree -f</code> 会以完整的路径前缀列出所有文件和目录。<code>tree -i</code> 则只显示文件和目录的名称，而不显示它们的结构。</p>
<p>此外，<code>tree</code> 命令可以使用 <code>-P</code> 选项配合通配符，来匹配特定的文件或目录。例如，如果你只想列出所有 <code>.txt</code> 文件，你可以使用 <code>tree -P &#39;*.txt&#39;</code> 命令。这里，<code>-P &#39;*.txt&#39;</code> 会过滤出所有后缀为 <code>.txt</code> 的文件。</p>
<p>**<code>cd</code>**：这个命令用于改变工作目录。你可以使用相对路径或绝对路径。以下是一些常见的使用方式：</p>
<ul>
<li><code>cd Documents</code>：将进入当前目录下的 “Documents” 目录。</li>
<li><code>cd /home/user/Documents</code>：将进入用户主目录下的 “Documents” 目录。</li>
<li><code>cd ..</code>：返回上级目录。</li>
<li><code>cd</code> 或 <code>cd ~</code>：返回用户主目录。</li>
</ul>
<p>此外，如果你想切换到上一次的工作目录，你可以使用 <code>cd -</code> 命令。这个命令会将当前的工作目录切换到上一次的工作目录。例如，如果你当前在 <code>/home/user/Documents</code> 目录，然后你执行 <code>cd /etc</code> 命令进入到 <code>/etc</code> 目录，此时你可以通过执行 <code>cd -</code> 命令快速切换回 <code>/home/user/Documents</code> 目录。</p>
<p>**<code>pwd</code>**：这个命令用于显示当前工作目录的完整路径。它没有额外的选项。</p>
<p>**<code>cp</code>**：这个命令用于复制文件或目录。常用的选项包括：</p>
<ul>
<li><code>-r</code> 或 <code>-R</code>：递归复制，用于复制目录及其内部的所有文件和子目录。</li>
<li><code>-i</code>：在覆盖文件之前提示用户。</li>
<li><code>-v</code>：在复制过程中显示详细信息。</li>
<li><code>-f</code>：强制复制，即如果目标文件已经存在，不会询问用户，直接覆盖。</li>
</ul>
<p>例如，<code>cp -Riv source_dir destination_dir</code> 将复制整个 <code>source_dir</code> 目录（包括其内部的所有文件和子目录）到 <code>destination_dir</code>，并在覆盖文件之前提示用户，同时在过程中显示详细信息。</p>
<p>如果使用 <code>-f</code> 选项，如 <code>cp -Rfv source_dir destination_dir</code>，则在目标目录存在相同文件时，会直接进行覆盖，不会询问用户。</p>
<p>**<code>mv</code>**：这个命令用于移动或重命名文件或目录。常用的选项包括：</p>
<ul>
<li><code>-i</code>：在覆盖文件之前提示用户。</li>
<li><code>-v</code>：在移动过程中显示详细信息。</li>
</ul>
<p>例如，<code>mv -iv old.txt new.txt</code> 将把 <code>old.txt</code> 文件重命名为 <code>new.txt</code>，在覆盖文件之前会提示用户，同时显示详细信息。</p>
<p>**<code>rm</code>**：这个命令用于删除文件或目录。常用的选项包括：</p>
<ul>
<li><code>-r</code> 或 <code>-R</code>：递归删除，用于删除目录及其内部的所有文件和子目录。</li>
<li><code>-i</code>：在删除文件之前提示用户。</li>
<li><code>-v</code>：在删除过程中显示详细信息。</li>
<li><code>-f</code>：强制删除，即不会询问用户，直接删除目标文件或目录。如果文件不存在，也不会显示错误信息。</li>
</ul>
<p>例如，<code>rm -Riv target_dir</code> 将删除整个 <code>target_dir</code> 目录（包括其内部的所有文件和子目录），并在删除文件之前提示用户，同时在过程中显示详细信息。</p>
<p>如果使用 <code>-f</code> 选项，如 <code>rm -Rfv target_dir</code>，则在删除目标目录时，会直接进行删除，不会询问用户。</p>
<p>**<code>mkdir</code>**：这个命令用于创建新目录。常用的选项包括：</p>
<ul>
<li><code>-p</code>：创建多级目录。如果中间的某些目录不存在，会自动创建。</li>
</ul>
<p>例如，<code>mkdir -p Dir/SubDir</code> 将创建一个名为 “Dir” 的目录和一个名为 “SubDir” 的子目录。</p>
<p>**<code>rmdir</code>**：这个命令用于删除空目录。如果一个目录不为空（即，包含其他文件或子目录），则不能用 <code>rmdir</code> 删除。在这种情况下，你需要使用 <code>rm -r</code> 或 <code>rm -R</code> 命令。</p>
<h2 id="2-7-链接"><a href="#2-7-链接" class="headerlink" title="2.7. 链接"></a>2.7. 链接</h2><p>在 Linux 中，链接是一种特殊的文件类型，它允许我们创建对现有文件或目录的引用。链接有两种类型：硬链接和符号链接，也叫软链接。</p>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>硬链接是一个文件在磁盘上的一个引用。一个文件可能有一个以上的硬链接，每个硬链接都对应同一个文件的数据。这意味着，即使原始文件名被删除，只要至少有一个硬链接存在，文件的数据就可以被访问。</p>
<p>我们可以使用 <code>ln</code> 命令来创建硬链接。例如，要为一个名为 <code>file1</code> 的文件创建一个名为 <code>link1</code> 的硬链接，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln file1 link1</span><br></pre></td></tr></table></figure>

<p>虽然硬链接在许多情况下都很有用，但它们也有一些限制。首先，硬链接不能跨文件系统，也就是说，硬链接只能在同一文件系统的文件之间创建。其次，硬链接不能引用目录，只能引用文件。</p>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>符号链接（软链接）是对另一个文件或目录的间接指针。与硬链接不同，符号链接可以跨文件系统，可以链接目录，且它们是包含了目标文件路径的特殊文件。</p>
<p>我们可以使用 <code>ln</code> 命令的 <code>-s</code> 选项来创建符号链接。例如，要为一个名为 <code>file1</code> 的文件创建一个名为 <code>link1</code> 的符号链接，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s file1 link1</span><br></pre></td></tr></table></figure>

<p>与硬链接不同，如果删除了符号链接的目标文件，符号链接将变得无效。此外，符号链接的权限位通常显示为 <code>lrwxrwxrwx</code>，但实际上符号链接的权限由其目标文件的权限决定。</p>
<h3 id="查看链接"><a href="#查看链接" class="headerlink" title="查看链接"></a>查看链接</h3><p>我们可以使用 <code>ls -l</code> 命令来查看文件的链接信息。对于硬链接，<code>ls -l</code> 将显示文件的链接数量；对于符号链接，<code>ls -l</code> 将显示链接的目标文件。</p>
<h3 id="删除链接"><a href="#删除链接" class="headerlink" title="删除链接"></a>删除链接</h3><p>删除链接的方式与删除普通文件相同，使用 <code>rm</code> 命令。需要注意的是，删除一个硬链接不会影响其它链接，只有当所有链接都被删除，文件才会被真正删除。对于符号链接，删除链接不会删除目标文件。</p>
<p>以上就是 Linux 中的链接的基本概念和使用。理解和掌握链接，对于有效地管理和组织文件系统中的文件和目录具有重要意义。</p>
<h2 id="2-8-打包和解压"><a href="#2-8-打包和解压" class="headerlink" title="2.8. 打包和解压"></a>2.8. 打包和解压</h2><h3 id="tar-命令"><a href="#tar-命令" class="headerlink" title="tar 命令"></a>tar 命令</h3><p><code>tar</code>（磁带存档）命令是 Unix 和 Linux 系统中用于文件打包和解压的工具。<code>tar</code> 可以将多个文件和目录打包为一个 <code>tar</code> 文件，也可以将 <code>tar</code> 文件解压到其组成的文件和目录。以下是 <code>tar</code> 命令的一些常用选项和用法：</p>
<p><strong>创建存档</strong>：使用 <code>-c</code> 选项创建新的 <code>tar</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -cvf archive.tar file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>这会创建一个名为 <code>archive.tar</code> 的文件，其中包含 <code>file1.txt</code> 和 <code>file2.txt</code>。</p>
<p><strong>列出存档内容</strong>：使用 <code>-t</code> 选项列出 <code>tar</code> 文件的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -tvf archive.tar</span><br></pre></td></tr></table></figure>

<p>这会列出 <code>archive.tar</code> 文件中的所有文件和目录。</p>
<p><strong>解压存档</strong>：使用 <code>-x</code> 选项解压 <code>tar</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xvf archive.tar</span><br></pre></td></tr></table></figure>

<p>这会解压 <code>archive.tar</code> 文件中的所有文件和目录。</p>
<p><strong>带有 gzip 压缩的存档</strong>：使用 <code>-z</code> 选项创建或解压带有 gzip 压缩的 <code>tar</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -czvf archive.tar.gz file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>这会创建一个 gzip 压缩的 <code>tar</code> 文件 <code>archive.tar.gz</code>，其中包含 <code>file1.txt</code> 和 <code>file2.txt</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xzvf archive.tar.gz</span><br></pre></td></tr></table></figure>

<p>这会解压 gzip 压缩的 <code>tar</code> 文件 <code>archive.tar.gz</code>。</p>
<p><strong>带有 bzip2 压缩的存档</strong>：使用 <code>-j</code> 选项创建或解压带有 bzip2 压缩的 <code>tar</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -cjvf archive.tar.bz2 file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>这会创建一个 bzip2 压缩的 <code>tar</code> 文件 <code>archive.tar.bz2</code>，其中包含 <code>file1.txt</code> 和 <code>file2.txt</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xjvf archive.tar.bz2</span><br></pre></td></tr></table></figure>

<p>这会解压 bzip2 压缩的 <code>tar</code> 文件 <code>archive.tar.bz2</code>。</p>
<p>在上述选项中，<code>v</code> 是可选的，它表示 “verbose”（详细），如果使用该选项，<code>tar</code> 命令会打印正在进行的操作。</p>
<p><code>tar</code> 命令是一个非常重要的工具，对于文件的打包和解压，以及和其他系统的文件交换，它都是非常有用的。</p>
<h3 id="unzip-命令"><a href="#unzip-命令" class="headerlink" title="unzip 命令"></a>unzip 命令</h3><p><code>unzip</code> 是一个在 Unix 和 Linux 系统中用于解压缩 ZIP 文件的命令。以下是 <code>unzip</code> 命令的一些常用选项和用法：</p>
<p><strong>解压缩 ZIP 文件</strong>：不带任何选项，直接使用 <code>unzip</code> 命令可以解压缩 ZIP 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip archive.zip</span><br></pre></td></tr></table></figure>

<p>这会解压缩 <code>archive.zip</code> 文件中的所有文件和目录到当前目录。</p>
<p><strong>列出 ZIP 文件内容</strong>：使用 <code>-l</code> 选项可以列出 ZIP 文件的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip -l archive.zip</span><br></pre></td></tr></table></figure>

<p>这会列出 <code>archive.zip</code> 文件中的所有文件和目录，但不会解压缩。</p>
<p><strong>解压缩到指定目录</strong>：使用 <code>-d</code> 选项可以解压缩 ZIP 文件到指定目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip archive.zip -d /path/to/directory</span><br></pre></td></tr></table></figure>

<p>这会解压缩 <code>archive.zip</code> 文件到 <code>/path/to/directory</code> 目录。</p>
<p><strong>测试 ZIP 文件</strong>：使用 <code>-t</code> 选项可以测试 ZIP 文件的完整性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip -t archive.zip</span><br></pre></td></tr></table></figure>

<p>这会检查 <code>archive.zip</code> 文件中的所有文件是否完整。</p>
<p><code>unzip</code> 命令是一个非常重要的工具，对于处理 ZIP 文件，无论是解压缩还是检查 ZIP 文件的完整性，它都是非常有用的。</p>
<h2 id="2-9-文本文件的操作"><a href="#2-9-文本文件的操作" class="headerlink" title="2.9. 文本文件的操作"></a>2.9. 文本文件的操作</h2><p>在 Ubuntu Linux 中，有几种方法可以查看文本文件的内容：</p>
<ul>
<li><code>cat</code>：显示文件的全部内容。例如，<code>cat file.txt</code> 会显示 <code>file.txt</code> 的全部内容。</li>
<li><code>more</code> 或 <code>less</code>：用分页的方式显示文件内容。例如，<code>more file.txt</code> 或 <code>less file.txt</code> 会以分页方式显示 <code>file.txt</code>。</li>
<li><code>tail</code>：显示文件的最后几行。例如，<code>tail file.txt</code> 会显示 <code>file.txt</code> 的最后 10 行。</li>
<li><code>head</code>：显示文件的前几行。例如，<code>head file.txt</code> 会显示 <code>file.txt</code> 的前 10 行。</li>
</ul>
<h2 id="2-10-计算哈希值"><a href="#2-10-计算哈希值" class="headerlink" title="2.10. 计算哈希值"></a>2.10. 计算哈希值</h2><p>在 Unix 和 Linux 系统中，可以使用 <code>md5sum</code> 和 <code>sha256sum</code> 命令计算文件的 MD5 和 SHA-256 哈希值。这些命令可以用于验证文件的完整性和验证下载的文件是否被篡改。</p>
<p><strong>计算文件的 MD5 哈希值</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">md5sum file.txt</span><br></pre></td></tr></table></figure>

<p>这将返回 <code>file.txt</code> 的 MD5 哈希值。</p>
<p><strong>计算文件的 SHA-256 哈希值</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sha256sum file.txt</span><br></pre></td></tr></table></figure>

<p>这将返回 <code>file.txt</code> 的 SHA-256 哈希值。</p>
<p>注意：上述命令输出的哈希值应该与预期的哈希值或提供者给出的哈希值匹配，以确保文件完整性和防止篡改。如果两个哈希值不匹配，那么文件可能已经被更改或损坏。</p>
<h2 id="2-11-编程和系统管理"><a href="#2-11-编程和系统管理" class="headerlink" title="2.11. 编程和系统管理"></a>2.11. 编程和系统管理</h2><p>在编程和系统管理中，还常用如下命令：</p>
<ul>
<li>diff 命令</li>
</ul>
<p><code>diff</code> 命令用于比较两个文件的不同点。这对于查看两个版本的文件之间的差异非常有用。例如，你可以使用以下命令比较 <code>file1</code> 和 <code>file2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff file1 file2</span><br></pre></td></tr></table></figure>

<p>这将输出 <code>file1</code> 和 <code>file2</code> 之间的所有差异。</p>
<ul>
<li>vimdiff 命令</li>
</ul>
<p><code>vimdiff</code> 是 <code>vim</code> 文本编辑器的一个模式，用于显示两个或多个文件的差异。它的使用方式和 <code>diff</code> 类似，但它提供了一个交互式的界面，可以更方便地浏览和编辑差异。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vimdiff file1 file2</span><br></pre></td></tr></table></figure>

<p>这将在 <code>vim</code> 中打开 <code>file1</code> 和 <code>file2</code>，并在分割的窗口中显示它们的差异。</p>
<ul>
<li>patch 命令</li>
</ul>
<p><code>patch</code> 命令用于将由 <code>diff</code> 生成的差异应用到文件中。这对于应用别人的更改或撤销自己的更改非常有用。例如，如果你有一个 <code>file.diff</code> 包含了 <code>file</code> 的一些更改，你可以使用以下命令应用这些更改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patch file file.diff</span><br></pre></td></tr></table></figure>

<p>这将应用 <code>file.diff</code> 中的所有更改到 <code>file</code> 中。</p>
<ul>
<li>file 命令</li>
</ul>
<p><code>file</code> 命令用于确定文件类型。这个命令对于查看未知文件的信息非常有用。它不仅可以识别文本文件，还可以识别二进制文件，如程序可执行文件。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file myscript.sh</span><br></pre></td></tr></table></figure>

<p>这将告诉你 <code>myscript.sh</code> 是什么类型的文件。</p>
<h2 id="2-12-输入输出重定向"><a href="#2-12-输入输出重定向" class="headerlink" title="2.12. 输入输出重定向"></a>2.12. 输入输出重定向</h2><p>在 Unix 和 Linux 系统中，<code>&gt;</code>、<code>&gt;&gt;</code>、<code>&lt;</code> 和 <code>&lt;&lt;</code> 是用于输入输出重定向的操作符。这些操作符可以帮助你将命令的输出写入文件，或者从文件中读取输入。</p>
<ul>
<li><code>&gt;</code>：这个操作符将命令的输出重定向到一个文件。如果文件已经存在，它会被覆盖。例如，<code>echo Hello &gt; file.txt</code> 会将 “Hello” 写入 <code>file.txt</code>，如果 <code>file.txt</code> 已经存在，它的内容会被 “Hello” 替换。</li>
<li><code>&gt;&gt;</code>：这个操作符将命令的输出追加到一个文件。如果文件已经存在，新的内容会被添加到文件的末尾。例如，<code>echo Hello &gt;&gt; file.txt</code> 会将 “Hello” 添加到 <code>file.txt</code> 的末尾。</li>
<li><code>&lt;</code>：这个操作符将文件的内容作为命令的输入。例如，<code>sort &lt; file.txt</code> 会将 <code>file.txt</code> 的内容排序。</li>
<li><code>&lt;&lt;</code>：这个操作符用于创建一个 “here-document”。”here-document” 是一个在 shell 脚本中使用的输入重定向方式，它可以将多行的输入重定向到一个命令。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt; EOF</span><br><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>这个命令会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure>

<p><code>EOF</code> 是 “End of File” 的缩写，它是 “here-document” 的结束标志。你可以使用其他的单词作为结束标志，但 <code>EOF</code> 是最常见的。在 <code>&lt;&lt; EOF</code> 和 <code>EOF</code> 之间的所有行都会被视为输入内容。</p>
<p>在 C 程序中，<code>scanf</code> 函数用于从标准输入（通常是键盘）读取数据。你可以使用输入重定向操作符（<code>&lt;</code>）将文件的内容作为输入提供给 <code>scanf</code> 函数。</p>
<p>例如，假设你有一个 C 程序 <code>program.c</code>，它使用 <code>scanf</code> 函数读取两个整数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    scanf (&quot;% d % d&quot;, &amp;a, &amp;b);</span><br><span class="line">    printf (&quot;You entered: % d and % d</span><br><span class="line">&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以先编译这个程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc program.c -o program</span><br></pre></td></tr></table></figure>

<p>然后，你可以创建一个包含两个整数的文件 <code>input.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;123 456&quot; &gt; input.txt</span><br></pre></td></tr></table></figure>

<p>最后，你可以使用输入重定向操作符将 <code>input.txt</code> 的内容作为输入提供给 <code>program</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./program &lt; input.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You entered: 123 and 456</span><br></pre></td></tr></table></figure>

<p>这说明 <code>scanf</code> 函数已经成功地从 <code>input.txt</code> 中读取了两个整数。这种方法对于需要大量输入或者需要重复测试的情况非常有用。</p>
<h2 id="2-13-剪切"><a href="#2-13-剪切" class="headerlink" title="2.13. 剪切"></a>2.13. 剪切</h2><p><code>cut</code> 是一个在 Linux 和 Unix 系统中常用的命令行工具，它用于从文件或标准输入中提取或 “剪切” 出列的部分。<code>cut</code> 命令主要用于处理文本数据，特别是处理分隔符分隔的数据。下面是一些常用的 <code>cut</code> 命令选项以及使用示例。</p>
<p>cut 命令的选项：</p>
<ul>
<li><code>-d</code>：指定字段的分隔符，默认为制表符。例如，<code>-d &#39;:&#39;</code> 会设置分隔符为冒号。</li>
<li><code>-f</code>：指定要显示的字段。例如，<code>-f 1</code> 会显示第一个字段，<code>-f 1,3</code> 会显示第一个和第三个字段，<code>-f 1-3</code> 会显示第一到第三个字段。</li>
<li><code>-c</code>：指定要显示的字符。例如，<code>-c 1-10</code> 会显示每行的第一到第十个字符。</li>
</ul>
<p>cut 命令的使用示例：</p>
<p>假设有一个文件 <code>users.txt</code>，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alice:secret:1000:1000:Alice:/home/alice:/bin/bash</span><br><span class="line">bob:secret:1001:1001:Bob:/home/bob:/bin/bash</span><br></pre></td></tr></table></figure>

<p>以下是一些 <code>cut</code> 命令的使用示例：</p>
<ol>
<li>获取用户名：<code>cut -d &#39;:&#39; -f 1 users.txt</code>。这个命令会显示 <code>users.txt</code> 文件中的每一行的第 1 个字段，即用户名。</li>
<li>获取用户 ID：<code>cut -d &#39;:&#39; -f 3 users.txt</code>。这个命令会显示 <code>users.txt</code> 文件中的每一行的第 3 个字段，即用户 ID。</li>
<li>获取用户名和用户 ID：<code>cut -d &#39;:&#39; -f 1,3 users.txt</code>。这个命令会显示 <code>users.txt</code> 文件中的每一行的第 1 个和第 3 个字段，即用户名和用户 ID。</li>
</ol>
<p>以上就是 <code>cut</code> 命令的基本用法。在处理文本文件时，<code>cut</code> 命令是一个非常有用的工具。</p>
<h2 id="2-14-排序和去重"><a href="#2-14-排序和去重" class="headerlink" title="2.14. 排序和去重"></a>2.14. 排序和去重</h2><h3 id="sort-命令"><a href="#sort-命令" class="headerlink" title="sort 命令"></a>sort 命令</h3><p><code>sort</code> 的主要功能是对输入行进行排序。<code>sort</code> 可以基于字符串或数字排序，也可以基于字段排序。以下是一些常用的 <code>sort</code> 命令选项：</p>
<ul>
<li><code>-n</code>：基于数字值进行排序。</li>
<li><code>-r</code>：反向排序，即降序排序。</li>
<li><code>-k</code>：按照指定的字段进行排序。</li>
</ul>
<p>以下是一个 <code>sort</code> 命令的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort -n -k 2 file.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会按照 <code>file.txt</code> 文件中的第2个字段进行数字排序。</p>
<h3 id="uniq-命令"><a href="#uniq-命令" class="headerlink" title="uniq 命令"></a>uniq 命令</h3><p><code>uniq</code> 的主要功能是从输入中过滤掉重复的行。<code>uniq</code> 命令通常与 <code>sort</code> 命令结合使用，因为 <code>uniq</code> 只能检测相邻的重复行。以下是一些常用的 <code>uniq</code> 命令选项：</p>
<ul>
<li><code>-d</code>：仅显示重复出现的行。</li>
<li><code>-u</code>：仅显示非重复的行。</li>
<li><code>-c</code>：显示每行在输入文件中出现的次数。</li>
</ul>
<p>以下是一个 <code>uniq</code> 命令的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort file.txt | uniq</span><br></pre></td></tr></table></figure>

<p>这个命令会先对 <code>file.txt</code> 文件进行排序，然后通过 <code>uniq</code> 删除所有重复的行。</p>
<p><code>uniq</code> 和 <code>sort</code> 命令都是处理文本文件的强大工具，它们可以帮助你进行数据清理和预处理，特别是在处理大量数据时。</p>
<h2 id="2-15-统计"><a href="#2-15-统计" class="headerlink" title="2.15. 统计"></a>2.15. 统计</h2><p><code>wc</code>（word count）命令是一个常用的 Unix/Linux 命令，它用于计算文本文件中的字节数、字数、行数。该命令接收文件名作为参数，然后返回三个值：行数、字数和字节数。</p>
<p><code>wc</code> 的常用选项包括：</p>
<ul>
<li><code>-l</code>：仅打印行数。</li>
<li><code>-w</code>：仅打印字数。</li>
<li><code>-c</code>：仅打印字节数。</li>
</ul>
<p>以下是一些常见的 <code>wc</code> 命令使用示例：</p>
<p><strong>计算文件的行数、字数和字节数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc file.txt</span><br></pre></td></tr></table></figure>

<p>这将返回三个值：<code>file.txt</code> 的行数、字数和字节数。</p>
<p><strong>仅计算文件的行数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc -l file.txt</span><br></pre></td></tr></table></figure>

<p>这将返回 <code>file.txt</code> 的行数。</p>
<p><strong>仅计算文件的字数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc -w file.txt</span><br></pre></td></tr></table></figure>

<p>这将返回 <code>file.txt</code> 的字数。</p>
<p><strong>仅计算文件的字节数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc -c file.txt</span><br></pre></td></tr></table></figure>

<p>这将返回 <code>file.txt</code> 的字节数。</p>
<h2 id="2-16-搜索和替换"><a href="#2-16-搜索和替换" class="headerlink" title="2.16. 搜索和替换"></a>2.16. 搜索和替换</h2><p>在 Linux 系统中，有许多强大的命令行工具可以帮助你进行搜索和替换操作，包括但不限于 <code>grep</code>、<code>sed</code>、<code>awk</code>、<code>find</code> 等。下面是一些详细的使用这些工具进行搜索和替换的方法：</p>
<h3 id="使用-grep-进行搜索"><a href="#使用-grep-进行搜索" class="headerlink" title="使用 grep 进行搜索"></a>使用 <code>grep</code> 进行搜索</h3><p><code>grep</code> 命令是一个强大的文本搜索工具，它可以在文件或者标准输入（stdin）中搜索与指定模式相匹配的行。例如，下面的命令会在 <code>file.txt</code> 文件中搜索包含 ‘pattern’ 的所有行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;pattern&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>这个命令将会在终端输出所有包含 ‘pattern’ 的行。但是，如果匹配的内容非常多，直接在终端显示可能会导致结果淹没在信息之中，影响查看。在这种情况下，你可以考虑将输出结果重定向到一个文件中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;pattern&#x27; file.txt &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会将所有包含 ‘pattern’ 的行输出到 <code>output.txt</code> 文件中，如果 <code>output.txt</code> 文件已经存在，这个命令会覆盖原有的文件内容。如果你想保留原有内容，可以使用 <code>&gt;&gt;</code> 追加内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;pattern&#x27; file.txt &gt;&gt; output.txt</span><br></pre></td></tr></table></figure>

<p>此外，你还可以使用 <code>-r</code>（或 <code>--recursive</code>）选项在目录及其子目录中递归搜索，或者使用 <code>-i</code>（或 <code>--ignore-case</code>）选项忽略大小写。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -r &#x27;pattern&#x27; /path/to/directory &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会从 <code>/path/to/directory</code> 开始，递归搜索所有文件中包含 ‘pattern’ 的行，并将结果输出到 <code>output.txt</code> 文件中。</p>
<p>请注意，<code>grep</code> 命令还有许多其他选项，可以提供更多的搜索功能，例如只显示匹配数量（<code>-c</code>）、显示行号（<code>-n</code>）、使用 Perl 正则表达式（<code>-P</code>）等等。你可以通过 <code>man grep</code> 或 <code>grep --help</code> 来查看更多信息。</p>
<h3 id="使用-sed-进行替换"><a href="#使用-sed-进行替换" class="headerlink" title="使用 sed 进行替换"></a>使用 <code>sed</code> 进行替换</h3><p><code>sed</code> 是一个流编辑器，它可以对输入流（文件或者其他命令的输出）进行处理。最常见的用法之一是进行替换操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed&#x27;s/pattern/replacement/g&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会将 <code>file.txt</code> 中的 ‘pattern’ 替换为 ‘replacement’。这里的 <code>g</code> 表示全局替换，如果去掉 <code>g</code>，只会替换每一行的第一个匹配。</p>
<p><code>sed</code> 的 <code>-i</code> 选项是 <code>sed</code> 命令中的一个非常重要的选项，用于直接修改文件。在没有 <code>-i</code> 选项的情况下，<code>sed</code> 命令会将修改后的结果输出到标准输出（通常是终端或其他命令），原文件保持不变。如果你添加了 <code>-i</code> 选项，<code>sed</code> 将直接修改文件。</p>
<p>例如，下面的命令会将 <code>file.txt</code> 中的 ‘pattern’ 替换为 ‘replacement’，并且直接修改 <code>file.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i&#x27;s/pattern/replacement/g&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>在使用 <code>-i</code> 选项时，你可以提供一个扩展名，<code>sed</code> 会创建一个带有该扩展名的备份文件。例如，下面的命令会将 <code>file.txt</code> 中的 ‘pattern’ 替换为 ‘replacement’，并且创建一个名为 <code>file.txt.bak</code> 的备份文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i.bak&#x27;s/pattern/replacement/g&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>这在你想保留原始文件的情况下非常有用。</p>
<p>同样，你可以用 <code>-i</code> 选项与 <code>find</code> 命令结合，批量修改多个文件。例如，下面的命令会在当前目录及其子目录中的所有 <code>.txt</code> 文件中，将 ‘pattern’ 替换为 ‘replacement’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.txt&quot; -exec sed -i&#x27;s/pattern/replacement/g&#x27; &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>&#123;&#125;</code> 是 <code>find</code> 找到的每个文件的占位符，<code>\;</code> 表示 <code>-exec</code> 选项的结束。</p>
<h3 id="使用-awk-进行更复杂的处理"><a href="#使用-awk-进行更复杂的处理" class="headerlink" title="使用 awk 进行更复杂的处理"></a>使用 <code>awk</code> 进行更复杂的处理</h3><p><code>awk</code> 是一个强大的文本处理工具，它可以对输入的每一行进行更复杂的处理。例如，下面的命令会打印 <code>file.txt</code> 中包含 ‘pattern’ 的行的第一列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;/pattern/ &#123;print $1&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>在 <code>awk</code> 命令中，<code>&#123;print $1&#125;</code> 的含义是：对于每一行，打印第一列的内容。</p>
<p>在 <code>awk</code> 中，<code>$0</code> 表示整行的内容，<code>$1</code> 表示第一列的内容，<code>$2</code> 表示第二列的内容，以此类推。列的默认分隔符是空格或者制表符，但你可以使用 <code>-F</code> 选项指定其他的分隔符。</p>
<p>所以，<code>awk &#39;/pattern/ &#123;print $1&#125;&#39; file.txt</code> 这个命令的意思是：对 <code>file.txt</code> 的每一行，如果这一行包含 ‘pattern’，就打印这一行的第一列。例如，如果 <code>file.txt</code> 的内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apple fruit</span><br><span class="line">banana food</span><br><span class="line">cherry delicious</span><br></pre></td></tr></table></figure>

<p>那么 <code>awk &#39;/fruit/ &#123;print $1&#125;&#39; file.txt</code> 会输出 <code>apple</code>，因为 ‘fruit’ 是 <code>apple</code> 这一行的第二列。</p>
<p><code>print</code> 是 <code>awk</code> 的一个内建函数。它用于输出文本。在 <code>awk</code> 脚本中，<code>print</code> 通常被用来显示处理过的数据。</p>
<p>例如，在 <code>awk &#39;&#123;print $1&#125;&#39; file.txt</code> 这个命令中，<code>&#123;print $1&#125;</code> 是一个 <code>awk</code> 动作。这个动作告诉 <code>awk</code> 对每一行执行 <code>print $1</code> 操作，也就是打印每一行的第一列。</p>
<p><code>awk</code> 还有许多其他的内建函数，例如 <code>length</code>（返回字符串的长度）、<code>sub</code>（在字符串中进行替换）、<code>split</code>（将字符串分割成数组）等。你可以使用这些函数进行复杂的文本处理。</p>
<h3 id="使用-find-搜索文件"><a href="#使用-find-搜索文件" class="headerlink" title="使用 find 搜索文件"></a>使用 <code>find</code> 搜索文件</h3><p><code>find</code> 是一个在目录中搜索文件的工具。例如，下面的命令会在当前目录及其子目录中搜索所有 <code>.txt</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>



<h3 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h3><p>你可以使用管道符（<code>|</code>）将这些命令组合起来，实现更复杂的操作。例如，下面的命令会在当前目录及其子目录中的所有 <code>.txt</code> 文件中搜索 ‘pattern’，然后将 ‘pattern’ 替换为 ‘replacement’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.txt&quot; -exec grep -l &#x27;pattern&#x27; &#123;&#125; \; | xargs sed -i&#x27;s/pattern/replacement/g&#x27;</span><br></pre></td></tr></table></figure>

<p>这个命令首先使用 <code>find</code> 和 <code>grep</code> 找到包含 ‘pattern’ 的文件，然后使用 <code>xargs</code> 和 <code>sed</code> 将这些文件中的 ‘pattern’ 替换为 ‘replacement’。</p>
<p>这些只是 Linux 命令行工具的基本用法，通过灵活地组合这些工具，你可以实现几乎所有的文本处理任务。</p>
<h2 id="2-17-权限与所有权管理"><a href="#2-17-权限与所有权管理" class="headerlink" title="2.17. 权限与所有权管理"></a>2.17. 权限与所有权管理</h2><p>在 Unix-like 操作系统中，每个文件和目录都有一组权限与所有权，这些权限由三个主体（所有者、用户组和其他用户）以及三种权限（读、写和执行）构成。每个文件或目录都有一个所有者和一个所属的用户组。所有者、用户组和其他用户的权限可以被分别设置，允许的操作分别为读（r）、写（w）和执行（x）。这些权限可以被表示为数字：</p>
<ul>
<li>读取权限（r）：4</li>
<li>写入权限（w）：2</li>
<li>执行权限（x）：1</li>
<li>无任何权限：0</li>
</ul>
<p>可以使用 <code>ls -l</code> 命令查看文件或目录的所有者、所属用户组和权限，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l myfile.txt</span><br></pre></td></tr></table></figure>

<p>返回的结果可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 user group 0 Jul 18 08:30 myfile.txt</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>user</code> 是所有者，<code>group</code> 是所属用户组，而 <code>-rw-r--r--</code> 是权限的表达式。在权限表达式中，第一位 <code>-</code> 表示这是一个文件（如果是 <code>d</code> 则表示这是一个目录），之后的九个字符三个一组（<code>rwx</code>）分别表示所有者、用户组和其他用户的权限。</p>
<p><code>chmod</code> 命令可以用来更改文件或目录的权限。例如，命令 <code>chmod u+x myfile.txt</code> 会给文件的所有者添加执行权限。权限也可以用三个数字表示，如 <code>chmod 755 myfile.txt</code> 将设置文件所有者的权限为读、写、执行，而所属的用户组和其他用户的权限则被设置为读、执行。</p>
<p><code>chown</code> 和 <code>chgrp</code> 命令可以用来更改文件或目录的所有者和所属的用户组。例如，<code>chown newuser myfile.txt</code> 和 <code>chgrp newgroup myfile.txt</code>。</p>
<p>具体使用场景中，<code>chmod</code> 命令的实用性是非常广泛的：</p>
<ol>
<li><strong>设置脚本为可执行</strong>：如 <code>chmod +x script.sh</code> 会给 <code>script.sh</code> 文件添加可执行权限。</li>
<li><strong>限制对敏感文件的访问</strong>：如 <code>chmod 600 secret.txt</code> 会设置 <code>secret.txt</code> 文件的权限，使得只有文件所有者可以进行读写操作。</li>
<li><strong>处理 Samba 权限问题</strong>：如 <code>chmod -x file.txt</code> 将去除 <code>file.txt</code> 文件的所有可执行权限。</li>
</ol>
<p>以上是 Unix-like 操作系统中文件和目录的权限与所有权管理的基本知识。我们可以通过理解和运用这些知识，有效地控制在系统中的文件和目录的访问权限，提高系统的安全性。</p>
<h2 id="2-18-进程管理和系统监控"><a href="#2-18-进程管理和系统监控" class="headerlink" title="2.18. 进程管理和系统监控"></a>2.18. 进程管理和系统监控</h2><p>在 Unix 和 Linux 系统中，进程管理和系统监控是非常重要的。以下是一些常用的命令和操作：</p>
<h3 id="2-18-1-查看进程"><a href="#2-18-1-查看进程" class="headerlink" title="2.18.1. 查看进程"></a>2.18.1. 查看进程</h3><p><code>top</code> 命令可以显示系统中的进程和它们的状态。使用 <code>top</code> 可以查看哪些进程在使用 CPU 或内存。<code>htop</code> 是 <code>top</code> 的一个增强版本，它提供了一个颜色的界面，并且可以直接用键盘进行交互。</p>
<h3 id="2-18-2-结束进程"><a href="#2-18-2-结束进程" class="headerlink" title="2.18.2. 结束进程"></a>2.18.2. 结束进程</h3><p>如果你需要结束一个进程，你可以使用 <code>kill</code> 命令。例如，<code>kill 12345</code> 将结束 PID 为 12345 的进程。</p>
<p><code>kill</code> 的 <code>-9</code> 选项是 <code>kill</code> 命令中的一种信号。在 Linux 中，每个信号都有一个名字和一个对应的数字。<code>-9</code> 对应的信号名字是 <code>SIGKILL</code>。当 <code>kill</code> 命令发送 <code>SIGKILL</code> 信号给一个进程时，它会立即结束该进程，进程没有机会进行任何清理操作。</p>
<p>如果你需要结束一个进程，并且该进程不响应正常的结束信号（例如 <code>SIGTERM</code>，对应的数字是 <code>-15</code>），你可以使用 <code>-9</code> 选项。例如，<code>kill -9 12345</code> 会立即结束 PID 为 12345 的进程。注意，虽然 <code>-9</code> 选项可以立即结束进程，但它也可能会导致数据丢失或其他问题，因为进程没有机会进行清理操作。因此，你应该尽量避免使用 <code>-9</code> 选项，除非你没有其他选择。</p>
<p><code>find</code> 和 <code>grep</code> 是两个非常强大的命令，你可以用它们来查找文件和过滤输出。如果你想要查找并结束一个特定的进程，你可以这样做：</p>
<ol>
<li>使用 <code>ps</code> 命令列出所有进程。</li>
<li>使用 <code>grep</code> 命令过滤出你想要结束的进程。</li>
<li>使用 <code>awk</code> 命令提取出进程的 PID。</li>
<li>使用 <code>kill</code> 命令结束该进程。</li>
</ol>
<p>例如，如果你想要结束所有名为 firefox 的进程，你可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -9 $(ps aux | grep firefox | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p>这个命令的意思是：</p>
<ol>
<li><code>ps aux</code>：列出所有进程。</li>
<li><code>grep firefox</code>：过滤出名为 firefox 的进程。</li>
<li><code>grep -v grep</code>：删除包含 <code>grep</code> 的行，因为我们不想要结束 <code>grep</code> 命令自身。</li>
<li><code>awk &#39;&#123;print $2&#125;&#39;</code>：提取出第二列，即 PID。</li>
<li><code>kill -9</code>：结束这些进程。</li>
</ol>
<p>你也可以使用 <code>killall</code> 命令结束所有名字相同的进程，例如，<code>killall firefox</code> 会结束所有名为 firefox 的进程。</p>
<p><code>kill</code> 和 <code>killall</code> 这两个命令都可以添加 <code>-9</code> 选项（或其他的信号选项）来发送特定的信号。</p>
<h3 id="2-18-3-查看进程状态"><a href="#2-18-3-查看进程状态" class="headerlink" title="2.18.3. 查看进程状态"></a>2.18.3. 查看进程状态</h3><p><code>ps</code> 命令是一个非常强大的工具，可以查看和控制系统中运行的进程。<code>ps aux</code> 会显示所有的进程，并包括各种详细信息，如 PID、CPU 使用率、内存使用率、所属用户等。但是，当进程数量较多时，直接运行 <code>ps aux</code> 可能会返回过多的结果，这时就需要依赖其他工具，如 <code>grep</code>，来过滤和搜索具体的进程。</p>
<p><code>grep</code> 是一个用于文本搜索的命令行工具，它可以从输入中筛选出包含（或不包含）特定模式的行。当与 <code>ps</code> 命令结合使用时，你可以快速定位特定的进程。</p>
<p>例如，如果你想要查找所有名为 firefox 的进程，你可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps aux | grep firefox</span><br></pre></td></tr></table></figure>

<p>这个命令会列出所有名为 firefox 的进程。<code>|</code> 是一个管道符，它会把 <code>ps aux</code> 的输出作为 <code>grep firefox</code> 的输入。因此，最后的结果只会包含名为 firefox 的进程。</p>
<p>有时，你会发现 <code>grep</code> 命令自身也出现在了结果中。如果你想要排除 <code>grep</code> 命令，你可以再加一个 <code>grep</code> 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps aux | grep firefox | grep -v grep</span><br></pre></td></tr></table></figure>

<p>这个命令会排除所有包含 <code>grep</code> 的行。</p>
<p><code>ps</code> 和 <code>grep</code> 的结合应用非常广泛，常常用于系统监控、故障排查等场景。另外，<code>ps</code> 命令还可以与其他命令结合使用，例如 <code>awk</code>（用于文本处理）、<code>sort</code>（用于排序输出结果）等，可以实现更复杂的操作。</p>
<h3 id="2-18-4-查看-proc-中的信息"><a href="#2-18-4-查看-proc-中的信息" class="headerlink" title="2.18.4. 查看 /proc 中的信息"></a>2.18.4. 查看 /proc 中的信息</h3><p><code>/proc</code> 是一个虚拟的文件系统，它包含了关于系统和进程的信息。例如，<code>/proc/cpuinfo</code> 包含了关于 CPU 的信息，<code>/proc/meminfo</code> 包含了关于内存的信息，<code>/proc/PID</code> 包含了关于 PID 进程的信息。</p>
<p>确实，<code>/proc</code> 文件系统是一个具有大量信息的宝库，包含了关于系统和正在运行的进程的许多详细信息。你可以使用 <code>cat</code> 命令来查看这些文件的内容。</p>
<h4 id="查看-CPU-信息"><a href="#查看-CPU-信息" class="headerlink" title="查看 CPU 信息"></a>查看 CPU 信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<p>这将显示关于系统 CPU 的详细信息，例如型号，厂商，核数等。</p>
<h4 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure>

<p>这将显示关于系统内存的详细信息，例如总内存，可用内存，缓冲区大小等。</p>
<h4 id="查看特定进程的信息"><a href="#查看特定进程的信息" class="headerlink" title="查看特定进程的信息"></a>查看特定进程的信息</h4><p>每一个正在运行的进程都有一个与其 PID 对应的目录在 <code>/proc</code> 下。例如，如果你有一个 PID 为 1234 的进程，你可以使用以下命令查看其状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/1234/status</span><br></pre></td></tr></table></figure>

<p>这将显示关于该进程的各种信息，如其状态（Sleeping，Running 等），内存占用等。</p>
<p>对于查看进程的内存占用以分析是否存在内存泄露，你可以查看 <code>/proc/PID/smaps</code> 或 <code>/proc/PID/status</code> 文件。</p>
<p><code>/proc/PID/smaps</code> 提供了进程使用的每个内存区域的详细信息，包括大小，位置，权限等。你可以通过汇总这些区域的大小来获取进程的总内存使用量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/1234/smaps</span><br></pre></td></tr></table></figure>

<p><code>/proc/PID/status</code> 文件中的 <code>VmRSS</code> 和 <code>VmSize</code> 字段也提供了有关进程内存使用的信息。<code>VmRSS</code> 是进程正在使用的物理内存量，<code>VmSize</code> 是进程虚拟内存大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/1234/status</span><br></pre></td></tr></table></figure>

<p>如果你观察到这些值随着时间的推移持续增长，可能就存在内存泄漏的问题。</p>
<p>请注意，分析内存泄漏通常需要结合其他工具和技术，例如 <code>valgrind</code>，<code>gdb</code>，或者专门的内存分析器。</p>
<h3 id="2-18-5-查看网络参数"><a href="#2-18-5-查看网络参数" class="headerlink" title="2.18.5. 查看网络参数"></a>2.18.5. 查看网络参数</h3><h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><p><code>traceroute</code> 命令用于显示数据包从你的机器到达目标机器所经过的所有路由。这对于诊断网络问题非常有用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">traceroute www.baidu.com</span><br></pre></td></tr></table></figure>



<h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p><code>ping</code> 命令用于测试你的机器和目标机器之间的网络连接。如果你能成功地 “ping” 到一个机器，那么你的机器就能和那台机器通信：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>



<h4 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h4><p><code>nslookup</code> 命令用于查询 DNS 记录。这可以帮助你查看域名的 IP 地址，以及其他 DNS 记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup www.baidu.com</span><br></pre></td></tr></table></figure>



<h4 id="ifconfig-和-ip"><a href="#ifconfig-和-ip" class="headerlink" title="ifconfig 和 ip"></a>ifconfig 和 ip</h4><p><code>ifconfig</code> 和 <code>ip</code> 命令用于查看和配置网络接口。你可以使用这些命令来查看你的网络配置，或者更改你的 IP 地址或路由表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">ip addr</span><br></pre></td></tr></table></figure>



<h4 id="netstat-和-ss"><a href="#netstat-和-ss" class="headerlink" title="netstat 和 ss"></a>netstat 和 ss</h4><p><code>netstat</code> 和 <code>ss</code>，能够显示网络连接，路由表，接口状态等：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -tuln</span><br><span class="line">ss -t</span><br></pre></td></tr></table></figure>

<p>以上的命令都是网络诊断工具中的基础，但是也有许多其他的工具和技术可以用于更复杂的网络问题的诊断。例如，<code>tcpdump</code> 和 <code>wireshark</code> 可以用于捕获和分析网络流量，<code>nmap</code> 可以用于网络扫描和安全审计，<code>curl</code> 和 <code>wget</code> 可以用于从 web 服务器下载文件，等等。</p>
<h2 id="2-19-键盘快捷和命令"><a href="#2-19-键盘快捷和命令" class="headerlink" title="2.19. 键盘快捷和命令"></a>2.19. 键盘快捷和命令</h2><p>在 Ubuntu 的命令行中，有很多键盘快捷键和命令可以提高程序员的效率。以下是一些实用的操作技巧：</p>
<p><strong>自动完成（Tab 键）</strong>：在输入命令或文件名的时候，可以按 <code>Tab</code> 键自动补全。如果有多个选项，按两次 <code>Tab</code> 键将列出所有匹配的选项。</p>
<p><strong>历史命令（上 / 下方向键）</strong>：在命令行中，你可以使用上 / 下方向键来浏览你之前输入过的命令。按上方向键可以回到更早之前的命令，按下方向键可以回到更近的命令。</p>
<p><strong>命令行中的光标移动（左 / 右方向键）</strong>：左 / 右方向键可以在当前命令行中移动光标，这样你可以编辑命令行中的任何部分。</p>
<p><strong>历史命令（history）</strong>：<code>history</code> 命令可以显示你之前输入过的所有命令。这样你可以找到并重新执行之前的命令，而不是手动输入。</p>
<p><strong>搜索历史命令（Ctrl+R）</strong>：按下 <code>Ctrl+R</code>，然后开始输入，你会看到一个提示符，显示你正在搜索历史命令。这是一个增量搜索，也就是说，随着你的输入，系统会显示匹配的历史命令。在执行 <code>Ctrl+R</code> 输入关键词进行搜索后，可以使用上 / 下方向键在匹配的历史命令之间进行切换。</p>
<p><strong>跳转到行首（Ctrl+A）和行尾（Ctrl+E）</strong>：在命令行中，你可以使用 <code>Ctrl+A</code> 快速跳到当前行的开头，或者使用 <code>Ctrl+E</code> 快速跳到当前行的末尾。</p>
<p><strong>单词跳跃（Ctrl + 左方向键 / 右方向键）</strong>：按下 <code>Ctrl</code> 键的同时按左方向键或右方向键，可以一次跳过一个单词，而不是一个字符。</p>
<p><strong>删除单词（Ctrl+W）</strong>：按下 <code>Ctrl+W</code> 会删除光标左边的一个单词。</p>
<p><strong>清空命令行（Ctrl+L）</strong>：这个快捷键可以帮助你清空命令行界面，类似于输入 <code>clear</code> 命令。</p>
<p><strong>中止当前命令（Ctrl+C）</strong>：这个快捷键可以帮助你中止当前正在运行的命令。</p>
<p><strong>将命令放入后台运行（Ctrl+Z）</strong>：这个快捷键可以将当前正在运行的命令放入后台。你可以使用 <code>fg</code> 命令将其恢复到前台。</p>
<p><strong>复制和粘贴（Ctrl+Shift+C 和 Ctrl+Shift+V）</strong>：在命令行中，你不能直接使用 <code>Ctrl+C</code> 和 <code>Ctrl+V</code> 来复制和粘贴，因为这两个快捷键已经被其他功能占用。但你可以使用 <code>Ctrl+Shift+C</code> 来复制，使用 <code>Ctrl+Shift+V</code> 来粘贴。</p>
<p><strong>切换命令行标签页（Ctrl+PgUp 和 Ctrl+PgDn）</strong>：如果你在使用带标签页的命令行界面（例如 GNOME Terminal），你可以使用 <code>Ctrl+PgUp</code> 和 <code>Ctrl+PgDn</code> 在标签页之间切换。</p>
<p><strong>命令别名（alias）</strong>：如果你有一些经常使用的长命令，你可以使用 <code>alias</code> 命令为它们创建别名。例如，你可以使用 <code>alias ll=&#39;ls -lh&#39;</code> 创建一个 <code>ll</code> 的别名，这样每次输入 <code>ll</code> 都相当于输入 <code>ls -lh</code>。</p>
<p>以上只是一部分实用的命令行技巧，还有许多其他的技巧和快捷键可以帮助你提高效率。你可以尝试在网上搜索更多的信息，或者查看相关的文档和教程。</p>
<h2 id="2-20-包管理"><a href="#2-20-包管理" class="headerlink" title="2.20. 包管理"></a>2.20. 包管理</h2><p>Ubuntu 使用 <code>apt</code> 包管理器来处理软件包。以下是一些基本的 <code>apt</code> 命令：</p>
<ul>
<li><code>sudo apt update</code>：更新软件包列表。这应该是安装新软件之前执行的第一个命令。</li>
<li><code>sudo apt upgrade</code>：升级所有的软件包。这将更新所有已安装的软件包至最新版本。</li>
<li><code>sudo apt install</code>：安装一个新的软件包。例如，<code>sudo apt install firefox</code> 将安装 Firefox 浏览器。</li>
<li><code>sudo apt remove</code>：删除一个已安装的软件包。例如，<code>sudo apt remove firefox</code> 将卸载 Firefox 浏览器。</li>
<li><code>sudo apt search</code>：搜索软件包。例如，<code>sudo apt search firefox</code> 将显示所有与 Firefox 相关的软件包。</li>
</ul>
<p>如果你下载了一个 <code>.deb</code> 文件并希望通过命令行手动安装，你可以使用 <code>dpkg</code> 命令。以下是具体的操作：</p>
<ul>
<li><code>sudo dpkg -i package_file.deb</code>：安装一个 <code>.deb</code> 软件包。例如，<code>sudo dpkg -i firefox.deb</code> 将安装名为 <code>firefox.deb</code> 的软件包。</li>
</ul>
<p>这里的 <code>sudo</code> 命令是 “superuser do” 的缩写，它允许普通用户以超级用户（或称为 root 用户）的身份执行命令。由于安装和卸载软件包可能会影响系统的运行，所以需要超级用户的权限。当你在命令前添加 <code>sudo</code> 时，系统可能会提示你输入密码，以验证你有执行该命令的权限。</p>
<h2 id="2-21-其他"><a href="#2-21-其他" class="headerlink" title="2.21. 其他"></a>2.21. 其他</h2><h3 id="watch-命令"><a href="#watch-命令" class="headerlink" title="watch 命令"></a>watch 命令</h3><p><code>watch</code> 是一个非常有用的命令，它允许你周期性地执行命令并显示结果。这对于监视文件、系统状态或任何可以通过命令行查看的内容非常有用。</p>
<p>例如，你可以使用 <code>watch</code> 每两秒刷新一次 <code>ls</code> 命令的输出，以监视目录的变化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch -n 2 du -sh</span><br></pre></td></tr></table></figure>

<p>这将每两秒执行一次 <code>du -sh</code> 命令并显示其输出。</p>
<h3 id="time-命令"><a href="#time-命令" class="headerlink" title="time 命令"></a>time 命令</h3><p><code>time</code> 命令用于测量命令的执行时间。这对于性能测试非常有用。</p>
<p>例如，你可以使用 <code>time</code> 来测量 <code>make all</code> 命令的执行时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time make all</span><br></pre></td></tr></table></figure>

<p>这将显示 <code>make all</code> 命令的执行时间，包括用户态，内核态的 CPU 时间以及实际经过的墙钟时间。</p>
<p>这些工具提供了非常有用的功能，可以帮助你更好地理解和监控你的系统。和其他命令一样，你可以通过查看它们的手册页（例如，通过运行 <code>man watch</code> 或 <code>man time</code>）来学习更多关于它们的信息。</p>
<h2 id="2-22-查看帮助手册"><a href="#2-22-查看帮助手册" class="headerlink" title="2.22. 查看帮助手册"></a>2.22. 查看帮助手册</h2><p>在 Ubuntu Linux 中，你可以通过两种主要方式查看命令的帮助和手册：使用 <code>man</code> 命令或者使用 <code>--help</code> 或 <code>-h</code> 选项。</p>
<p><strong>man 命令</strong>：<code>man</code> 命令用于显示用户手册页，这些手册页包含了关于各种命令和程序的详细信息。要查看某个命令的手册页，只需在 <code>man</code> 后面跟上你想要查询的命令即可。例如，<code>man ls</code> 将显示 <code>ls</code> 命令的手册页。这个命令的结果通常会很详尽，包含了命令的描述、选项、使用示例等。</p>
<p><strong>–help 或 -h 选项</strong>：大多数的命令都支持 <code>--help</code> 或 <code>-h</code> 选项，这个选项可以显示命令的简短帮助信息。这个选项通常会列出命令的基本用法和所有可用的选项，但不会像 <code>man</code> 命令那样详尽。例如，<code>ls --help</code> 或 <code>ls -h</code> 将显示 <code>ls</code> 命令的帮助信息。</p>
<p>需要注意的是，不是所有的命令都支持 <code>--help</code> 或 <code>-h</code> 选项，而且即使支持，显示的信息也可能因命令而异。如果 <code>--help</code> 或 <code>-h</code> 选项无法提供足够的信息，那么你可以考虑使用 <code>man</code> 命令。</p>
<h1 id="3-编辑器的使用"><a href="#3-编辑器的使用" class="headerlink" title="3. 编辑器的使用"></a>3. 编辑器的使用</h1><h2 id="3-1-Vim-编辑器的介绍"><a href="#3-1-Vim-编辑器的介绍" class="headerlink" title="3.1. Vim 编辑器的介绍"></a>3.1. Vim 编辑器的介绍</h2><p>Vim 是一款由 Bram Moolenaar 开发的文本编辑器，它是 Unix 类操作系统下 vi 编辑器的克隆版本，但比 vi 更为强大。Vim 是全键盘操作的编辑器，可以实现对文本的高效编辑。</p>
<p>Vim 的功能强大，主要表现在以下几个方面：</p>
<ul>
<li>语法高亮：Vim 支持多种编程语言的语法高亮。</li>
<li>多重撤销：Vim 支持无限次的撤销操作。</li>
<li>分屏：Vim 可以打开多个文档，并进行分屏显示。</li>
<li>扩展性：Vim 的功能可以通过插件进行扩展，有丰富的插件可供选择。</li>
</ul>
<h2 id="3-2-Vim-的模式"><a href="#3-2-Vim-的模式" class="headerlink" title="3.2. Vim 的模式"></a>3.2. Vim 的模式</h2><p>Vim 有以下几种模式：</p>
<ul>
<li>一般模式（Normal Mode）：这是 Vim 打开后的默认模式，可以进行光标移动、复制、粘贴、搜索、替换等多种操作。</li>
<li>插入模式（Insert Mode）：在此模式下，可以插入文本。从一般模式按 <code>i</code> 键进入此模式，按 <code>ESC</code> 键回到一般模式。</li>
<li>命令模式（Command Mode）：在此模式下，可以输入命令行命令。从一般模式按 <code>:</code> 键进入此模式，按 <code>ESC</code> 键回到一般模式。</li>
<li>可视模式（Visual Mode）：在此模式下，可以对文本进行选中操作。从一般模式按 <code>v</code>（字符可视模式）、<code>V</code>（行可视模式）或 <code>Ctrl+v</code>（块可视模式）进入此模式，按 <code>ESC</code> 键回到一般模式。</li>
</ul>
<h2 id="3-3-Vim-的基本操作"><a href="#3-3-Vim-的基本操作" class="headerlink" title="3.3. Vim 的基本操作"></a>3.3. Vim 的基本操作</h2><p>以下是 Vim 的一些基本操作：</p>
<ul>
<li>光标移动：在一般模式下，<code>h</code>（左）、<code>j</code>（下）、<code>k</code>（上）、<code>l</code>（右）用于光标的基础移动。</li>
<li>插入文本：在一般模式下，<code>i</code> 进入插入模式，然后可以输入文本。在完成后，按 <code>ESC</code> 键回到一般模式。</li>
<li>保存文件：在命令模式下，输入 <code>:w</code> 可以保存文件。</li>
<li>退出 Vim：在命令模式下，输入 <code>:q</code> 可以退出 Vim。如果有未保存的修改，需要输入 <code>:q!</code> 强制退出。</li>
</ul>
<p>在 Vim 中，你可以快速地跳转到文件的任何一行。以下是具体的步骤：</p>
<ul>
<li>在命令模式（也就是一般模式）下，输入行数，然后按 <code>G</code> 键。例如，如果你想跳转到第 25 行，你应该输入 <code>25G</code>。</li>
<li>另一种方法是在命令行模式中使用 <code>:</code> 和行号。例如，如果你想跳转到第 25 行，你应该输入 <code>:25</code>。在输入完毕后，按 <code>Enter</code> 键即可。</li>
</ul>
<p>这两种方法都可以让你快速地在文件中跳转。</p>
<h2 id="3-4-Vim-的高级功能"><a href="#3-4-Vim-的高级功能" class="headerlink" title="3.4. Vim 的高级功能"></a>3.4. Vim 的高级功能</h2><p>以下是 Vim 的一些高级功能：</p>
<ul>
<li>搜索：在一般模式下，输入 <code>/</code> 后跟着要搜索的内容，然后按 <code>Enter</code> 键可以进行搜索。按 <code>n</code> 键跳转到下一个搜索结果，按 <code>N</code> 键跳转到上一个搜索结果。</li>
<li>替换：在命令模式下，输入 <code>:s/old/new/g</code> 可以替换当前行中的所有 “old” 为 “new”。如果要在整个文件中进行替换，可以使用 <code>:% s/old/new/g</code> 命令。</li>
<li>分屏：在命令模式下，输入 <code>:split</code> 或 <code>:vsplit</code> 可以进行水平分屏或垂直分屏。使用 <code>Ctrl+w</code> 键可以在各个分屏窗口中切换。</li>
<li>宏：Vim 支持宏录制和播放，可以批量处理复杂的文本操作。</li>
</ul>
<h2 id="3-5-Vim-的实际应用练习"><a href="#3-5-Vim-的实际应用练习" class="headerlink" title="3.5. Vim 的实际应用练习"></a>3.5. Vim 的实际应用练习</h2><p>Vim 是一款高度可配置的文本编辑器，用于有效地创建和更改任何类型的文本。 它被包含在大多数 UNIX 系统并且在许多其他地方有所应用。 在本章节中，我们将通过一些实际的练习来探索 Vim 编辑器的应用。</p>
<p><strong>练习 1：创建和保存文件</strong></p>
<p>让我们从创建和保存一个新文档开始。 在终端中，键入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim newfile.txt</span><br></pre></td></tr></table></figure>

<p>这将打开一个名为 “newfile.txt” 的新 Vim 窗口。 现在，键入 <code>i</code> 进入插入模式，在其中你可以输入文本。 输入一些文本，然后按 <code>ESC</code> 返回到命令模式。 在命令模式下，键入 <code>:wq</code> 或者按 <code>Shift + ZZ</code> 快捷键保存并退出 Vim。</p>
<p><strong>练习 2：导航文本</strong></p>
<p>Vim 有多种导航文档的方法。 在 Vim 中打开一个文档，然后试试下面的命令：</p>
<ul>
<li><code>gg</code> - 跳到文档的开始</li>
<li><code>G</code> - 跳到文档的结尾</li>
<li><code>0</code> - 跳到行的开头</li>
<li><code>$</code> - 跳到行的末尾</li>
<li><code>w</code> - 跳到下一个单词的开头</li>
<li><code>b</code> - 跳到上一个单词的开头</li>
</ul>
<p><strong>练习 3：编辑文本</strong></p>
<p>Vim 提供了许多强大的文本编辑功能，包括复制、粘贴和删除。 在 Vim 中打开一个文档，然后尝试以下命令：</p>
<ul>
<li><code>dd</code> - 删除当前行</li>
<li><code>yy</code> - 复制当前行</li>
<li><code>p</code> - 粘贴剪贴板中的内容到当前行之后</li>
<li><code>u</code> - 撤销上一次操作</li>
<li><code>Ctrl + r</code> - 重做上一次撤销的操作</li>
</ul>
<p><strong>练习 4：查找和替换</strong></p>
<p>Vim 的查找和替换功能非常实用。 在 Vim 中打开一个文档，然后尝试以下命令：</p>
<ul>
<li><code>/word</code> - 查找 “word”</li>
<li><code>n</code> - 跳到下一个匹配项</li>
<li><code>N</code> - 跳到上一个匹配项</li>
<li><code>:% s/old/new/g</code> - 全文替换 “old” 为 “new”</li>
</ul>
<p><strong>练习 5：使用 Vim 宏</strong></p>
<p>Vim 的宏是一种强大的自动化工具，可以记录和重播键入序列。 试试以下步骤：</p>
<ul>
<li>在命令模式下，键入 <code>qa</code> 开始记录宏 a</li>
<li>输入一系列的命令，例如 <code>iHello World&lt;Esc&gt;</code></li>
<li>键入 <code>q</code> 停止记录</li>
<li>键入 <code>@a</code> 运行宏 a</li>
</ul>
<h1 id="4-Bash-Shell-编程基础"><a href="#4-Bash-Shell-编程基础" class="headerlink" title="4. Bash Shell 编程基础"></a>4. Bash Shell 编程基础</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1. 介绍"></a>4.1. 介绍</h2><h3 id="Bash-Shell-是什么"><a href="#Bash-Shell-是什么" class="headerlink" title="Bash Shell 是什么"></a>Bash Shell 是什么</h3><p>Bash（Bourne Again Shell）是一个 Unix shell 和命令语言，由 Brian Fox 为 GNU 项目开发。它是 Bourne Shell (sh) 的扩展版，并提供了许多改善和新特性。Bash 是许多 Linux 发行版的默认 shell，并且也是 macOS 和 Windows 的 Subsystem for Linux（WSL）中可用的。</p>
<p>Shell 是一个用户与操作系统进行交互的界面。通过 shell，用户可以执行命令、运行脚本、操作文件系统等。Bash 作为一个 shell，提供了丰富的编程特性，如变量、数组、流程控制结构（如 if，for，while 等）和函数。</p>
<h3 id="Bash-Shell-的历史和应用"><a href="#Bash-Shell-的历史和应用" class="headerlink" title="Bash Shell 的历史和应用"></a>Bash Shell 的历史和应用</h3><p>Bash Shell 最初于 1989 年发布，作为自由软件基础构建块的一部分，它旨在完全兼容 “sh”（Bourne Shell），同时还引入了 C Shell（csh）和 Korn Shell（ksh）的许多有用特性。</p>
<p>由于其强大的特性和开源的本质，Bash 已经成为了许多系统管理员和开发人员的首选工具。它不仅用于日常的文件管理和系统管理任务，也用于编写复杂的脚本和自动化程序。</p>
<h2 id="4-2-Shell-变量"><a href="#4-2-Shell-变量" class="headerlink" title="4.2. Shell 变量"></a>4.2. Shell 变量</h2><h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><p>在 Bash shell 中，变量是用来存储和操作数据的名称。这些数据可能是字符串，数字，或者是其他命令的输出。变量的主要用途是提供一个方法来保存和操纵数据，以便在脚本或命令行中使用。</p>
<h3 id="如何声明和使用变量"><a href="#如何声明和使用变量" class="headerlink" title="如何声明和使用变量"></a>如何声明和使用变量</h3><p>在 Bash 中，你可以使用等号 <code>=</code> 来声明变量和赋值。例如，下面的命令声明了一个名为 <code>my_variable</code> 的变量，并将其值设置为 <code>Hello, world!</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_variable=&quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>

<p>请注意，变量名和等号之间不能有空格。</p>
<p>一旦你声明了一个变量，你就可以使用美元符号 <code>$</code> 来使用它。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $my_variable</span><br></pre></td></tr></table></figure>

<p>这会在终端中输出 <code>Hello, world!</code>。</p>
<h3 id="环境变量和局部变量"><a href="#环境变量和局部变量" class="headerlink" title="环境变量和局部变量"></a>环境变量和局部变量</h3><p>Bash 中有两种主要类型的变量：环境变量和局部变量。</p>
<p>局部变量只在它们被声明的 shell 会话中可用。如果你在一个终端窗口中声明了一个变量，然后打开了一个新的终端窗口，那么新的终端窗口将无法访问那个变量。</p>
<p>环境变量，另一方面，是在所有的 shell 会话中都可用的。你可以使用 <code>export</code> 命令来创建环境变量。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export my_variable=&quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>

<p>一旦你这样做，<code>my_variable</code> 将在所有的子 shell 会话中都可用。</p>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><p>Bash 还定义了一些特殊的变量，这些变量在 shell 中有特定的用途。以下是一些最常用的特殊变量：</p>
<ul>
<li><code>$HOME</code>：当前用户的主目录的路径。</li>
<li><code>$PATH</code>：用于查找命令的目录列表。</li>
<li><code>$PS1</code>：默认的命令提示符。</li>
<li><code>$USER</code>：当前用户的用户名。</li>
<li><code>$?</code>：最后执行的命令的退出状态。如果命令成功执行，该值为 0，否则为非零值。</li>
<li><code>$$</code>：当前 shell 进程的 PID。</li>
<li><code>$#</code>：传递给脚本或函数的参数个数。</li>
<li><code>$*</code> 和 <code>$@</code>：传递给脚本或函数的所有参数。</li>
</ul>
<p>这些特殊变量为你在 Bash 中编写脚本和处理数据提供了强大的工具。</p>
<h2 id="4-3-Shell-脚本"><a href="#4-3-Shell-脚本" class="headerlink" title="4.3. Shell 脚本"></a>4.3. Shell 脚本</h2><h3 id="什么是-Shell-脚本"><a href="#什么是-Shell-脚本" class="headerlink" title="什么是 Shell 脚本"></a>什么是 Shell 脚本</h3><p>Shell 脚本是一个包含了一系列命令的文本文件，当这个脚本被执行时，这些命令会按照它们在脚本中出现的顺序被执行。Shell 脚本可以帮助我们自动化一些日常的任务，例如文件管理、程序运行等。</p>
<h3 id="如何创建和运行-Shell-脚本"><a href="#如何创建和运行-Shell-脚本" class="headerlink" title="如何创建和运行 Shell 脚本"></a>如何创建和运行 Shell 脚本</h3><p>创建一个 Shell 脚本其实就是创建一个文本文件，并在文件中写入你想要执行的命令。例如，你可以创建一个名为 <code>my_script.sh</code> 的文件，并在其中写入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>

<p>在这个脚本中，<code>#!/bin/bash</code> 是一个特殊的指示符，称为 shebang，它告诉系统这个脚本应该用哪个解释器来执行，这里是 <code>/bin/bash</code>。接下来的命令 <code>echo&quot;Hello, world!&quot;</code>将会在脚本被执行时输出”Hello, world!”。</p>
<p>你可以通过以下命令来运行这个脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash my_script.sh</span><br></pre></td></tr></table></figure>

<p>或者，你可以先给这个脚本添加执行权限，然后直接运行它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x my_script.sh</span><br><span class="line">./my_script.sh</span><br></pre></td></tr></table></figure>



<h3 id="Shell-脚本的结构和语法"><a href="#Shell-脚本的结构和语法" class="headerlink" title="Shell 脚本的结构和语法"></a>Shell 脚本的结构和语法</h3><p>一个典型的 Shell 脚本包含了以下元素：</p>
<ul>
<li>Shebang：这是脚本的第一行，它指定了执行这个脚本的解释器。对于 Bash 脚本，这通常是 <code>#!/bin/bash</code>。</li>
<li>命令：这些是你想要自动执行的命令。它们按照在脚本中出现的顺序执行。</li>
<li>注释：以 <code>#</code> 开始的行是注释，它们不会被执行。你可以使用注释来解释脚本的功能或者说明某个命令的作用。</li>
<li>变量：你可以在脚本中定义变量来保存和操作数据。</li>
<li>控制结构：例如 <code>if</code>、<code>for</code>、<code>while</code>。这些可以让你的脚本根据条件执行不同的命令，或者重复执行某些命令。</li>
</ul>
<p>以下是一个更复杂的脚本的例子，它使用了变量和 <code>if</code> 控制结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">name=$1</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$name&quot; ]; then</span><br><span class="line">  echo &quot;Hello, world!&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;Hello, $name!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>这个脚本接受一个参数，并将其值赋给 <code>name</code> 变量。然后，它使用 <code>if</code> 语句检查 <code>name</code> 是否为空。如果 <code>name</code> 为空，它会输出 “Hello, world!”，否则，它会输出 “Hello, $name!”。</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>你可以在执行脚本时传递参数，这些参数在脚本中可以通过 <code>$1</code>、<code>$2</code>、<code>$3</code> 等变量来访问，其中 <code>$1</code> 对应第一个参数，<code>$2</code> 对应第二个参数，以此类推。例如，如果你执行 <code>bash my_script.sh Alice</code>，那么在 <code>my_script.sh</code> 脚本中，<code>$1</code> 的值就会是 “Alice”。</p>
<p>另外，你也可以使用 <code>$@</code> 或者 <code>$*</code> 来获取所有的参数，而 <code>$#</code> 可以获取参数的个数。</p>
<h2 id="4-4-流程控制"><a href="#4-4-流程控制" class="headerlink" title="4.4. 流程控制"></a>4.4. 流程控制</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>在 Shell 脚本中，我们可以使用 <code>if</code>、<code>else</code> 和 <code>case</code> 来进行条件判断。</p>
<p>-<strong>if/else</strong>语句</p>
<p><code>if</code> 语句用于根据条件执行不同的代码块。基本的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ condition ]; then</span><br><span class="line">    # commands to execute if condition is true</span><br><span class="line">else</span><br><span class="line">    # commands to execute if condition is false</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ $1 -gt 100 ]; then</span><br><span class="line">    echo &quot;The number is larger than 100.&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;The number is 100 or less.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>-<strong>case</strong>语句</p>
<p><code>case</code> 语句用于根据值的不同执行不同的代码块。基本的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case value in</span><br><span class="line">    pattern1)</span><br><span class="line">        # commands to execute if value matches pattern1</span><br><span class="line">        ;;</span><br><span class="line">    pattern2)</span><br><span class="line">        # commands to execute if value matches pattern2</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        # commands to execute if value doesn&#x27;t match any pattern</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case $1 in</span><br><span class="line">    start)</span><br><span class="line">        echo &quot;Starting...&quot;</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        echo &quot;Stopping...&quot;</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;Unknown command: $1&quot;</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<h3 id="循环语句（for-while-until）"><a href="#循环语句（for-while-until）" class="headerlink" title="循环语句（for, while, until）"></a>循环语句（for, while, until）</h3><p>在 Shell 脚本中，我们可以使用 <code>for</code>、<code>while</code> 和 <code>until</code> 来进行循环。</p>
<p>-<strong>for</strong>循环</p>
<p>``for` 循环用于重复执行一段代码。基本的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for var in list; do</span><br><span class="line">    # commands to execute</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in 1 2 3; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>-<strong>while</strong>循环</p>
<p>``while` 循环用于当条件为真时重复执行一段代码。基本的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while [ condition ]; do</span><br><span class="line">    # commands to execute</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i=1</span><br><span class="line">while [ $i -le 3 ]; do</span><br><span class="line">    echo $i</span><br><span class="line">    i=$((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>-<strong>until</strong>循环</p>
<p>``until` 循环用于当条件为假时重复执行一段代码。基本的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">until [ condition ]; do</span><br><span class="line">    # commands to execute</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i=1</span><br><span class="line">until [ $i -gt 3 ]; do</span><br><span class="line">    echo $i</span><br><span class="line">    i=$((i+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>这些流程控制结构为我们在 Shell 脚本中编写复杂的逻辑提供了强大的工具。</p>
<h2 id="4-5-函数"><a href="#4-5-函数" class="headerlink" title="4.5. 函数"></a>4.5. 函数</h2><h3 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h3><p>在 Shell 脚本中，函数是一段可被重复使用的代码块。你可以在脚本的任何地方声明一个函数，并在需要的地方调用它。函数可以帮助你组织和重用代码，使你的脚本更简洁、更易于理解和维护。</p>
<h3 id="如何声明和调用函数"><a href="#如何声明和调用函数" class="headerlink" title="如何声明和调用函数"></a>如何声明和调用函数</h3><p>在 Shell 脚本中，你可以使用 <code>function</code> 关键字或者直接使用函数名来声明函数。函数的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function_name () &#123;</span><br><span class="line">  # commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function function_name &#123;</span><br><span class="line">  # commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以通过函数名来调用函数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function_name</span><br></pre></td></tr></table></figure>

<p>以下是一个简单的函数示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">greet () &#123;</span><br><span class="line">  echo &quot;Hello, $1!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet &quot;world&quot;  # 输出 &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>greet</code> 是一个接受一个参数的函数，它会输出 “Hello, $1!”，其中 <code>$1</code> 是函数的第一个参数。</p>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>在函数中，你可以使用 <code>return</code> 语句来指定函数的返回值，但是这个值只能是一个介于 0 到 255 的整数。如果你不指定返回值，函数将返回最后一个命令的退出状态。</p>
<p>你可以使用 <code>$?</code> 变量来获取上一个命令或函数的返回值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_func () &#123;</span><br><span class="line">  return 42</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_func</span><br><span class="line">echo $?  # 输出 &quot;42&quot;</span><br></pre></td></tr></table></figure>

<p>如果你想返回一个字符串或其他类型的值，你可以通过 <code>echo</code> 或 <code>printf</code> 命令将值输出到标准输出，然后在调用函数时使用命令替换的方式来获取这个值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_func () &#123;</span><br><span class="line">  echo &quot;Hello, $1!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greeting=$(my_func &quot;world&quot;)</span><br><span class="line">echo $greeting  # 输出 &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>



<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>递归函数是一种在其定义中调用自身的函数。在 Shell 脚本中，你可以创建递归函数，但是请注意控制递归的深度，避免出现无限递归的情况。</p>
<p>以下是一个计算阶乘的递归函数的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">factorial () &#123;</span><br><span class="line">  if [ $1 -eq 0 ]; then</span><br><span class="line">    echo 1</span><br><span class="line">  else</span><br><span class="line">    last_factorial=$(factorial $(( $1 - 1 )))</span><br><span class="line">    echo $(( $1 * last_factorial ))</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo $(factorial 5)  # 输出 &quot;120&quot;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>factorial</code> 函数接受一个参数，如果这个参数等于 0，它就返回 1，否则，它就调用自身来计算 <code>($1 - 1)</code> 的阶乘，然后将这个值乘以 <code>$1</code>。</p>
<h2 id="4-6-用户输入和输出"><a href="#4-6-用户输入和输出" class="headerlink" title="4.6. 用户输入和输出"></a>4.6. 用户输入和输出</h2><p>在 Shell 脚本中，处理用户输入和输出是非常重要的。我们可以通过几种不同的方式来读取用户的输入，打印输出到终端，或者将输出重定向到文件或其他命令。</p>
<h3 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h3><p>在 Shell 脚本中，我们可以使用 <code>read</code> 命令来读取用户的输入。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;What is your name?&quot;</span><br><span class="line">read name</span><br><span class="line">echo &quot;Hello, $name!&quot;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>read</code> 命令会等待用户输入，然后将输入的值赋给变量 <code>name</code>。</p>
<h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><p>在 Shell 脚本中，我们一般使用 <code>echo</code> 或 <code>printf</code> 命令来打印输出到终端。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=&quot;John Doe&quot;</span><br><span class="line">echo &quot;Hello, $name!&quot;</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>echo</code> 命令会打印出 “Hello, John Doe!”。</p>
<h3 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h3><p>在 Shell 中，我们可以使用重定向操作符 <code>&gt;</code> 和 <code>&gt;&gt;</code> 来将输出重定向到文件。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Hello, world!&quot; &gt; myfile.txt</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>echo</code> 命令的输出 “Hello, world!” 会被写入到 <code>myfile.txt</code> 文件中。如果文件已经存在，<code>&gt;</code> 操作符会覆盖文件的内容。如果我们想要将内容追加到文件的末尾，可以使用 <code>&gt;&gt;</code> 操作符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Hello again, world!&quot; &gt;&gt; myfile.txt</span><br></pre></td></tr></table></figure>



<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>在 Shell 中，我们可以使用管道 <code>|</code> 操作符将一个命令的输出作为另一个命令的输入。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls | grep &quot;.txt&quot;</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>ls</code> 命令会列出当前目录下的所有文件，然后这个列表会被传递给 <code>grep</code> 命令，<code>grep</code> 命令会从这个列表中筛选出所有包含 “.txt” 的行。这样我们就可以找出当前目录下的所有 txt 文件。</p>
<h2 id="4-7-错误处理和调试"><a href="#4-7-错误处理和调试" class="headerlink" title="4.7. 错误处理和调试"></a>4.7. 错误处理和调试</h2><p>在编写和运行 Shell 脚本时，错误处理和调试是必不可少的环节。在不同的情况下，我们可以使用不同的技术来寻找和解决问题。</p>
<h3 id="4-7-1-错误处理"><a href="#4-7-1-错误处理" class="headerlink" title="4.7.1. 错误处理"></a>4.7.1. 错误处理</h3><p>在 Shell 脚本中，我们可以使用特殊变量 <code>$?</code> 来获取上一个命令的退出状态。如果命令成功执行，退出状态为 0，否则为非零值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /nonexistentdirectory</span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">    echo &quot;An error occurred.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果 <code>ls</code> 命令因为目录不存在而失败，我们会打印出一条错误信息。</p>
<p>另外，我们可以使用 <code>set -e</code> 命令让脚本在任何命令失败时立即退出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set -e</span><br><span class="line">ls /nonexistentdirectory</span><br><span class="line">echo &quot;This will not be printed.&quot;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ls</code> 命令会失败，然后脚本立即退出，所以 “This will not be printed.” 永远不会被打印出来。</p>
<h3 id="4-7-2-脚本调试"><a href="#4-7-2-脚本调试" class="headerlink" title="4.7.2. 脚本调试"></a>4.7.2. 脚本调试</h3><p>在 Shell 脚本中，我们可以使用 <code>set -x</code> 命令打开调试模式，这会打印出所有执行的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set -x</span><br><span class="line">echo &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们会看到 <code>+ echo &#39;Hello, world!&#39;</code> 和 <code>Hello, world!</code> 两行输出。前一行显示了实际执行的命令，后一行显示了命令的输出。</p>
<p>如果你想在运行某个 shell 脚本时启用调试模式，你可以在命令行中使用 <code>-x</code> 选项和 Shell 解释器一起调用脚本，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -x script.sh</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>bash -x</code> 会启动一个新的 bash shell，并在这个 shell 中以调试模式运行 <code>script.sh</code> 脚本。这样，脚本中的每一条命令在执行前都会被打印出来。</p>
<h3 id="4-7-3-日志记录"><a href="#4-7-3-日志记录" class="headerlink" title="4.7.3. 日志记录"></a>4.7.3. 日志记录</h3><p>在 Shell 脚本中，记录执行过程和结果是一种常见的做法，以便于后续查看和分析。这通常通过将脚本的输出（包括标准输出和错误输出）重定向到文件实现。这样，我们可以随时查看这些日志文件，了解脚本运行时的具体情况。</p>
<h4 id="标准输出重定向"><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h4><p>我们可以使用 <code>&gt;</code> 和 <code>&gt;&gt;</code> 运算符将脚本的标准输出重定向到文件。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;This is a message.&quot; &gt; output.log</span><br></pre></td></tr></table></figure>

<p>这个例子中，”This is a message.” 会被写入到 <code>output.log</code> 文件中。如果文件已经存在，<code>&gt;</code> 运算符会覆盖文件的内容。如果我们想要将内容追加到文件的末尾，可以使用 <code>&gt;&gt;</code> 运算符。</p>
<h4 id="错误输出重定向"><a href="#错误输出重定向" class="headerlink" title="错误输出重定向"></a>错误输出重定向</h4><p>同样地，我们也可以使用 <code>2&gt;</code> 和 <code>2&gt;&gt;</code> 运算符将脚本的错误输出重定向到文件。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /nonexistentdirectory 2&gt; error.log</span><br></pre></td></tr></table></figure>

<p>这个例子中，如果 <code>ls</code> 命令失败，错误信息会被写入到 <code>error.log</code> 文件中。</p>
<h4 id="同时重定向标准输出和错误输出"><a href="#同时重定向标准输出和错误输出" class="headerlink" title="同时重定向标准输出和错误输出"></a>同时重定向标准输出和错误输出</h4><p>如果我们想要同时重定向标准输出和错误输出，可以使用 <code>&amp;&gt;</code> 运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /nonexistentdirectory &amp;&gt; output_and_error.log</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>ls</code> 命令的标准输出和错误输出都会被写入到 <code>output_and_error.log</code> 文件中。</p>
<p>通过这样的方式，我们可以将脚本的输出和错误信息记录下来，以便于后续查看和分析，从而更好地理解和控制 Shell 脚本的行为，更有效地找出和解决问题。</p>
<h2 id="4-8-Python-与-Shell-脚本的差异"><a href="#4-8-Python-与-Shell-脚本的差异" class="headerlink" title="4.8. Python 与 Shell 脚本的差异"></a>4.8. Python 与 Shell 脚本的差异</h2><p>Python 和 Shell 脚本是两种常用的脚本语言，它们各有特点和用途。了解它们的差异有助于我们在不同的场景下选择合适的工具。</p>
<h3 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h3><p>在 Python 中，我们使用 <code>=</code> 来给变量赋值，可以直接使用变量名引用变量，而且变量可以有多种类型，如整数、浮点数、字符串、列表、字典等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 1</span><br><span class="line">y = &quot;hello&quot;</span><br><span class="line">z = [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们同样使用 <code>=</code> 来给变量赋值，但是不能在变量名和 <code>=</code> 之间有空格，而且需要使用 <code>$</code> 来引用变量。Shell 脚本中的变量只有字符串一种类型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=1</span><br><span class="line">y=&quot;hello&quot;</span><br><span class="line">z=&quot;1 2 3&quot;</span><br></pre></td></tr></table></figure>



<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><p>Python 和 Shell 脚本都支持常见的控制结构，如条件判断和循环，但是语法有所不同。</p>
<p>在 Python 中，我们使用 <code>if</code>、<code>elif</code>、<code>else</code> 进行条件判断，使用 <code>for</code> 和 <code>while</code> 进行循环。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if x == 1:</span><br><span class="line">    print (&quot;x is 1&quot;)</span><br><span class="line">elif x == 2:</span><br><span class="line">    print (&quot;x is 2&quot;)</span><br><span class="line">else:</span><br><span class="line">    print (&quot;x is neither 1 nor 2&quot;)</span><br><span class="line"></span><br><span class="line">for i in range (3):</span><br><span class="line">    print (i)</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们使用 <code>if</code>、<code>elif</code>、<code>else</code> 进行条件判断，需要配合 <code>then</code>、<code>fi</code> 关键字。循环则可以使用 <code>for</code>、<code>while</code>，且 <code>for</code> 循环的语法与 Python 有显著差异。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ $x -eq 1 ]; then</span><br><span class="line">    echo &quot;x is 1&quot;</span><br><span class="line">elif [ $x -eq 2 ]; then</span><br><span class="line">    echo &quot;x is 2&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;x is neither 1 nor 2&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for i in 1 2 3; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Python 和 Shell 脚本都支持定义和调用函数，但是语法有所不同。</p>
<p>在 Python 中，我们使用 <code>def</code> 关键字来定义函数，使用函数名和括号来调用函数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def greet (name):</span><br><span class="line">    print (&quot;Hello,&quot; + name + &quot;!&quot;)</span><br><span class="line"></span><br><span class="line">greet (&quot;world&quot;)</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们使用 <code>function</code> 关键字或直接使用函数名来定义函数，调用函数时只需写出函数名，无需括号。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">greet () &#123;</span><br><span class="line">    echo &quot;Hello, $1!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet &quot;world&quot;</span><br></pre></td></tr></table></figure>

<p>以上只是 Python 和 Shell 脚本的一部分差异，它们在其他方面，如错误处理、文件操作、进程控制等，也有各自的特点和用法。但是，了解这些基本的差异可以帮助我们更快地从 Python 迁移到 Shell 脚本。</p>
<h2 id="4-9-C-语言与-Shell-脚本的差异"><a href="#4-9-C-语言与-Shell-脚本的差异" class="headerlink" title="4.9. C 语言与 Shell 脚本的差异"></a>4.9. C 语言与 Shell 脚本的差异</h2><p>C 语言和 Shell 脚本是两种常用的编程和脚本语言，它们各有特点和用途。了解它们的差异有助于我们在不同的场景下选择合适的工具。</p>
<h3 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h3><p>在 C 语言中，我们必须为每个变量声明数据类型。C 语言支持多种数据类型，包括整型、浮点型、字符型、数组、结构体等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">char y [] = &quot;hello&quot;;</span><br><span class="line">int z [] = &#123;1, 2, 3&#125;;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，所有的变量都是字符串类型，我们不需要声明变量类型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=1</span><br><span class="line">y=&quot;hello&quot;</span><br><span class="line">z=&quot;1 2 3&quot;</span><br></pre></td></tr></table></figure>



<h3 id="控制结构-1"><a href="#控制结构-1" class="headerlink" title="控制结构"></a>控制结构</h3><p>C 语言和 Shell 脚本都支持常见的控制结构，如条件判断和循环，但是语法有所不同。</p>
<p>在 C 语言中，我们使用 <code>if</code>、<code>else if</code>、<code>else</code> 进行条件判断，使用 <code>for</code>、<code>while</code> 和 <code>do...while</code> 进行循环。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (x == 1) &#123;</span><br><span class="line">    printf (&quot;x is 1&quot;);</span><br><span class="line">&#125; else if (x == 2) &#123;</span><br><span class="line">    printf (&quot;x is 2&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    printf (&quot;x is neither 1 nor 2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    printf (&quot;% d&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们使用 <code>if</code>、<code>elif</code>、<code>else</code> 进行条件判断，需要配合 <code>then</code>、<code>fi</code> 关键字。循环则可以使用 <code>for</code>、<code>while</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ $x -eq 1 ]; then</span><br><span class="line">    echo &quot;x is 1&quot;</span><br><span class="line">elif [ $x -eq 2 ]; then</span><br><span class="line">    echo &quot;x is 2&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;x is neither 1 nor 2&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for i in 1 2 3; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>C 语言和 Shell 脚本都支持定义和调用函数，但是语法有所不同。</p>
<p>在 C 语言中，我们需要为函数声明返回类型和参数类型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void greet (char* name) &#123;</span><br><span class="line">    printf (&quot;Hello, % s!</span><br><span class="line">&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet (&quot;world&quot;);</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们不需要声明函数的返回类型和参数类型。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">greet () &#123;</span><br><span class="line">    echo &quot;Hello, $1!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet &quot;world&quot;</span><br></pre></td></tr></table></figure>



<h3 id="变量相等的判断"><a href="#变量相等的判断" class="headerlink" title="变量相等的判断"></a>变量相等的判断</h3><p>在 C 语言中，我们使用 <code>==</code> 符号来判断两个变量是否相等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (x == y) &#123;</span><br><span class="line">    printf (&quot;x is equal to y</span><br><span class="line">&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们使用 <code>-eq</code>（用于整数）或 <code>=</code>（用于字符串）来判断两个变量是否相等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ $x -eq $y ]; then</span><br><span class="line">    echo &quot;x is equal to y&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h3 id="变量的大小比较"><a href="#变量的大小比较" class="headerlink" title="变量的大小比较"></a>变量的大小比较</h3><p>在 C 语言中，我们使用 <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 符号来比较两个变量的大小。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (x &lt; y) &#123;</span><br><span class="line">    printf (&quot;x is less than y</span><br><span class="line">&quot;);</span><br><span class="line">&#125; else if (x &gt; y) &#123;</span><br><span class="line">    printf (&quot;x is greater than y</span><br><span class="line">&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    printf (&quot;x is equal to y</span><br><span class="line">&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们使用 <code>-lt</code>、<code>-gt</code>、<code>-le</code>、<code>-ge</code> 来比较两个整数的大小。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ $x -lt $y ]; then</span><br><span class="line">    echo &quot;x is less than y&quot;</span><br><span class="line">elif [ $x -gt $y ]; then</span><br><span class="line">    echo &quot;x is greater than y&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;x is equal to y&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>在 C 语言中，我们使用字符串函数（如 <code>strcpy</code>、<code>strcat</code>、<code>strlen</code> 等）来操作字符串。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char s [100];</span><br><span class="line">strcpy (s, &quot;hello&quot;);</span><br><span class="line">strcat (s, &quot;, world&quot;);</span><br><span class="line">printf (&quot;% s</span><br><span class="line">&quot;, s); //prints &quot;hello, world&quot;</span><br><span class="line">printf (&quot;% lu</span><br><span class="line">&quot;, strlen (s)); //prints &quot;13&quot;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们可以直接使用变量和字符串字面量来连接字符串，使用 <code>$&#123;# 变量名&#125;</code> 来获取字符串长度。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s=&quot;hello&quot;</span><br><span class="line">s+=&quot;, world&quot;</span><br><span class="line">echo $s # prints &quot;hello, world&quot;</span><br><span class="line">echo $&#123;#s&#125; # prints &quot;13&quot;</span><br></pre></td></tr></table></figure>

<p>在 C 语言中，我们通常使用函数（如 <code>strstr</code> 或 <code>regex</code> 库函数）来进行字符串的模式匹配。</p>
<p>在 Shell 脚本中，我们可以直接使用 <code>=</code> 或 <code>!=</code> 运算符来进行简单的模式匹配，或者使用 <code>case</code> 语句、<code>[[ ]]</code> 结构，或者 <code>grep</code> 命令等来进行更复杂的模式匹配。</p>
<h3 id="字符串空值和非空值的判断"><a href="#字符串空值和非空值的判断" class="headerlink" title="字符串空值和非空值的判断"></a>字符串空值和非空值的判断</h3><p>在 C 语言中，我们通常使用 <code>==</code> 或 <code>!=</code> 符号来判断字符串是否为空。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *s = &quot;hello&quot;;</span><br><span class="line">if (s [0] == &#x27; &#x27;) &#123;</span><br><span class="line">    printf (&quot;s is an empty string</span><br><span class="line">&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    printf (&quot;s is not an empty string</span><br><span class="line">&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们使用 <code>-z</code> 或 <code>-n</code> 来判断字符串是否为空。另外，为了避免字符串变量未定义或为空时出错，我们在比较字符串时，常常会在字符串前加一个常量，例如 <code>x$string</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s=&quot;hello&quot;</span><br><span class="line">if [ -z &quot;$s&quot; ]; then</span><br><span class="line">    echo &quot;s is an empty string&quot;</span><br><span class="line">elif [ &quot;x$s&quot; = &quot;x&quot; ]; then</span><br><span class="line">    echo &quot;s is an empty string&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;s is not an empty string&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p>在 C 语言中，我们使用索引来访问数组元素，使用循环来遍历数组。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a [] = &#123;1, 2, 3&#125;;</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    printf (&quot;% d</span><br><span class="line">&quot;, a [i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Shell 脚本中，我们也使用索引来访问数组元素，使用 <code>$&#123;数组名 [@]&#125;</code> 来获取数组的所有元素，然后用 <code>for</code> 循环来遍历数组。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=(1 2 3)</span><br><span class="line">for i in $&#123;a [@]&#125;; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在 C 语言中，错误处理通常通过函数的返回值或全局变量（如 <code>errno</code>）进行。</p>
<p>在 Shell 脚本中，我们可以使用 <code>$?</code> 变量来获取上一个命令的退出状态，这通常被用作错误处理。</p>
<p>以上只是 C 语言和 Shell 脚本的一部分差异，它们在其他方面，如文件操作、进程控制、信号处理等，也有各自的特点和用法。理解这些差异有助于我们在编写或阅读这两种语言的代码时，更准确地理解其行为。</p>
<p>这些只是 C 语言和 Shell 脚本的部分差异，理解这些差异有助于我们在编写或阅读代码时，更</p>
<h1 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5. 正则表达式"></a>5. 正则表达式</h1><p>在 Shell 中，你可以使用正则表达式（Regular Expression，经常被简写为 RegEx）来描述复杂的匹配模式。正则表达式是一种强大的文本匹配工具，它可以用于 <code>grep</code>、<code>sed</code>、<code>awk</code> 等命令。</p>
<h2 id="5-1-元字符和构造"><a href="#5-1-元字符和构造" class="headerlink" title="5.1. 元字符和构造"></a>5.1. 元字符和构造</h2><p>下面是一些常用的正则表达式元字符和构造：</p>
<p><strong><code>.</code>（点）</strong>：匹配任何单个字符（除了换行符）。</p>
<p><strong><code>\*</code>（星号）</strong>：匹配前面的元素零次或多次。</p>
<p><strong><code>+</code>（加号）</strong>：匹配前面的元素一次或多次。</p>
<p><strong><code>?</code>（问号）</strong>：匹配前面的元素零次或一次。</p>
<p><strong><code>[]</code>（方括号）</strong>：匹配方括号中的任何一个字符。例如，<code>[abc]</code> 会匹配 ‘a’、’b’ 或 ‘c’。</p>
<p><strong><code>^</code>（脱字符）</strong>：在方括号中，表示否定（例如，<code>[^abc]</code> 会匹配任何不是 ‘a’、’b’ 或 ‘c’ 的字符）；在方括号外，表示行的开始。</p>
<p><strong><code>$</code>（美元符号）</strong>：表示行的结束。</p>
<p><strong><code>\</code>（反斜杠）</strong>：用于转义元字符（例如，<code>\.</code> 会匹配实际的 ‘.’ 字符，而不是任何字符）。</p>
<p><strong><code>()</code>（括号）</strong>：用于分组。</p>
<p><strong><code>|</code>（竖线）</strong>：表示或（例如，<code>a|b</code> 会匹配 ‘a’ 或 ‘b’）。</p>
<p><strong><code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code>（花括号）</strong>：匹配前面的元素 n 次、至少 n 次、或者 n 到 m 次。</p>
<p>注意，这些元字符和构造在不同的命令和环境中可能有不同的行为，具体取决于你是否使用了扩展正则表达式（Extended Regular Expression）或者 Perl 正则表达式（Perl-Compatible Regular Expression）。你可以通过查阅相应命令的手册页（例如 <code>man grep</code>）来获取更详细的信息。</p>
<h2 id="5-2-正则表达式的实例"><a href="#5-2-正则表达式的实例" class="headerlink" title="5.2. 正则表达式的实例"></a>5.2. 正则表达式的实例</h2><p>让我们看一些在 Shell 中使用正则表达式的实例。这些例子主要涉及 <code>grep</code>，<code>sed</code> 和 <code>awk</code> 命令，这些都是日常工作中常用的命令。</p>
<p><strong>使用 <code>grep</code> 进行搜索</strong></p>
<p><code>grep</code> 是一种常见的使用正则表达式的方式。你可以使用正则表达式来匹配复杂的模式。例如，下面的命令会在 <code>file.txt</code> 中找到所有以’start’ 开始并以 ‘end’ 结束的行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;^start.*end$&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>如果你想使用扩展的正则表达式特性（例如 <code>+</code>、<code>?</code>、<code>|</code> 和 <code>()</code>），你需要使用 <code>egrep</code> 或者 <code>grep -E</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -E&#x27;start.*end1|end2$&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>这个命令会找到所有以’start’ 开始并以 ‘end1’ 或 ‘end2’ 结束的行。</p>
<p><strong>使用 <code>sed</code> 进行替换</strong></p>
<p><code>sed</code> 可以使用正则表达式来执行复杂的替换操作。例如，下面的命令会在 <code>file.txt</code> 中将所有以’start’ 开始并以 ‘end’ 结束的行替换为 ‘replacement’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -E&#x27;s/^start.*end$/replacement/g&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>awk</code> 进行文本处理</strong></p>
<p><code>awk</code> 可以使用正则表达式来处理复杂的文本模式。例如，下面的命令会打印 <code>file.txt</code> 中所有包含 ‘pattern’ 的行的第一列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;/pattern/ &#123;print $1&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>

<p>这只是正则表达式在 Shell 中的一些基本用法，你可以根据需要进行组合和扩展，以处理更复杂的模式和任务。</p>
<h1 id="6-Linux-环境下的编程常见操作"><a href="#6-Linux-环境下的编程常见操作" class="headerlink" title="6. Linux 环境下的编程常见操作"></a>6. Linux 环境下的编程常见操作</h1><h2 id="6-1-C-编程环境的配置"><a href="#6-1-C-编程环境的配置" class="headerlink" title="6.1. C 编程环境的配置"></a>6.1. C 编程环境的配置</h2><p>在 Linux 环境下进行 C 语言编程，需要先配置好开发环境。一般而言，你应该已经安装了 GCC（GNU Compiler Collection）集合，它包含了 C 语言的编译器。如果你还未安装 GCC，可以通过以下命令进行安装（以 Ubuntu 为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

<p>安装完 GCC 后，你可以通过在终端输入 <code>gcc --version</code> 来验证安装是否成功。</p>
<h2 id="6-2-基本的编译命令"><a href="#6-2-基本的编译命令" class="headerlink" title="6.2. 基本的编译命令"></a>6.2. 基本的编译命令</h2><p>编译 C 程序主要使用 <code>gcc</code> 命令。如果你有一个名为 <code>program.c</code> 的 C 语言源文件，你可以使用以下命令进行编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc program.c -o program</span><br></pre></td></tr></table></figure>

<p>在这个命令中，<code>-o program</code> 表示编译后生成的可执行文件名为 <code>program</code>。如果你省略 <code>-o</code> 选项，那么默认的输出文件名为 <code>a.out</code>。</p>
<h2 id="6-3-版本控制工具"><a href="#6-3-版本控制工具" class="headerlink" title="6.3. 版本控制工具"></a>6.3. 版本控制工具</h2><p>在 Linux 环境下，最常用的版本控制工具无疑是 Git。Git 是一个分布式的版本控制系统，可以帮助你跟踪和管理项目的代码变更。</p>
<p>首次使用 Git 时，你需要配置你的用户名和电子邮件地址，因为 Git 每次提交会使用这些信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;Your Email&quot;</span><br></pre></td></tr></table></figure>

<p>Git 的基本工作流程包括：初始化仓库（<code>git init</code>）、添加文件到仓库（<code>git add</code>）、提交变更（<code>git commit</code>）、查看状态（<code>git status</code>）、查看提交历史（<code>git log</code>）等。</p>
<h2 id="6-4-调试工具"><a href="#6-4-调试工具" class="headerlink" title="6.4. 调试工具"></a>6.4. 调试工具</h2><p>对于 C 语言程序，最常用的调试工具是 GDB（GNU Debugger）。GDB 可以让你逐行地运行程序，查看和修改程序状态，以帮助你查找和修复错误。</p>
<p>在使用 GDB 之前，你需要使用 <code>-g</code> 选项来编译你的 C 程序，以包含调试信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -g program.c -o program</span><br></pre></td></tr></table></figure>

<p>然后，你可以使用 <code>gdb</code> 命令启动 GDB 并加载你的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb program</span><br></pre></td></tr></table></figure>

<p>在 GDB 中，你可以使用各种命令进行调试，如：<code>run</code>（运行程序）、<code>break</code>（设置断点）、<code>next</code>（执行下一行程序）、<code>print</code>（打印变量的值）等。</p>
<p>以上就是在 Linux 环境下进行编程的一些常见操作，包括 C 编程环境的配置、基本的编译命令、版本控制工具以及调试工具。希望对你有所帮助。</p>
<h1 id="7-Makefile-的使用和编写"><a href="#7-Makefile-的使用和编写" class="headerlink" title="7. Makefile 的使用和编写"></a>7. Makefile 的使用和编写</h1><p>在 C 程序的编译和构建过程中，<code>make</code> 是一个非常重要的工具。<code>make</code> 工具可以自动化编译和链接的过程，它依赖于一个名为 <code>Makefile</code> 的文件，该文件描述了各个源文件之间的依赖关系以及如何从源文件生成目标文件。</p>
<h2 id="7-1-什么是-Makefile"><a href="#7-1-什么是-Makefile" class="headerlink" title="7.1. 什么是 Makefile"></a>7.1. 什么是 Makefile</h2><p>Makefile 是一个包含了一系列规则（rules）和变量的文件。规则定义了目标文件的生成过程，变量则可以在多个地方重复使用同一个值。</p>
<p>一个基本的 <code>Makefile</code> 规则包含了一个目标（target），它的依赖项（dependencies）和一个命令（command）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target: dependencies</span><br><span class="line">    command</span><br></pre></td></tr></table></figure>



<h2 id="7-2-Makefile-的基本结构"><a href="#7-2-Makefile-的基本结构" class="headerlink" title="7.2. Makefile 的基本结构"></a>7.2. Makefile 的基本结构</h2><p>一个简单的 Makefile 示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myprogram: main.o utility.o</span><br><span class="line">    gcc -o myprogram main.o utility.o</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">    gcc -c main.c</span><br><span class="line"></span><br><span class="line">utility.o: utility.c</span><br><span class="line">    gcc -c utility.c</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myprogram</code> 是最终的目标，它依赖于两个 <code>.o</code> 文件，每个 <code>.o</code> 文件又各自依赖于一个 <code>.c</code> 文件。</p>
<p>如果我们在终端中运行 <code>make</code> 命令，<code>make</code> 工具会检查 <code>Makefile</code> 文件，并按照规则执行命令。如果一个 <code>.o</code> 文件的时间戳比其对应的 <code>.c</code> 文件新，<code>make</code> 工具就会跳过编译这个 <code>.c</code> 文件的步骤。</p>
<h2 id="7-3-使用变量"><a href="#7-3-使用变量" class="headerlink" title="7.3. 使用变量"></a>7.3. 使用变量</h2><p>在 <code>Makefile</code> 中，我们可以定义变量，然后在命令中使用它们。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I.</span><br><span class="line"></span><br><span class="line">%.o: %.c</span><br><span class="line">    $(CC) -c -o $@ $&lt; $(CFLAGS)</span><br><span class="line"></span><br><span class="line">myprogram: main.o utility.o</span><br><span class="line">    $(CC) -o myprogram main.o utility.o</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>CC</code> 和 <code>CFLAGS</code> 是变量，<code>$(CC)</code> 和 <code>$(CFLAGS)</code> 是对变量的引用。<code>$@</code> 和 <code>$&lt;</code> 是自动变量，<code>$@</code> 表示目标文件名，<code>$&lt;</code> 表示第一个依赖文件名。</p>
<h2 id="7-4-使用伪目标"><a href="#7-4-使用伪目标" class="headerlink" title="7.4. 使用伪目标"></a>7.4. 使用伪目标</h2><p>有时候，我们希望定义一些并不产生文件的目标，例如清理构建生成的文件。我们可以使用 <code>.PHONY</code> 伪目标来定义这种规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f *.o myprogram</span><br></pre></td></tr></table></figure>

<p>在这个示例中，如果我们运行 <code>make clean</code>，<code>make</code> 工具就会执行 <code>rm -f *.o myprogram</code> 命令，删除所有 <code>.o</code> 文件和 <code>myprogram</code> 文件。</p>
<p>以上就是 Makefile 的基础知识。理解并会用 Makefile 可以帮助你更有效地编译和构建 C 程序。在实际使用中，Makefile 可能会包含更复杂的规则和变量，但基本的思想和结构都是一样的。</p>
<h2 id="7-5-编译选项和标记"><a href="#7-5-编译选项和标记" class="headerlink" title="7.5. 编译选项和标记"></a>7.5. 编译选项和标记</h2><p>在使用 <code>make</code> 和 <code>Makefile</code> 进行 C 程序编译和链接时，你可能会遇到很多选项和标记。以下是其中一些最常见的。</p>
<p><strong>CFLAGS</strong></p>
<p><code>CFLAGS</code> 是 <code>gcc</code> (GNU Compiler Collection 的 C 编译器部分) 中用于设置 C 编译器选项的环境变量。这些选项包括优化级别、警告级别、调试信息等。</p>
<p>以下是一些常见的 <code>CFLAGS</code> 选项：</p>
<ul>
<li><code>-O</code> : 这个选项用于设置优化级别，如 <code>-O1</code>， <code>-O2</code>， <code>-O3</code> 和 <code>-Os</code>。更高的优化级别会使编译器花更多的时间来优化代码，以生成更快的程序。</li>
<li><code>-g</code> : 这个选项使编译器生成调试信息，这对于使用 gdb 等调试工具非常有用。</li>
<li><code>-Wall</code> : 这个选项使编译器生成所有的警告信息，这可以帮助你发现代码中的问题。</li>
</ul>
<p><strong>LDFLAGS</strong></p>
<p><code>LDFLAGS</code> 是 <code>gcc</code> 中用于设置链接器选项的环境变量。这些选项包括库搜索路径、链接的库等。</p>
<p>以下是一些常见的 <code>LDFLAGS</code> 选项：</p>
<ul>
<li><code>-L</code> : 这个选项用于指定库搜索路径，如 <code>-L/usr/local/lib</code>。</li>
<li><code>-l</code> : 这个选项用于指定要链接的库，如 <code>-lm</code> 指定链接数学库。</li>
</ul>
<p><strong>-I</strong></p>
<p><code>-I</code> 是 <code>gcc</code> 中用于设置头文件搜索路径的选项。例如，<code>-I/usr/local/include</code> 会使编译器在 <code>/usr/local/include</code> 目录中搜索头文件。</p>
<p><strong>-D</strong></p>
<p><code>-D</code> 是 <code>gcc</code> 中用于定义宏的选项。例如，<code>-DDEBUG</code> 会定义一个名为 <code>DEBUG</code> 的宏。</p>
<p>在 <code>Makefile</code> 中，你可以设置 <code>CFLAGS</code> 和 <code>LDFLAGS</code> 变量，然后在编译和链接命令中使用它们。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I. -g -O2 -Wall</span><br><span class="line">LDFLAGS=-L/usr/local/lib -lm</span><br><span class="line"></span><br><span class="line">myprogram: main.o utility.o</span><br><span class="line">    $(CC) $(LDFLAGS) -o $@ $^ $(CFLAGS)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，编译命令会包含 <code>-I. -g -O2 -Wall</code> 选项，链接命令会包含 <code>-L/usr/local/lib -lm</code> 选项。</p>
<h2 id="7-6-编写通用性强的-Makefile"><a href="#7-6-编写通用性强的-Makefile" class="headerlink" title="7.6. 编写通用性强的 Makefile"></a>7.6. 编写通用性强的 Makefile</h2><p>当我们有很多 <code>.c</code> 文件时，如果每次增加或删除 <code>.c</code> 文件都需要修改 <code>Makefile</code>，那么将会非常麻烦。一个解决办法是编写一个通用性强的 <code>Makefile</code>，使其能自动检测并编译所有 <code>.c</code> 文件。</p>
<p>以下是一个示例，这个 <code>Makefile</code> 可以自动检测所有 <code>.c</code> 文件，并编译它们生成对应的 <code>.o</code> 文件，最后链接所有 <code>.o</code> 文件生成目标程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-I.</span><br><span class="line"></span><br><span class="line"># 使用 Shell 命令查找所有 .c 文件</span><br><span class="line">SRCS=$(shell find . -name &quot;*.c&quot;)</span><br><span class="line"># 把 .c 文件列表转化为 .o 文件列表</span><br><span class="line">OBJS=$(patsubst %.c,%.o,$(SRCS))</span><br><span class="line"></span><br><span class="line">myprogram: $(OBJS)</span><br><span class="line">    $(CC) -o $@ $^ $(CFLAGS)</span><br><span class="line"></span><br><span class="line">%.o: %.c</span><br><span class="line">    $(CC) -c -o $@ $&lt; $(CFLAGS)</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f $(OBJS) myprogram</span><br></pre></td></tr></table></figure>

<p>在这个 <code>Makefile</code> 中：</p>
<ul>
<li><code>$(shell find . -name &quot;*.c&quot;)</code> 使用 <code>find</code> 命令查找所有 <code>.c</code> 文件。</li>
<li><code>$(patsubst %.c,%.o,$(SRCS))</code> 把 <code>.c</code> 文件列表转化为 <code>.o</code> 文件列表。</li>
<li><code>myprogram: $(OBJS)</code> 指定了 <code>myprogram</code> 依赖于所有 <code>.o</code> 文件。</li>
<li><code>%.o: %.c</code> 是一个模式规则，它指定了如何从 <code>.c</code> 文件生成 <code>.o</code> 文件。</li>
</ul>
<p>当我们运行 <code>make</code> 命令时，<code>make</code> 工具会自动检测并编译所有 <code>.c</code> 文件，然后链接所有 <code>.o</code> 文件生成目标程序。</p>
<p>这个 <code>Makefile</code> 具有很好的通用性，无论我们增加或删除 <code>.c</code> 文件，都不需要修改 <code>Makefile</code>。我们只需要保证所有 <code>.c</code> 文件都在 <code>Makefile</code> 所在目录或其子目录下即可。</p>
<h2 id="7-7-调试-Makefile"><a href="#7-7-调试-Makefile" class="headerlink" title="7.7. 调试 Makefile"></a>7.7. 调试 Makefile</h2><p>当你编写的 <code>Makefile</code> 没有按预期的方式工作时，你可能需要调试它。幸运的是，<code>make</code> 工具提供了一些选项来帮助我们调试 <code>Makefile</code>。</p>
<p><code>-n</code> 或 <code>--just-print</code> 选项可以让 <code>make</code> 工具只打印命令，而不真正执行它们。这个选项对于检查 <code>Makefile</code> 中的命令是否正确非常有用。</p>
<p>例如，你可以运行 <code>make -n myprogram</code> 来查看生成 <code>myprogram</code> 的命令是否正确。</p>
<p><code>-d</code> 选项会让 <code>make</code> 工具打印大量的调试信息，包括它是如何读取 <code>Makefile</code>，如何决定规则的依赖关系，以及如何执行命令等等。这个选项非常有用，但它可能会产生很多输出。</p>
<p><code>$(warning ...)</code> 函数会打印一条警告信息，然后继续执行 <code>make</code>。<code>$(info ...)</code> 函数会打印一条信息，但不会产生警告或错误。这两个函数可以用来检查变量的值或调试 <code>Makefile</code>。</p>
<p>例如，你可以在 <code>Makefile</code> 中添加一行 <code>$(info SRCS is $(SRCS))</code> 来查看 <code>SRCS</code> 变量的值。</p>
<p><code>--debug</code> 或 <code>-d</code> 选项可以让 <code>make</code> 打印出大量的调试信息，这对于理解 <code>make</code> 是如何解析 <code>Makefile</code>，以及它是如何决定哪些目标需要重新构建的，非常有用。</p>
<p><code>make</code> 是通过比较目标和它的依赖项的时间戳来决定是否需要重新构建目标。如果你的 <code>Makefile</code> 没有按预期的方式工作，可能是因为文件的时间戳有问题。你可以使用 <code>ls -l</code> 命令来查看文件的时间戳。</p>
<p>调试 <code>Makefile</code> 可能需要一些耐心和实践，但是一旦你理解了 <code>make</code> 工具的工作方式，你就能编写出更强大、更灵活的 <code>Makefile</code>。</p>
<h2 id="7-8-xuedue"><a href="#7-8-xuedue" class="headerlink" title="7.8. xuedue"></a>7.8. xuedue</h2><ul>
<li>符号信息</li>
</ul>
<p>file 查看文件信息，可以看到符号信息，not stripped 就是没有去符号</p>
<p>使用 strip filename 可以去符号（strip可能在其他目录中）</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Shell-常用命令速查表"><a href="#Shell-常用命令速查表" class="headerlink" title="Shell 常用命令速查表"></a>Shell 常用命令速查表</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>常用选项</th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code></td>
<td>列出目录中的文件和子目录</td>
<td><code>-l</code>：长格式 &lt; br&gt; <code>-a</code>：包括隐藏文件 &lt; br&gt; <code>-h</code>：易读的文件大小 &lt; br&gt; <code>-t</code>：按修改时间排序 &lt; br&gt; <code>-r</code>：反向排序</td>
</tr>
<tr>
<td><code>cd</code></td>
<td>改变当前目录</td>
<td><code>..</code>：上级目录 &lt; br&gt; <code>~</code>：用户主目录 &lt; br&gt; <code>-</code>：上次工作目录</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>打印当前工作目录</td>
<td>-</td>
</tr>
<tr>
<td><code>cp</code></td>
<td>复制文件或目录</td>
<td><code>-r</code>：复制目录 &lt; br&gt; <code>-p</code>：保留文件属性</td>
</tr>
<tr>
<td><code>mv</code></td>
<td>移动或重命名文件或目录</td>
<td>-</td>
</tr>
<tr>
<td><code>rm</code></td>
<td>删除文件或目录</td>
<td><code>-r</code>：删除目录 &lt; br&gt; <code>-f</code>：强制删除</td>
</tr>
<tr>
<td><code>cat</code></td>
<td>查看或连接文件内容</td>
<td><code>-n</code>：显示行号</td>
</tr>
<tr>
<td><code>less</code></td>
<td>分页查看文件内容</td>
<td>-</td>
</tr>
<tr>
<td><code>grep</code></td>
<td>搜索文本</td>
<td><code>-i</code>：忽略大小写 &lt; br&gt; <code>-r</code>：递归搜索 &lt; br&gt; <code>-v</code>：显示不匹配行</td>
</tr>
<tr>
<td><code>find</code></td>
<td>查找文件或目录</td>
<td><code>-name</code>：按名称查找 &lt; br&gt; <code>-type</code>：按类型查找 &lt; br&gt; <code>-size</code>：按大小查找</td>
</tr>
<tr>
<td><code>tar</code></td>
<td>打包或解压缩文件</td>
<td><code>-c</code>：创建归档文件 &lt; br&gt; <code>-x</code>：提取文件 &lt; br&gt; <code>-f</code>：指定文件名 &lt; br&gt; <code>-v</code>：显示详细信息 &lt; br&gt; <code>-z</code>：gzip 压缩 / 解压 &lt; br&gt; <code>-j</code>：bzip2 压缩 / 解压</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Paper-LLM</title>
    <url>/2025/02/23/Paper/Paper-LLM/</url>
    <content><![CDATA[<h1 id="LLM-从入门到入土"><a href="#LLM-从入门到入土" class="headerlink" title="LLM 从入门到入土"></a>LLM 从入门到入土</h1><p>开头附上大语言模型的发展时间线</p>
<p><img src="image-20250314094255692.png" alt="image-20250314094255692"></p>
<p>按照时间线，典型开源大模型</p>
<table>
<thead>
<tr>
<th>模型名称</th>
<th>发布时间</th>
<th>参数量（个）</th>
<th>模型类型</th>
<th>预训练数据量</th>
</tr>
</thead>
<tbody><tr>
<td>T5</td>
<td>2019 年 10 月</td>
<td>110 亿</td>
<td>基础模型</td>
<td>1 万亿个词元</td>
</tr>
<tr>
<td>PanGu-α</td>
<td>2021 年 4 月</td>
<td>130 亿</td>
<td>基础模型</td>
<td>1.1 万亿个词元</td>
</tr>
<tr>
<td>CPM-2</td>
<td>2021 年 6 月</td>
<td>1980 亿</td>
<td>基础模型</td>
<td>2.6 万亿个词元</td>
</tr>
<tr>
<td>CodeGen</td>
<td>2022 年 3 月</td>
<td>160 亿</td>
<td>基础模型</td>
<td>5770 亿个词元</td>
</tr>
<tr>
<td>GPT-NeoX-20B</td>
<td>2022 年 4 月</td>
<td>200 亿</td>
<td>基础模型</td>
<td>825GB</td>
</tr>
<tr>
<td>OPT</td>
<td>2022 年 5 月</td>
<td>1750 亿</td>
<td>基础模型</td>
<td>1800 亿个词元</td>
</tr>
<tr>
<td><a href="https://chatglm.cn/">GLM</a></td>
<td>2022 年 10 月</td>
<td>1300 亿</td>
<td>基础模型</td>
<td>4000 亿个词元</td>
</tr>
<tr>
<td>Flan-T5</td>
<td>2022 年 10 月</td>
<td>110 亿</td>
<td>对话模型</td>
<td>-</td>
</tr>
<tr>
<td>BLOOM</td>
<td>2022 年 11 月</td>
<td>1760 亿</td>
<td>基础模型</td>
<td>3660 亿个词元</td>
</tr>
<tr>
<td>BLOOMZ</td>
<td>2022 年 11 月</td>
<td>1760 亿</td>
<td>对话模型</td>
<td>-</td>
</tr>
<tr>
<td>OPT-IML</td>
<td>2022 年 12 月</td>
<td>1750 亿</td>
<td>对话模型</td>
<td>-</td>
</tr>
<tr>
<td><a href="https://llama.meta.com/">LLaMa</a></td>
<td>2023 年 2 月</td>
<td>652 亿</td>
<td>基础模型和对话模型</td>
<td>1.4 万亿个词元</td>
</tr>
<tr>
<td>MOSS</td>
<td>2023 年 2 月</td>
<td>160 亿</td>
<td>对话模型</td>
<td>-</td>
</tr>
<tr>
<td>ChatGLM-6B</td>
<td>2023 年 4 月</td>
<td>62 亿</td>
<td>基础模型和对话模型</td>
<td>-</td>
</tr>
<tr>
<td>Alpaca</td>
<td>2023 年 4 月</td>
<td>130 亿</td>
<td>对话模型</td>
<td>-</td>
</tr>
<tr>
<td>Falcon</td>
<td>2023 年 5 月</td>
<td>400 亿</td>
<td>基础模型</td>
<td>1 万亿个词元</td>
</tr>
<tr>
<td>OpenLLaMA</td>
<td>2023 年 5 月</td>
<td>130 亿</td>
<td>基础模型</td>
<td>1 万亿个词元</td>
</tr>
<tr>
<td>Gorilla</td>
<td>2023 年 5 月</td>
<td>67 亿</td>
<td>对话模型</td>
<td>-</td>
</tr>
<tr>
<td><a href="https://www.baichuan-ai.com/chat">Baichuan</a></td>
<td>2023 年 6 月</td>
<td>70-130 亿</td>
<td>基础模型和对话模型</td>
<td>1.4 万亿个词元</td>
</tr>
<tr>
<td>LLaMA2</td>
<td>2023 年 7 月</td>
<td>70-700 亿</td>
<td>基础模型和对话模型</td>
<td>2.0 万亿个词元</td>
</tr>
<tr>
<td><a href="https://tongyi.aliyun.com/">Qwen</a></td>
<td>2023 年 8 月</td>
<td>70 亿</td>
<td>基础模型和对话模型</td>
<td>3.0 万亿个词元</td>
</tr>
<tr>
<td>ChatGLM3-6B</td>
<td>2023 年 9 月</td>
<td>60 亿</td>
<td>基础模型和对话模型</td>
<td>1.0 万亿个词元</td>
</tr>
<tr>
<td>Mistral 7B</td>
<td>2023 年 9 月</td>
<td>70 亿</td>
<td>基础模型和对话模型</td>
<td>8.0 万亿个词元</td>
</tr>
<tr>
<td>InternLM-20B</td>
<td>2023 年 9 月</td>
<td>200 亿</td>
<td>基础模型和对话模型</td>
<td>2.3 万亿个词元</td>
</tr>
<tr>
<td>Grok-1</td>
<td>2023 年 10 月</td>
<td>3140 亿</td>
<td>基础模型和对话模型</td>
<td>-</td>
</tr>
<tr>
<td>DeepSeek-LLM</td>
<td>2023 年 11 月</td>
<td>70-670 亿</td>
<td>基础模型和对话模型</td>
<td>2.0 万亿个词元</td>
</tr>
<tr>
<td>Qwen 1.5</td>
<td>2024 年 2 月</td>
<td>5-720 亿</td>
<td>基础模型和对话模型</td>
<td>3.0 万亿个词元</td>
</tr>
<tr>
<td>Gemma</td>
<td>2024 年 2 月</td>
<td>20-70 亿</td>
<td>基础模型和对话模型</td>
<td>6.0 万亿个词元</td>
</tr>
<tr>
<td>MiniCPM-2B</td>
<td>2024 年 2 月</td>
<td>20 亿</td>
<td>基础模型和对话模型</td>
<td>1.0 万亿个词元</td>
</tr>
<tr>
<td>Grok-1</td>
<td>2024 年 2 月</td>
<td>3140 亿</td>
<td>对话模型</td>
<td>-</td>
</tr>
<tr>
<td>LLaMA 3</td>
<td>2024 年 4 月</td>
<td>80-700 亿</td>
<td>基础模型和对话模型</td>
<td>15.0 万亿个词元</td>
</tr>
<tr>
<td>Phi-3</td>
<td>2024 年 4 月</td>
<td>38-140 亿</td>
<td>对话模型</td>
<td>4.8 万亿个词元</td>
</tr>
<tr>
<td>GLM-4-9B</td>
<td>2024 年 6 月</td>
<td>90 亿</td>
<td>基础模型和对话模型</td>
<td>10.0 万亿个词元</td>
</tr>
<tr>
<td>LLaMA 3.1</td>
<td>2024 年 7 月</td>
<td>80-4050 亿</td>
<td>基础模型和对话模型</td>
<td>15.0 万亿个词元</td>
</tr>
<tr>
<td>Qwen 2.5</td>
<td>2024 年 9 月</td>
<td>5-720 亿</td>
<td>基础模型和对话模型</td>
<td>18.0 万亿个词元</td>
</tr>
<tr>
<td>LLaMA 3.2</td>
<td>2024 年 9 月</td>
<td>10-900 亿</td>
<td>基础模型和对话模型</td>
<td>15.0 万亿个词元</td>
</tr>
<tr>
<td>Hunyuan-Large</td>
<td>2024 年 11 月</td>
<td>3890 亿</td>
<td>基础模型和对话模型</td>
<td>7.0 万亿个词元</td>
</tr>
<tr>
<td><a href="https://www.deepseek.com/">DeepSeek</a>-V3</td>
<td>2024 年 12 月</td>
<td>6710 亿</td>
<td>对话模型</td>
<td>14.8 万亿个词元</td>
</tr>
<tr>
<td>Phi-4</td>
<td>2024 年 12 月</td>
<td>140 亿</td>
<td>对话模型</td>
<td>10.0 万亿个词元</td>
</tr>
<tr>
<td>DeepSeek-R1</td>
<td>2025 年 1 月</td>
<td>6710 亿</td>
<td>推理模型</td>
<td>14.8 万亿个词元</td>
</tr>
</tbody></table>
<p>按照时间线，典型闭源大模型</p>
<table>
<thead>
<tr>
<th>模型名称</th>
<th>发布时间</th>
<th>发布公司</th>
<th>参数量（个）</th>
<th>模型类型</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://chat.openai.com/">GPT</a>-3</td>
<td>2020 年 5 月</td>
<td>OpenAI</td>
<td>1750 亿</td>
<td>基础模型</td>
</tr>
<tr>
<td>ERNIE 3.0</td>
<td>2021 年 7 月</td>
<td>百度</td>
<td>100 亿</td>
<td>基础模型</td>
</tr>
<tr>
<td><a href="https://claude.ai/chats">Claude</a></td>
<td>2021 年 12 月</td>
<td>Anthropic</td>
<td>520 亿</td>
<td>基础模型</td>
</tr>
<tr>
<td>InstructGPT</td>
<td>2022 年 3 月</td>
<td>OpenAI</td>
<td>1750 亿</td>
<td>对话模型</td>
</tr>
<tr>
<td>PaLM</td>
<td>2022 年 4 月</td>
<td>Google</td>
<td>5400 亿</td>
<td>基础模型</td>
</tr>
<tr>
<td>ChatGPT 3.5</td>
<td>2022 年 11 月</td>
<td>OpenAI</td>
<td>1750 亿</td>
<td>对话模型</td>
</tr>
<tr>
<td>GPT-4</td>
<td>2023 年 3 月</td>
<td>OpenAI</td>
<td>17600 亿</td>
<td>对话模型</td>
</tr>
<tr>
<td>PanGu-Σ</td>
<td>2023 年 3 月</td>
<td>华为</td>
<td>10850 亿</td>
<td>对话模型</td>
</tr>
<tr>
<td>ChatGLM</td>
<td>2023 年 3 月</td>
<td>智谱华章</td>
<td>1300 亿</td>
<td>对话模型</td>
</tr>
<tr>
<td><a href="https://yiyan.baidu.com/">文心一言</a></td>
<td>2023 年 4 月</td>
<td>百度</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td>通义千问</td>
<td>2023 年 5 月</td>
<td>阿里巴巴</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td>MinMax</td>
<td>2023 年 5 月</td>
<td>稀宇科技</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td>星火</td>
<td>2023 年 5 月</td>
<td>科大讯飞</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td>浦语书生</td>
<td>2023 年 6 月</td>
<td>浦江实验室</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td>Claude 2</td>
<td>2023 年 7 月</td>
<td>Anthropic</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td>Baichuan2</td>
<td>2023 年 9 月</td>
<td>百川</td>
<td>530 亿</td>
<td>对话模型</td>
</tr>
<tr>
<td>Kimi</td>
<td>2023 年 10 月</td>
<td>月之暗面</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td><a href="https://gemini.google.com/">Gemini</a></td>
<td>2023 年 12 月</td>
<td>Google</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td>GLM-4</td>
<td>2024 年 1 月</td>
<td>智谱华章</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td>Claude 3</td>
<td>2024 年 1 月</td>
<td>Anthropic</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td>GPT-4o</td>
<td>2024 年 5 月</td>
<td>OpenAI</td>
<td>2000 亿</td>
<td>对话模型</td>
</tr>
<tr>
<td>豆包</td>
<td>2024 年 5 月</td>
<td>字节跳动</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td><a href="https://xinghuo.xfyun.cn/">星火 2.0</a></td>
<td>2024 年 6 月</td>
<td>科大讯飞</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td>Step-2</td>
<td>2024 年 7 月</td>
<td>阶跃星辰</td>
<td>10000 亿</td>
<td>对话模型</td>
</tr>
<tr>
<td>GPT-o1</td>
<td>2024 年 9 月</td>
<td>OpenAI</td>
<td>3000 亿</td>
<td>对话模型</td>
</tr>
<tr>
<td>Claude 3.5</td>
<td>2024 年 10 月</td>
<td>Anthropic</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td>GPT-o3</td>
<td>2024 年 12 月</td>
<td>OpenAI</td>
<td>-</td>
<td>推理模型</td>
</tr>
<tr>
<td>豆包 1.5Pro</td>
<td>2025 年 1 月</td>
<td>字节跳动</td>
<td>-</td>
<td>对话模型</td>
</tr>
<tr>
<td>Grok-3</td>
<td>2025 年 2 月</td>
<td>XAI</td>
<td>-</td>
<td>对话推理模型</td>
</tr>
</tbody></table>
<p>其中比较出名和重要的大语言模型</p>
<table>
<thead>
<tr>
<th>模型名称</th>
<th>链接</th>
<th>发布日期</th>
<th>是否开源</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GPT-4</td>
<td><a href="https://chat.openai.com/">OpenAI</a></td>
<td>2023 年 3 月</td>
<td>闭源</td>
<td>知识型模型，知识截至2021 年 9 月</td>
</tr>
<tr>
<td>GPT-4o</td>
<td></td>
<td>2024 年 5 月</td>
<td>闭源</td>
<td>知识型模型，知识截至2023 年 10 月</td>
</tr>
<tr>
<td>GPT-4.5</td>
<td></td>
<td>2025 年 2 月</td>
<td>闭源</td>
<td>知识型模型，知识截至2023 年 10 月</td>
</tr>
<tr>
<td>GPT-4o mini</td>
<td></td>
<td>2024 年 7 月</td>
<td>闭源</td>
<td>知识型模型，知识截至2023 年 10 月</td>
</tr>
<tr>
<td>o1</td>
<td></td>
<td>2024 年 9 月</td>
<td>闭源</td>
<td>推理型模型，知识截至2023 年 10 月</td>
</tr>
<tr>
<td>o1 mini</td>
<td></td>
<td>2024 年 12 月</td>
<td>闭源</td>
<td>推理型模型，知识截至2023 年 10 月</td>
</tr>
<tr>
<td>o3 mini</td>
<td></td>
<td>2025 年 1 月</td>
<td>闭源</td>
<td>推理型模型，知识截至2023 年 10 月</td>
</tr>
<tr>
<td>Claude 3</td>
<td><a href="https://claude.ai/chats">Claude</a></td>
<td>2024 年 3 月 4 日</td>
<td>闭源</td>
<td></td>
</tr>
<tr>
<td>Claude 3.5 Sonnet</td>
<td></td>
<td>2024 年 10 月</td>
<td>闭源</td>
<td></td>
</tr>
<tr>
<td>Claude 3.7 Sonnet</td>
<td></td>
<td>2025 年 2 月</td>
<td>闭源</td>
<td></td>
</tr>
<tr>
<td>Gemini 2.0 Pro</td>
<td><a href="https://gemini.google.com/">Gemini</a></td>
<td></td>
<td>闭源</td>
<td>谷歌开发</td>
</tr>
<tr>
<td>Gemini 2.0 Flash</td>
<td></td>
<td></td>
<td>闭源</td>
<td></td>
</tr>
<tr>
<td>Gemini 2.0 Flash-Lite</td>
<td></td>
<td></td>
<td>闭源</td>
<td></td>
</tr>
<tr>
<td>Gemini 2.0 Flash Thinking</td>
<td></td>
<td></td>
<td>闭源</td>
<td>推理型模型</td>
</tr>
<tr>
<td>文心一言</td>
<td><a href="https://yiyan.baidu.com/">文心一言</a></td>
<td>2019 年发布基础版本</td>
<td>闭源</td>
<td>百度</td>
</tr>
<tr>
<td>火星大模型</td>
<td><a href="https://xinghuo.xfyun.cn/">火星大模型</a></td>
<td>2023 年 5 月首次发布</td>
<td>闭源</td>
<td>科大讯飞</td>
</tr>
<tr>
<td>LLaMA 1.0</td>
<td><a href="https://llama.meta.com/">LLaMa 官方地址</a></td>
<td>2023 年 2 月</td>
<td>开源</td>
<td>Meta AI</td>
</tr>
<tr>
<td>LLaMA 2.0</td>
<td><a href="https://github.com/facebookresearch/llama">LLaMa 开源地址</a></td>
<td>2023 年 7 月</td>
<td>开源</td>
<td></td>
</tr>
<tr>
<td>LLaMA 3.0</td>
<td></td>
<td>2024 年 4 月</td>
<td>开源</td>
<td></td>
</tr>
<tr>
<td>LLaMA 3.1</td>
<td></td>
<td>2024 年 7 月</td>
<td>开源</td>
<td></td>
</tr>
<tr>
<td>LLaMA 3.3</td>
<td></td>
<td>2024 年 12 月</td>
<td>开源</td>
<td>只开源了 70B 的指令模型</td>
</tr>
<tr>
<td>ChatGLM</td>
<td><a href="https://chatglm.cn/">GLM使用地址</a></td>
<td>2023 年 3 月</td>
<td>开源</td>
<td>清华大学和智谱 AI 等合作研发的语言大模型</td>
</tr>
<tr>
<td>GLM4</td>
<td><a href="https://github.com/THUDM/GLM-4">GLM开源地址</a></td>
<td>2024 年 1 月</td>
<td>开源</td>
<td></td>
</tr>
<tr>
<td>Baichuan-7B/13B</td>
<td><a href="https://www.baichuan-ai.com/chat">百川使用地址</a></td>
<td>2023 年 6 月 15 日</td>
<td>开源</td>
<td>百川智能</td>
</tr>
<tr>
<td>Baichuan2</td>
<td><a href="https://github.com/baichuan-inc">百川开源地址</a></td>
<td>2023 年 9 月 6 日</td>
<td>开源</td>
<td></td>
</tr>
<tr>
<td>Baichuan3</td>
<td></td>
<td>2024 年 1 月 29 日</td>
<td>闭源</td>
<td></td>
</tr>
<tr>
<td>DeepSeek基础模型</td>
<td><a href="https://www.deepseek.com/">deepseek使用地址</a></td>
<td>2023 年 11 月 12 日</td>
<td>开源</td>
<td>深度求索 (DeepSeek) 团队</td>
</tr>
<tr>
<td>DeepSeek-V2</td>
<td><a href="https://github.com/deepseek-ai">deepseek开源地址</a></td>
<td>2024 年 3 月 15 日</td>
<td>开源</td>
<td></td>
</tr>
<tr>
<td>DeepSeek-V2.5</td>
<td></td>
<td>2024 年 5 月 31 日</td>
<td>开源</td>
<td></td>
</tr>
<tr>
<td>DeepSeek-R1</td>
<td></td>
<td>2024 年 10 月</td>
<td>开源</td>
<td></td>
</tr>
<tr>
<td>DeepSeek-R1-Zero</td>
<td></td>
<td>2025 年 2 月</td>
<td>开源</td>
<td></td>
</tr>
<tr>
<td>Qwen</td>
<td><a href="https://tongyi.aliyun.com/">通义千问使用地址</a></td>
<td>2023 年 9 月</td>
<td>开源</td>
<td>阿里巴巴</td>
</tr>
<tr>
<td>Qwen2</td>
<td><a href="https://github.com/QwenLM">通义千问开源地址</a></td>
<td>2024 年 6 月 6 日</td>
<td>开源</td>
<td></td>
</tr>
<tr>
<td>Qwen2.5</td>
<td></td>
<td>2025 年 3 月 1 日</td>
<td>开源</td>
<td></td>
</tr>
<tr>
<td>QwQ-32B</td>
<td></td>
<td></td>
<td>开源</td>
<td>性能可与具备 671B 参数（37B 激活参数）的 DeepSeek-R1 媲美</td>
</tr>
</tbody></table>
<h2 id="术语汇总"><a href="#术语汇总" class="headerlink" title="术语汇总"></a>术语汇总</h2><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><ul>
<li>AI（Artificial General）：「人工智能」涵盖了各种技术和领域，目的是让计算机模仿、延伸甚至超越人类智能。</li>
<li>AIGC（Artificial Intelligence Generated Content）：「人工智能生成内容」指的是利用AI技术，尤其是机器学习和深度学习模型，自动生成内容，如文本、图像、音乐或视频。AIGC通常专注于特定的创作任务，而不具备 AGI 的广泛智能和通用学习能力</li>
<li>AGI（Artificial General Intelligence）：「通用人工智能」指能够像人类一样理解、学习并应用知识的系统，涵盖从问题解决到创造性任务的广泛领域</li>
<li>NN（Neural Network）：「神经网络」一种模仿生物神经网络（例如人脑）的结构和功能的数学模型或计算模型，它主要用于对函数进行估计或近似，特别适用于处理复杂的非线性问题</li>
<li>FNN（Feed-forward Neural Network）：「前馈神经网络」采用前馈传播范式的神经网络可以统称为前馈神经网络，FNN 网络结构中仅包含正向通路</li>
<li>RNN（Recurrent Neural Network）：「循环神经网络」一类网络连接中包含环路的 神经网络的总称，因此，RNN 可以基于历史规律，对未来进行预测。基于 RNN 的语言模型，以词序列作为输入，基于被循环编码的上文和当前词来预测下一个词出现的概率</li>
<li>CNN（Convolutional Neural Network）：「卷积神经网络」使用卷积层来自动并有效地检测视觉输入中的空间层次特征，广泛应用于图像和视频分析等领域</li>
<li>MLP（Multi-Layer Perception）：「多层感知机」也叫人工神经网络（ANN，Artificial Neural Network），他的特点是层级之间为全连接，通常用于分类回归任务；</li>
<li>DNN（Deep Neural Network）：「深度神经网络」和 ANN 类似，但是其中间部分可以是多个全连接层，也可以是定义的任何技术或者数学公式来塑造中间网络的每一层或者每一个部分</li>
<li>DL（Deep Learning）：「深度学习」是机器学习中的一种基于人工神经网络的机器学习方法，其关键在于通过多层神经网络对输入数据进行逐层抽象和表示学习，从而实现对复杂数据结构和非线性关系的建模，目标是学习样本数据的内在规律和表示层次，最终目标是让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据</li>
<li>NLP（Natural Language Processing）：「自然语言处理」研究如何让计算机读懂人类语言，即将人的自然语言转换为计算机可以阅读的指令，其任务的目标就是在自然语言领域让机器拥有人类的智慧，理解句子的含义</li>
</ul>
<p>关于人工智能、机器学习、人工神经网络和深度学习的关系</p>
<p><img src="image-20250312151332747.png" alt="image-20250312151332747"></p>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><ul>
<li>GAN（Generative adversarial network）：「生成对抗网络」是一种图像生成网络，通过生成器和判别器对抗进行对抗训练</li>
<li>DDPM（Denoising Diffusion Probabilistic Model）：「扩散模型」是2020年提出的一种生成模型，可以用于图像生成</li>
<li>SD（Stable Diffusion）：「潜在扩散模型」，目前市面上绝大部分 AI 图文生成都是基于 SD 实现的</li>
<li>AR（Autoregressive Model）：「自回归模型」是用自身做回归变量的过程，即利用前期若干时刻的随机变量的线性组合来描述以后某时刻随机变量的线性回归模型，它是时间序列中的一种常见形式</li>
<li>LSTM（Long Short-Term Memory）：「长短时记忆网络」一种特殊的 RNN 架构，解决 RNN 处理长序列数据时面临着严重的梯度消失问题，得网络能够更好地处理序列中的长期依赖关系</li>
<li>Transformer：一类基于注意力机制（Attention）的模块化构建的神经网络结构，基于 Transformer 的语言模型，以词序列作为输入，基于一定长度的上文和当前词来预测下一个词出现的概率</li>
<li>BERT（Bidirectional Encoder Representation from Transformers）：2018年10月由Google AI研究院基于 Transformer 提出的一种预训练模型</li>
<li>MOE（(Mixed Expert Model）：「混合专家模型」希望在有限计算资源预算下，用更少训练步数训练更大模型，核心思想是模型不同部分（即“专 家”）专注不同任务或数据层面。</li>
</ul>
<h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><ul>
<li>Batch：「批/一批样本」指将整个训练样本分成若干个批，一次输入模型的一组样本</li>
<li>Batch Size：「批大小」指每批样本的大小，一次输入模型的一组样本的具体样本数量</li>
<li>Step：「步骤」表示在一个 epoch 中模型进行一次参数更新的操作</li>
<li>Iteration：「迭代」指训练一个 Batch 就是一次 Iteration</li>
<li>Epoch：一个 Epoch 就是将所有训练样本训练一次的过程（训练一次包括前向传播、计算损失、反向传播和参数更新）</li>
<li>LR（Learning Rate）：「学习率」是深度学习中一个至关重要的超参数，它决定了模型在训练过程中更新权重参数的速度与方向</li>
<li>Loss：「损失函数」衡量的是模型预测值与真实值之间的差异，通过反向传播指导模型参数更新的目标和方向</li>
<li>forward propagation：「前向传播」指的是按顺序(从输入层到输出层)计算和存储神经网络中每层的结果</li>
<li>BP（backward propagation）：「反向传播」指的是计算神经网络参数梯度的方法，其原理是基于微积分中的链式规则，按相反的顺序从输出层到输入层遍历网络，依次计算每个中间变量和参数的梯度</li>
<li>GD（gradient descent）：「梯度下降」是一种优化算法，也是神经网络模型训练中最为常见的优化器，还有很多其他的优化器例如「随机梯度下降」和「小批量随机梯度下降」等等</li>
<li>Vanishing Gradients：「梯度消失」是指在深层神经网络的反向传播中，梯度逐层指数级减小，导致浅层网络权重几乎不更新，无法有效学习</li>
<li>Exploding Gradients：「梯度爆炸」是指梯度逐层指数级增大，导致权重更新步长过大，模型参数剧烈震荡甚至溢出（NaN）</li>
<li>Finetune：「微调」实际上就是对一个已经训练好的模型，冻结模型部分权重，再用特定训练集重新训练并更新其余权重</li>
<li>SFT（Supervised Fine-Tuning）：「有监督微调」就是使用已标注的数据集来进行微调</li>
<li>TensorFlow：一个广泛使用的深度学习框架</li>
<li>Pytorch：另一个广泛使用的深度学习框架</li>
</ul>
<h3 id="LLM-相关"><a href="#LLM-相关" class="headerlink" title="LLM 相关"></a>LLM 相关</h3><ul>
<li>LM（Language Models）：「语言模型」是一种「人工智能系统」，旨在处理、理解和生成类似人类的语言。它们从大型数据集中学习模式和结构，使得能够产生连贯且上下文相关的文本，应用于翻译、摘要、聊天机器人和内容生成等领域</li>
<li>LLM（Large Language Models）:「大语言模型」和「语言模型」交替使用，但严格来说，LLMs 专指那些包含数百万甚至数十亿参数的语言模型</li>
<li>PEFT（Parameter-Efficient Fine-Tuning）：「参数高效微调」旨在避免微调全部参数，减少在微调过程中需要更新的参数数量和计算开销，从而提高微调大语言模型的效率。</li>
<li>LoRA（Low-Rank Adaptation）：「低秩适应」是参数高效微调最常用的方法，本质就是用更少的训练参数来近似LLM全参数微调所得的增量参数，从而达到使用更少显存占用的高效微调，其核心思想是，在冻结预训练模型权重后，将可训练的低秩分解矩阵注入到的 Transformer 架构的每一层中，从而大大减少了在下游任务上的可训练参数量，在推理时，对于使用LoRA的模型来说，可直接将原预训练模型权重与训练好的LoRA权重合并，因此在推理时不存在额外开销。</li>
<li>RLHF（Reinforcement Learning from Human Feedback）：「人类反馈强化学习」是由 InstructGPT 模型提出的一种强化学习训练方法</li>
<li>Agent：「智能体」是一种能够自主感知环境并采取行动以实现特定目标的实体</li>
<li>LLaMA（Large Language Model Meta AI）：「LLaMA」模型是由 Meta AI 开发的一系列大语言模 型，其模型权重在非商业许可证下向学术界开放，推动了大语言模型的“共创”和知识共享</li>
<li>Prompt：「指令」是指向模型提供输入以引导其生成特定输出的文本或指令</li>
<li>ICL（In-Context Learning）：「上下文学习」能力指语言模型能够通过给定的任务说明或示例等信息来掌握处理新任务的能力</li>
<li>COT（Chain of Thought）：「思维链」是一种改进的提示策略，用于提高 LLM 在复杂推理任务中的性能，如算术推理、常识推理和符号推理</li>
<li>RAG（Retrieval-Augmented Generation）：「检索增强生成」指从外部数据库中检索出相关信息来辅助改善大语言模型 生成质量的系统</li>
<li>PTQ（Post-Training Quantization）：「训练后量化」是一种对已完成训练的模型进行量化的方法， 无需重新训练原有模型，从而避免了高昂的计算成本。</li>
<li>QAT（Quantization-Aware Training）：「量化感知训练」通过在模型训练过程中整合模拟量化效应 的层，使权重适应量化引起的误差，从而提高任务性能。</li>
</ul>
<h2 id="大型语言模型简史1"><a href="#大型语言模型简史1" class="headerlink" title="大型语言模型简史1"></a>大型语言模型简史<a href="#refer-anchor-1"><sup>1</sup></a></h2><p>本篇博客更多的是以科普为主，因此不摘取具体的技术性内容，想要了解的可以自行查看原文或者网上搜索相关内容</p>
<h3 id="LLM-简述"><a href="#LLM-简述" class="headerlink" title="LLM 简述"></a>LLM 简述</h3><p>大多数 LLMs 以「自回归方式」（Autoregressive）操作，这意味着它们根据前面的文本预测下一个字的「概率分布」(propability distribution)</p>
<p><img src="%E6%96%87%E5%AD%97%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83.png" alt="文字概率分布"></p>
<p>LLM 的自回归特性使其能够根据前面内容提供的上下文，逐字生成文本。从一个「提示」(prompt)开始，模型会逐步预测下一个字，直到完成整个序列或达到预设的停止条件，尤如文字接龙游戏</p>
<p><img src="%E6%96%87%E5%AD%97%E6%8E%A5%E9%BE%99.png" alt="文字接龙"></p>
<p>通过这种逐字生成的方式，LLM可以创作出逻辑连贯且贴合上下文的内容，成为创意写作、对话生成以及代码补全等任务的强大工具。</p>
<h3 id="Transformer（2017）"><a href="#Transformer（2017）" class="headerlink" title="Transformer（2017）"></a>Transformer（2017）</h3><p>2017年，Vaswani 等人通过其开创性论文<strong>《Attention is All You Need》</strong>引入了 Transformer 架构，这标志着自然语言处理（NLP）领域的一个重要转折点。Transformer 解决了早期模型（如循环神经网络 RNN 和长短期记忆网络 LSTM）的关键限制。这些传统模型在处理长程依赖性和顺序输入时面临诸多挑战，例如计算效率低下、训练时间过长以及梯度消失问题。这些问题使得基于 RNN 或 LSTM 的语言模型难以实现高效且准确的性能。而 Transformer 的出现克服了这些障碍，彻底改变了 NLP 领域的研究范式，并为现代大型语言模型的发展奠定了坚实基础。Transformer 的架构图如下所示。</p>
<p><img src="image-20250318203937402.png" alt="image-20250318203937402"></p>
<p><strong>核心创新</strong>：自注意力机制 (Self-Attention)、多头注意力(Multi-Head Attention)、前馈网络(Feed-Forward Network, FFN)和层归一化(Layer Norm)、位置编码(Positional Encoding)</p>
<p><strong>对语言建模的影响</strong></p>
<ul>
<li><strong>可扩展性：</strong>Transformer 实现了完全并行化的计算方式，这使得在大规模数据集上训练超大模型成为可能。相比传统的 RNN 和 LSTM，Transformer的计算效率更高，能够充分利用现代硬件（如 GPU 和 TPU）的并行计算能力。</li>
<li><strong>上下文理解：</strong>自注意力机制能够同时捕捉局部和全局依赖关系，显著提高了模型对上下文的理解能力。这种能力使Transformer生成的文本更加连贯，语义更加准确，尤其在处理复杂任务（如翻译、问答和文本生成）时表现出色。</li>
</ul>
<p>Transformer的提出不仅是NLP领域的一次重大突破，更是人工智能发展史上的一个重要里程碑。它通过自注意力机制、多头注意力、位置编码等创新设计，解决了传统模型的诸多局限性，为未来的语言建模和深度学习研究开辟了全新的可能性。</p>
<h3 id="预训练Transformer模型时代（2018–2020）"><a href="#预训练Transformer模型时代（2018–2020）" class="headerlink" title="预训练Transformer模型时代（2018–2020）"></a>预训练Transformer模型时代（2018–2020）</h3><p>2017年Transformer架构的引入为NLP的新时代铺平了道路，其特点是预训练模型的兴起和对扩展的前所未有的关注。这一时期见证了两个有影响力的模型家族的出现：BERT 和 GPT，它们展示了大规模预训练和微调范式的强大功能。</p>
<h4 id="BERT：双向上下文理解-2018"><a href="#BERT：双向上下文理解-2018" class="headerlink" title="BERT：双向上下文理解 (2018)"></a>BERT：双向上下文理解 (2018)</h4><p>2018年，谷歌推出了 BERT（Bidirectional Encoder Representations from Transformers），这是一种使用 Transformer 编码器 (Encoder) 的突破性模型，在广泛的NLP任务中取得了最先进的性能</p>
<p><strong>关键创新：</strong>掩码语言建模（Masker Language Modeling — MLM）、下一句预测（Next Sentence Prediction — NSP）</p>
<p><strong>BERT的影响：</strong>BERT的双向训练使其在GLUE（通用语言理解评估）和SQuAD（斯坦福问答数据集）等基准测试中取得了突破性的表现。它的成功证明了上下文嵌入（Embedding）的重要性， 并为新一代预训练模型铺平了道路。</p>
<h4 id="GPT：生成式预训练和自回归文本生成-2018–2020"><a href="#GPT：生成式预训练和自回归文本生成-2018–2020" class="headerlink" title="GPT：生成式预训练和自回归文本生成 (2018–2020)"></a>GPT：生成式预训练和自回归文本生成 (2018–2020)</h4><p>虽然BERT优先考虑双向上下文理解，但OpenAI的GPT系列采用了不同的策略，<strong>专注于通过自回归预训练实现生成能力</strong>。通过利用**Transformer的解码器(Decoder)**，GPT模型在自回归语言模型和文本生成方面表现出色。</p>
<p><strong>GPT 发展过程</strong></p>
<p><strong>GPT (2018): 单向解码器Transformer建模</strong></p>
<p>2018年6月，GPT系列的首个版本问世，首次引入了仅解码器的Transformer架构，<strong>参数规模达1.17亿</strong>，成为自然语言处理领域的重要突破。该模型通过单向自回归方法在<strong>4.6GB高质量文本数据</strong>上进行训练，能够基于先前的标记预测下一个标记。凭借对自然语言序列依赖关系的精准捕捉，它在文本补全、摘要生成和对话生成等生成任务中表现优异。</p>
<p><strong>GPT-2 (2019): 扩展语言模型以实现广义零样本学习</strong></p>
<p>GPT-2于2019年2月发布，相较于前代实现了重大升级，参数量达到<strong>15亿</strong>，并在<strong>40GB多样化的互联网文本</strong>上进行训练。GPT-2引入了突破性的零样本学习能力，能够在不进行任务特定微调的情况下完成诸如撰写文章、回答问题、摘要生成和翻译等任务</p>
<p><strong>GPT-3 (2020): 大规模语言模型的崛起</strong></p>
<p>GPT-3于2020年6月发布，凭借其惊人的<strong>1750亿参数</strong>彻底改变了人工智能领域，成为当时规模最大的语言模型。它在庞大且多样化的文本语料库上进行训练，展现了卓越的少量样本和零样本学习能力，能够以极少甚至无需示例完成诸如撰写文章、生成代码、解决推理问题以及创意写作等任务。</p>
<p><strong>GPT的影响及规模的作：</strong>GPT模型的引入，特别是GPT-3，标志着AI的一个变革时代，展示了自回归架构和生成能力的强大功能。这些模型为内容创作、对话代理和自动推理等应用开辟了新的可能性，在广泛的任务中达到了接近人类的表现。<strong>GPT-3凭借其1750亿参数证明了规模的深远影响，表明在大规模数据集上训练的更大模型可以树立新的AI能力标杆</strong></p>
<blockquote>
<p>从 GTP-3 开始，Open AI 走上了闭源的不归路，只能说后续美股跌的不冤</p>
</blockquote>
<h3 id="后训练对齐：弥合AI与人类价值观之间的差距-2021–2022"><a href="#后训练对齐：弥合AI与人类价值观之间的差距-2021–2022" class="headerlink" title="后训练对齐：弥合AI与人类价值观之间的差距 (2021–2022)"></a>后训练对齐：弥合AI与人类价值观之间的差距 (2021–2022)</h3><p>GPT-3（一个拥有1750亿参数的LLM）生成几乎无法与人类写作区分的文本的能力引发了关于AI生成内容的真实性和可信度的重大担忧。尽管这一成就标志着AI发展的一个重要里程碑，但也突显了确保这些模型与人类价值观、偏好和期望保持一致的关键挑战。<strong>一个主要问题是「幻觉」（Hallucination），即LLM生成与事实不符、无意义或与输入提示矛盾的内容，给人一种一本正经地胡说八道的印象。</strong>为了解决这些挑战，2021年和2022年的研究人员专注于改善与人类意图的一致性并减少幻觉，导致了<strong>监督微调（SFT）</strong>和<strong>基于人类反馈的强化学习（RLHF）</strong>等技术的发展。</p>
<p>其中 RLHF 的工作流程如下图所示</p>
<p><img src="image-20250319093033929.png" alt="image-20250319093033929"></p>
<h4 id="ChatGPT：推进对话式AI-2022"><a href="#ChatGPT：推进对话式AI-2022" class="headerlink" title="ChatGPT：推进对话式AI (2022)"></a>ChatGPT：推进对话式AI (2022)</h4><p>2022年3月，OpenAI推出了<strong>GPT-3.5</strong>，这是GPT-3的升级版，架构相同但训练和微调有所改进。关键增强包括通过改进数据更好地遵循指令，减少了幻觉（尽管未完全消除），以及更多样化、更新的数据集，以生成更相关、上下文感知的响应。</p>
<p><img src="image-20250318175111026.png" alt="image-20250318175111026"></p>
<p>基于GPT-3.5和InstructGPT，OpenAI于2022年11月推出了ChatGPT，这是一种突破性的对话式AI模型，专门为自然的多轮对话进行了微调，其发展过程如上图所示。</p>
<p>ChatGPT的推出标志着AI的一个关键时刻，通常被称为**「ChatGPT时刻」(ChatGPT moment)**，因为它展示了对话式AI改变人机交互的潜力。</p>
<h3 id="多模态模型：连接文本、图像及其他-2023–2024"><a href="#多模态模型：连接文本、图像及其他-2023–2024" class="headerlink" title="多模态模型：连接文本、图像及其他 (2023–2024)"></a>多模态模型：连接文本、图像及其他 (2023–2024)</h3><p>在2023年至2024年间，像GPT-4, GPT-4V和GPT-4o这样的多模态大型语言模型（MLLMs）通过将文本、图像、音频和视频整合到统一系统中重新定义了AI。这些模型扩展了传统语言模型的能力，实现了更丰富的交互和更复杂的问题解决。</p>
<h4 id="GPT-4V：视觉遇见语言"><a href="#GPT-4V：视觉遇见语言" class="headerlink" title="GPT-4V：视觉遇见语言"></a>GPT-4V：视觉遇见语言</h4><p>2023年，OpenAI推出了GPT-4V，将GPT-4的语言能力与先进的计算机视觉相结合。它可以解释图像、生成标题、回答视觉问题，并推断视觉中的上下文关系。其跨模态注意力机制允许文本和图像数据的无缝集成，使其在医疗保健（如分析医学图像）和教育（如互动学习工具）等领域具有价值。</p>
<h4 id="GPT-4o：全模态前沿"><a href="#GPT-4o：全模态前沿" class="headerlink" title="GPT-4o：全模态前沿"></a>GPT-4o：全模态前沿</h4><p>到2024年初，GPT-4o通过整合音频和视频输入进一步推进了多模态。它在一个统一的表示空间中运行，可以转录音频、描述视频或将文本合成音频。实时交互和增强的创造力 — — 如生成多媒体内容 — — 使其成为娱乐和设计等行业的多功能工具。</p>
<h3 id="开源和开放权重模型-2023–2024"><a href="#开源和开放权重模型-2023–2024" class="headerlink" title="开源和开放权重模型 (2023–2024)"></a>开源和开放权重模型 (2023–2024)</h3><p>在2023年至2024年间，开源和开放权重AI模型获得了动力，使先进AI技术的访问民主化。</p>
<ul>
<li><strong>开放权重LLMs：</strong>开放权重模型提供公开访问的模型权重，限制极少。这使得微调和适应成为可能，但训练架构和训练数据保持封闭。它们适合快速部署。例子：Meta AI的LLaMA系列和Mistral AI的Mistral 7B / Mixtral 8x7B</li>
<li><strong>开源LLMs：</strong>开源模型使底层代码和结构公开可用。这允许全面理解、修改和定制模型，促进创新和适应性。例子：OPT和BERT。</li>
<li><strong>社区驱动的创新</strong>：像Hugging Face这样的平台促进了协作，LoRA和PEFT等工具使高效的微调成为可能。</li>
</ul>
<h3 id="推理模型：从「系统1」到「系统2」思维的转变-2024"><a href="#推理模型：从「系统1」到「系统2」思维的转变-2024" class="headerlink" title="推理模型：从「系统1」到「系统2」思维的转变 (2024)"></a>推理模型：从「系统1」到「系统2」思维的转变 (2024)</h3><p>2024年，AI开发开始强调增强「推理」，从简单的模式识别转向更逻辑化和结构化的思维过程。这一转变受到认知心理学双重过程理论的影响，区分了「系统1」（快速、直觉）和「系统2」（缓慢、分析）思维。虽然像GPT-3和GPT-4这样的早期模型在生成文本等「系统1」任务上表现出色，但在深度推理和问题解决方面却有所欠缺。</p>
<h4 id="OpenAI-o1：推理能力的一大飞跃-2024"><a href="#OpenAI-o1：推理能力的一大飞跃-2024" class="headerlink" title="OpenAI-o1：推理能力的一大飞跃(2024)"></a>OpenAI-o1：推理能力的一大飞跃(2024)</h4><p><strong>OpenAI-o1-preview</strong></p>
<p>2024年9月12日，OpenAI发布的<strong>o1-preview</strong>标志着人工智能能力的重大飞跃，尤其是在解决复杂推理任务（如数学和编程）方面。与传统LLMs不同，推理模型采用了<strong>「长链思维」（Long CoT）</strong> — — 即内部的推理轨迹，使模型能够通过分解问题、批判自己的解决方案并探索替代方案来“思考”问题。这些CoTs对用户是隐藏的，用户看到的是一个总结性的输出。</p>
<p><img src="gpt%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.png" alt="gpt发展历程"></p>
<p><strong>推理模型的关键特性包括</strong></p>
<ul>
<li><strong>长链思维（Long CoT）</strong> ：使模型能够将复杂问题分解为更小的部分，批判性地评估其解决方案，并探索多种方法，类似于搜索算法。</li>
<li><strong>推理时计算控制</strong> ：对于更复杂的问题，可以生成更长的CoTs；而对于较简单的问题，则使用较短的CoTs以节省计算资源。</li>
<li><strong>增强的推理能力</strong> ：尽管像o1-preview这样的初始推理模型在某些领域的能力不如标准LLMs，但在推理任务中，它们的表现远远超越了后者，常常能与人类专家媲美。例如，o1-preview在数学（AIME 2024）、编程（CodeForces）和博士级别的科学问题上均超越了GPT-4o。</li>
</ul>
<p><strong>OpenAI-o1</strong></p>
<p>2024年12月5日，OpenAI的完整版<strong>o1</strong>模型进一步提升了性能，在美国AIME 2024数学考试中排名前500名学生之列，并显著超越了<strong>GPT-4o</strong>（解决了74%-93%的AIME问题，而GPT-4o仅为12%）。此外，<strong>o1-mini</strong>作为更便宜且更快的版本，在编码任务中表现出色，尽管其成本仅为完整版o1的20%。</p>
<p><strong>OpenAI-o3</strong></p>
<p>2025年1月31日，OpenAI发布了<strong>o3</strong>，这是其推理模型系列的最新突破，建立在o1模型成功的基础之上。尽管完整的o3模型尚未发布，但其在关键基准测试中的表现被描述为具有开创性。</p>
<p>OpenAI-o1和OpenAI-o3推理模型的发布代表了人工智能领域的重大进步，通过结构化的内部推理过程提供了卓越的问题解决能力，并在复杂数学和编程任务中树立了新的标杆。</p>
<h3 id="成本高效的推理模型"><a href="#成本高效的推理模型" class="headerlink" title="成本高效的推理模型"></a>成本高效的推理模型</h3><p>LLMs通常需要极其庞大的计算资源来进行训练和推理。像GPT-4o和OpenAI-o1这样的最先进LLM模型的闭源性质限制了对尖端AI的普及化。</p>
<h4 id="DeepSeek-V3-2024–12"><a href="#DeepSeek-V3-2024–12" class="headerlink" title="DeepSeek-V3 (2024–12)"></a>DeepSeek-V3 (2024–12)</h4><p>2024年12月下旬，「深度求索-V3」(DeepSeek-V3)作为一种成本高效的开放权重LLM出现，为AI的可访问性设定了新标准。DeepSeek-V3与OpenAI的ChatGPT等顶级解决方案相媲美，但开发成本显著降低，估计约为560万美元，仅为西方公司投资的一小部分。该模型最多包含6710亿个参数，其中370亿个活跃参数，并采用专家混合（MoE）架构，将模型划分为专门处理数学和编码等任务的组件，以减轻训练负担。DeepSeek-V3采用了工程效率，例如改进Key-Value缓存管理和进一步推动专家混合方法。该模型引入了三个关键架构：</p>
<ul>
<li><strong>多头潜在注意力（Multi-head Latent Attention — MLA）</strong>：通过压缩注意力键和值来减少内存使用，同时保持性能，并通过旋转位置嵌入（RoPE）增强位置信息。</li>
<li><strong>DeepSeek专家混合（DeepSeekMoE）</strong>：在前馈网络（FFNs）中采用共享和路由专家的混合，以提高效率并平衡专家利用率。</li>
<li>**多标记预测 (Multi-Token Prediction — MTP)**：增强模型生成连贯且上下文相关的输出的能力，特别是对于需要复杂序列生成的任务。</li>
</ul>
<h4 id="DeepSeek-R1-Zero-和-DeepSeek-R1-2025–01"><a href="#DeepSeek-R1-Zero-和-DeepSeek-R1-2025–01" class="headerlink" title="DeepSeek-R1-Zero 和 DeepSeek-R1 (2025–01)"></a>DeepSeek-R1-Zero 和 DeepSeek-R1 (2025–01)</h4><p>仅仅一个月后，2025年1月下旬，DeepSeek通过发布DeepSeek-R1-Zero和DeepSeek-R1再次引起轰动，这些模型展示了卓越的推理能力，训练成本极低。利用先进的强化学习技术，这些模型证明了高性能推理可以在没有通常与尖端AI相关的巨额计算费用的情况下实现。这一突破巩固了DeepSeek作为高效和可扩展AI创新领导者的地位。</p>
<ul>
<li><p><strong>DeepSeek-R1-Zero：</strong>一种基于DeepSeek-V3的推理模型，通过强化学习（RL）增强其推理能力。它完全消除了「监督微调」(SFT)阶段，直接从名为DeepSeek-V3-Base的预训练模型开始。它采用了一种基于「规则的强化学习方法」(Rule-based Reinforcement Learning)，称为「<strong>组相对策略优化」</strong>（<strong>Group Relative Policy Optimization — GRPO）</strong>，根据预定义规则计算奖励，使训练过程更简单且更具可扩展性。</p>
</li>
<li><p><strong>DeepSeek-R1：</strong>为了解决DeepSeek-R1-Zero的局限性，如低可读性和语言混杂，DeepSeek-R1纳入了一组有限的高质量冷启动数据和额外的RL训练。该模型经历了多个微调和RL阶段，包括拒绝采样和第二轮RL训练，以提高其通用能力和与人类偏好的一致性。</p>
</li>
<li><p><strong>蒸馏DeepSeek模型：</strong>DeepSeek开发了较小的、蒸馏版的DeepSeek-R1，参数范围从15亿到700亿，将先进的推理能力带到较弱的硬件上。这些模型使用原始DeepSeek-R1生成的合成数据进行微调，确保在推理任务中表现出色，同时足够轻量化以便本地部署。</p>
</li>
</ul>
<h4 id="QwQ-32B（2025-03）"><a href="#QwQ-32B（2025-03）" class="headerlink" title="QwQ-32B（2025-03）"></a>QwQ-32B（2025-03）</h4><p>2025年3月6日，阿里云Qwen团队发布了其最新研究成果QwQ-32B推理模型，该成果通过大规模强化学习技术突破性地提升了语言模型的智能水平，这款拥有32B参数的模型性能远超同样在QWen32B上训练出来的DeepSeek-R1-Distill-Qwen32B。展现出与DeepSeek-R1（激活参数37B/总参数671B）相匹敌的性能，标志着强化学习在预训练模型优化中的显著成效。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从2017年Transformer架构的提出到2025年DeepSeek-R1的发展，大型语言模型（LLMs）的演进标志着AI领域进入了一个革命性的新阶段。这一历程由四个里程碑式的成就所定义：</p>
<ol>
<li><strong>Transformers (2017)</strong> ：Transformer架构的引入为构建大规模高效模型奠定了基础，使其能够以前所未有的精确性和灵活性处理复杂任务。</li>
<li><strong>GPT-3 (2020)</strong> ：这一模型展示了规模在AI中的变革性力量，证明了通过在海量数据集上训练的巨大模型，可以在广泛的应用场景中实现接近人类水平的表现，为AI能力设定了新的基准。</li>
<li><strong>ChatGPT (2022)</strong> ：通过将对话式AI带入主流，ChatGPT让高级AI技术变得更加亲民和互动，使普通用户也能轻松使用。同时，它引发了关于AI广泛应用所带来的伦理和社会影响的重要讨论。</li>
<li><strong>DeepSeek-R1 (2025)</strong> ：DeepSeek-R1通过采用「专家混合」（MoE）、 「多头潜在注意力」（MLA）以及「多标记预测」（MTP），结合高效的多阶段强化学习（RL）训练算法，实现了推理过程优化，并将运营成本削减高达50倍，相较于许多领先的闭源模型。其开源特性加速了尖端AI应用的普及，赋予各行业创新者更多能力，同时也突显了可扩展性、对齐性和可访问性在未来AI发展中的重要性。</li>
</ol>
<p>LLMs正逐步演变为多功能、多模态的推理系统，能够同时满足普通用户和特定需求。这一演变得益于突破性技术创新，以及在规模、易用性和成本效益上的显著提升，推动人工智能朝着更加包容和影响力深远的方向迈进。</p>
<h2 id="大语言模型数据集"><a href="#大语言模型数据集" class="headerlink" title="大语言模型数据集"></a>大语言模型数据集</h2><p>大语言模型预训练所需的数据来源大体上分为<strong>通用数据</strong>和<strong>专业数据</strong>两大类。</p>
<p>通用数据（General Data）包括网页、图书、新闻、对话文本等，通用数据具有规模大、多样性和易获取等特点，因此支持大语言模型的语言建模和泛化能力。</p>
<blockquote>
<p>书籍（Book）：受限于版权因素，开源书籍数据集很少，现有的开源大 语言模型研究通常采用 Pile 数据集中提供的 Books 3 和 BookCorpus 2 数据集。</p>
<p>多语言数据（Multilingual Text）：BLOOM 的预训练数据中包含 46 种语言的数据，PaLM的预训练数据中甚至包含高达 122 种语言的数据。</p>
<p>科学文本（Scientific Text）：科学文本数据的来源主要包括 arXiv 论 文、PubMed 论文、教材、课件和教学网页等。</p>
<p>百科（Encyclopedia）：百科全书、在线百科网站及其他知识数据库。</p>
<p>代码（Code）：代码的主要来源是编程问答社区（如 Stack Exchange） 和公共软件仓库（如 GitHub）。</p>
</blockquote>
<p>专业数据（Specialized Data）包括多语言数据、 科学文本数据、代码及领域特有资料等。通过在预训练阶段引入领域数据可以有效提升大语言模型的任务解决能力。</p>
<blockquote>
<p>金融领域：BBT-FinCorpus 是一个大规模的中文金融领域语料库，由公司公告、研究报告、金融 新闻和社交媒体这四个部分组成。FinCorpus 是一个中文金融领域语料库，包含公司公告、金融信息与新闻、金融考试题目等。FinGPT 收集了金融新闻、社交媒体、金融监管机构文件、金融趋势分析文章以及金融学术数据集等数据。</p>
<p>医疗领域：包含大量的医学文本语料库（包括结构化和非结构化文本），包 括电子健康记录、临床记录以及医学文献等。PubMed、MIMIC-III、Medical-GPT 等</p>
<p>法律领域：也包含许多可用于模型训练的数据资源，主要包括法律法规、裁判文书等法律数据</p>
</blockquote>
<p><img src="image-20250318175846048.png" alt="image-20250318175846048"></p>
<p>上图给出了一些典型的大语言模型所使用数据类型的分布情况。可以看到，不同的大语言模型在训练数据类型分布上的差距很大，截至 2025 年 2 月，业界关于预训练数据的配比还没达成广泛的共识。</p>
<p>大语言模型的相关研究表明，数据质量对于模型的影响非常大。因此，在收集了各种类型的数据之后，需要对数据进行处理，去除低质量数据、重复数据、有害信息、个人隐私等内容。 典型的数据处理流程如图所示</p>
<p><img src="image-20250318185410606.png" alt="image-20250318185410606"></p>
<h2 id="大语言模型架构"><a href="#大语言模型架构" class="headerlink" title="大语言模型架构"></a>大语言模型架构</h2><p>本节主要讨论并介绍 Encoder-only、Encoder-Decoder 以及 Decoder-only 三种主流的语言模型架构。在语言模型的发展历程中，Transformer 框架的问世代表着一个划时代的转折点。其独特的自注意力（Self-Attention）机制极大地提升了模型<strong>对序列数据的处理能力</strong>，在<strong>捕捉长距离依赖关系</strong>方面表现尤为出色。此外，Transformer 框架对<strong>并行计算的支持</strong>极大地加速了模型的训练过程。当前，绝大多数大语言模型均以 Transformer 框架为核心，并进一步演化出了三种经典架构，分别是 Encoder-only 架构，Decoder-only 架构以及 Encoder-Decoder 架构。</p>
<p>其中，随着 Decoder-only 架构展现出的强大能力，当下 Decoder-only 架构已成为主流，目前的 LLM 都是基于 Decoder-only 架构。</p>
<p>在介绍架构之前，先简要介绍一下分词向量化</p>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>在输入文本进入大模型之前，需要将它拆分成一个 Token 的序列，其中 Token 是<strong>承载语义的最小单元</strong>，标识具体某个词，并且每个 Token 由 Token ID 唯一标识。将文本转化为 Token 的过程称之为「分词」（Tokenization），实现转换的就是「分词器」（tokenizer）</p>
<p>以“小浣熊吃干脆面”这样一句话，经过分词处理之后，会变成一个 Token 序列，每个 Token 有对应的 Token ID。在完成分词之后，这些 Token 随后会经过模型的嵌入矩阵（Embedding Matrix） 处理，转化为固定大小的表征向量。这些向量序列被直接输入到模型中，供模型理解和处理。在模型生成阶段，模型会根据输入的向量序列计算出词表中每个词的 概率分布。模型从这些概率分布中选择并输出对应的 Token，这些 Token 再被转换 为相应的文本内容。</p>
<blockquote>
<p>简单理解，就是一段话通过分词器被拆分成多个单词或短句，每个单词就叫 Token，每个 Token 会通过分词表得到 Token ID，再通过静态（转换矩阵）或动态（预训练编码器）的方式转换为向量矩阵/语义嵌入，再送入模型进行训练</p>
</blockquote>
<p><img src="image-20250313103337020.png" alt="image-20250313103337020"></p>
<p>在构建大语言模型的词表时，分词器依赖于分词算法，例如 BBPE、BPE、WordPiece 等，不同的分词器得到的 Token 序列也不尽相同。</p>
<p>每个大语言模型都有自己的分词器，分词器维护一个词表，能够对文本进行 分词。分词器的质量对模型的性能有着直接的影响。一个优秀的分词器不仅能显著提升模型对文本的理解能力，还能够提高模型的处理速度，减少计算资源的消耗。一个好的分词器应当具备以下特点：</p>
<ul>
<li>首先，它能够准确地识别出文本中的关键词和短语，从而帮助模型更好地捕捉语义信息；</li>
<li>其次，分词器的效率直接影响到模型的训练和推理速度，一个高效的分词器能够实现对文本 Token 的优化压缩，进而显著缩短模型在处理数据时所需的时间。</li>
</ul>
<table>
<thead>
<tr>
<th>模型</th>
<th>词表大小</th>
<th>中文分词效率 （字 / Token）</th>
<th>英文分词效率 （词 / Token）</th>
</tr>
</thead>
<tbody><tr>
<td>LLaMA1</td>
<td>32000</td>
<td>0.6588</td>
<td>0.6891</td>
</tr>
<tr>
<td>LLaMA2</td>
<td>32000</td>
<td>0.6588</td>
<td>0.6891</td>
</tr>
<tr>
<td>LLaMA3</td>
<td>128256</td>
<td>1.0996</td>
<td>0.7870</td>
</tr>
<tr>
<td>DeepSeek-V1</td>
<td>100016</td>
<td>1.2915</td>
<td>0.7625</td>
</tr>
<tr>
<td>DeepSeek-V2</td>
<td>100002</td>
<td>1.2915</td>
<td>0.7625</td>
</tr>
<tr>
<td>GPT-3.5 &amp; GPT-4</td>
<td>100256</td>
<td>0.7723</td>
<td>0.7867</td>
</tr>
<tr>
<td>GPT-3</td>
<td>50257</td>
<td>0.4858</td>
<td>0.7522</td>
</tr>
<tr>
<td>Qwen-1.5</td>
<td>151646</td>
<td>1.2989</td>
<td>0.7865</td>
</tr>
<tr>
<td>StarCoder</td>
<td>49152</td>
<td>0.9344</td>
<td>0.6513</td>
</tr>
</tbody></table>
<p>表是对常见开源大语言模型的分词器的对比分析，其中中文语料库节选自《朱自清散文》 ，英文语料库来自莫泊桑短篇小说《项链》，像 DeepSeek、Qwen 这类中文开源大语言模型，对中文分词进行了优化，平均每个 Token 能够表示 1.3 个字（每个字仅需 0.7 个 Token 即可表示），一些 常用词语和成语甚至可以直接用一个 Token 来表示。相比之下，以英文为主要语料的模型，如 GPT-4、LLaMA 系列，对中文的支持度较弱，分词效率不高。</p>
<h3 id="Encoder-only-架构"><a href="#Encoder-only-架构" class="headerlink" title="Encoder-only 架构"></a>Encoder-only 架构</h3><p>Encoder-only 架构仅选取了 Transformer 中的编码器（Encoder）部分，用于接 收输入文本并生成与上下文相关的特征。具体来说，Encoder-only 架构包含三个部分，分别是<strong>输入编码</strong>部分，<strong>特征编码</strong>部分以及<strong>任务处理</strong>部分。</p>
<p>Encoder-only 架构如下所示</p>
<p><img src="image-20250313105459789.png" alt="image-20250313105459789"></p>
<p><strong>输入编码部分</strong></p>
<p>原始输入文本会被分词器（Tokenizer）拆解为 Token 序列， 随后通过词表和词嵌入（Embedding）矩阵映射为向量序列，确保文本信息得以数字化表达。接着为了保留文本中单词的顺序信息，每个向量序列会被赋予位置编码（Positional Encoding）。</p>
<blockquote>
<p>简单理解就是文本转换为语义嵌入后，再在语义嵌入上添加位置编码信息</p>
</blockquote>
<p><strong>特征编码部分</strong></p>
<p>先前得到的向量序列会依次通过一系列编码模块，这些模块通过自注意力机制和前馈网络进一步提取和深化文本特征</p>
<blockquote>
<p>简单理解就是前面得到的语义嵌入+位置编码信息后的编码送到网络中进行前向传播（输入和参数的线性和非线性的计算）</p>
</blockquote>
<p><strong>任务处理部分</strong></p>
<p>在预训练阶段和下游 任务适配阶段一般有所差别。在预训练阶段，模型通常使用全连接层作为输出头，用于完成掩码预测等任务。而在下游任务适配阶段，输出头会根据具体任务需求进行定制。</p>
<blockquote>
<p>简单理解就是对于 Encoder-only 框架，你最终的输出还是一堆向量，所以要想利用这些向量，就需要接 decoder（解码器），例如接一个分类器，可以实现文本分类，接一个 FC（全连接层），可以预测后续 Token，用于文本摘要</p>
</blockquote>
<p><strong>适用任务</strong></p>
<p>Encoder-only 架构中的双向注意力机制允许模型在预测每个 Token 时都充分 考虑序列中的前后文信息，捕捉丰富的语义和依赖关系。因此，Encoder-only 架构 的模型特别适合于<strong>自然语言理解</strong>（Natural Language Understanding, NLU）任务，如 情感分析或文本分类等判别任务。</p>
<blockquote>
<p>简单来说，就是用于分类任务</p>
</blockquote>
<p>Encoder-only 架构的<strong>代表性大语言模型</strong>：BERT 及其变体 RoBERTa、ALBERT 等</p>
<h3 id="Encoder-Decoder-架构"><a href="#Encoder-Decoder-架构" class="headerlink" title="Encoder-Decoder 架构"></a>Encoder-Decoder 架构</h3><p>为了弥补 Encoder-only 架构在文本生成任务上的短板，Encoder-Decoder 架构 在其基础上引入了一个解码器（Decoder），并采用交叉注意力机制来实现编码器与 解码器之间的有效交互。Encoder-Decoder 架构主要包含编码器和解码器两部分，Encoder-Decoder 架构如图所示。</p>
<p><img src="image-20250313111932120.png" alt="image-20250313111932120"></p>
<blockquote>
<p>其中分词器和输出文本只在训练阶段存在，而实现 “自回归”的红色虚线只在推理阶段存在。</p>
</blockquote>
<p>具体来说，解码器包含了<strong>输出编码</strong>、<strong>特征解码</strong>以及<strong>输出生成</strong>三个部分</p>
<p><strong>输出编码</strong></p>
<p>与编码器中的输入编码结构相同，包含分词、向量化以及添加位置编码三个过程，将原始输入文本转换化为带有位置信息的向量序列</p>
<p><strong>特征解码</strong></p>
<p>部分与特征编码部分在网络结构上也高度相似，包括掩码自注意力（Masked Self-Attention）模块，交叉注意力模块和全连接前馈模块。</p>
<p><strong>输出生成</strong></p>
<p>由一个线性层以及一个 Softmax 层组成，负责将特征解码后的向量转换为词表上的概率分布，并从这个分布中采样得到最合适的 Token 作为输出。</p>
<blockquote>
<p>简单理解就是特征编码通过 Softmax 计算得到对应词表中哪个词的概率最高，然后选最高概率的 Token 输出</p>
</blockquote>
<p>在推理阶段，由于缺少了真实的输出文本，所以输出序列原始状态只有开始标记 [START]，也不再需要分词器。模型需要通过自回归的方式，在每轮采样生成 Token 后，会将其拼接到输出序列中，用于下一轮预测。这个过程循环进行，直到 生成特定的结束标记 [end] 或达到模型设定的最大输出长度。</p>
<p><strong>适用任务</strong></p>
<p>Encoder-Decode 架构在 Encoder-only 架构的基础上添加了解码器，使模型 够基于编码器输出的上下文表示逐步生成输出序列。这种编码器和解码器的结合， 使得模型可以有效地处理复杂的输入条件，并生成相关且连贯的高质量内容。因此，Encoder-Decoder 架构的模型非常适合于处理各种复杂的<strong>有条件生成任务</strong>，例如机器翻译、文本摘要和问答系统等需要同时理解输入并生成相应输出的场景</p>
<blockquote>
<p>简单来说，针对语言模型，就是文本到文本的输出的相关任务</p>
</blockquote>
<p> Encoder-Decoder 架构的<strong>代表性大语言模型</strong>：T5 和 BART</p>
<h3 id="Decoder-only-架构"><a href="#Decoder-only-架构" class="headerlink" title="Decoder-only 架构"></a>Decoder-only 架构</h3><p>为了有效缩减模型的规模以及降低整体的计算复杂度，Decoder-only 架构摒弃 了 Encoder-Decoder 架构中的编码器部分以及与编码器交互的交叉注意力模块。在 这种架构下，模型仅使用解码器来构建语言模型。这种架构利用“自回归”机制， 在给定上文的情况下，生成流畅且连贯的下文。</p>
<p><img src="image-20250313112951412.png" alt="image-20250313112951412"></p>
<p>Decoder-only 架构同样包含了三个部分，分别是<strong>输入编码</strong>部分、<strong>特征解码</strong>部分以及<strong>输出生成</strong>部分</p>
<p>Decoder-only 架构的核心特点在于省略了每个编码模块中的交叉注意力子模块，这也是其与传统 Encoder-Decoder 架构中解码器部分的主要区别</p>
<p><strong>适用任务</strong></p>
<p>Decoder-only 架构进一步删除了 Encoder-Decoder 架构中的编码器部分，从而 降低了模型本身的计算复杂度。这一架构的模型使用掩码（Mask）操作确保在每 个时间步生成当前 Token 时只能访问先前的 Token，并通过自回归生成机制，从起 始 Token 开始逐步生成文本。大规模预训练数据的加持使得 Decoder-only 架构的 模型能够生成高质量、连贯的文本，在自动故事生成、新闻文章生成此类不依赖 于特定的输入文本的<strong>无条件文本生成</strong>任务中表现出色</p>
<p>Decoder-only 架构的<strong>代表性大语言模型</strong>：Decoder-only 架构模型的概念最早可以追溯到 2018 年发布的 GPT-1 模型，2020 年 GPT-3 的突破性成功，使得 Decoder-only 架构开始被广泛应用于各种大语言模型中，其中最为流行的有 OpenAI 提出的 GPT 系列、Meta 提出的 LLaMA 系列等，但从第三代开始，GPT 系列<strong>逐渐走向了闭源</strong>。而 LLaMA 系列虽然起步较晚， 但凭借着同样出色的性能以及<strong>始终坚持的开源道路</strong>，也在 Decoder-only 架构领域 占据了一席之地。</p>
<h4 id="GPT-模型"><a href="#GPT-模型" class="headerlink" title="GPT 模型"></a>GPT 模型</h4><p><strong>GPT 大语言模型构建流程</strong></p>
<p>根据 OpenAI 联合创始人 Andrej Karpathy 在微软 Build 2023 大会上公开的信息，OpenAI 使用 的大语言模型构建流程如下图所示</p>
<p><img src="image-20250314095901475.png" alt="image-20250314095901475"></p>
<p><strong>预训练</strong>（Pretraining）</p>
<p>利用海量的训练数据（数据来自互联网网页、维基百科、书籍、 GitHub、论文、问答网站等），构建包含数千亿甚至数万亿单词的具有多样性的内容。利用由数千块高性能 GPU 和高速网络组成的超级计算机，花费数十天完成深度神经网络参数训练，构建基础模 型（Base Model）。基础模型对长文本进行建模，使模型具有语言生成能力，根据输入的提示词，模型可以生成文本补全句子。</p>
<p>根据相关论文，GPT-3 完成一次训练的总计算量是 3640PFLOPS，按照 NVIDIA A100 80GB GPU 和平均利用率达到 50% 计算，需要花费近一个月的时间使用 1000 块 GPU 完成。由于 GPT-3 的训练采用 NVIDIA V100 32GB GPU，其实际计算成本远高于上述计算。</p>
<p><strong>有监督微调</strong>（Supervised Fine Tuning，SFT）</p>
<p>利用少量高质量数据集，通过 有监督训练使模型具备问题回答、翻译、写作等能力。有监督微调的数据包含用户输入的提示词和对应的理想输出结果。用户输入包括问题、闲聊对话、任务指令等多种形式和任务。</p>
<blockquote>
<p>例如：提示词：TP-LINK 总部在哪里？</p>
<p>​            理想回答：TP-LINK 总部位于中国广东省深圳市的高新技术产业园区</p>
</blockquote>
<p>利用这些有监督数据，使用与预训练阶段相同的语言模型训练算法，在基础模型的基础上进行训 练，得到有监督微调模型（SFT 模型）。经过训练的 SFT 模型具备初步的指令理解能力和上下文理解能力，能够完成开放领域问答、阅读理解、翻译、生成代码等任务，也具备了一定的对未知任 务的泛化能力。</p>
<p><strong>奖励建模</strong>（Reward Modeling）</p>
<p>目标是构建一个文本质量对比模型。对于同一个提示词， SFT 模型对给出的多个不同输出结果的质量进行排序。奖励模型可以通过二分类模型，对输入的两个结果之间的优劣进行判断。由于奖励模型的准确率对强化学习阶段的效果有至关重要的影响，因此通常需要大规模的训 练数据对该模型进行训练。Andrej Karpathy 在报告中指出，该部分需要百万量级的对比数据标注， 而且其中很多标注需要很长时间才能完成。</p>
<p><strong>强化学习</strong>（Reinforcement Learning，RL）</p>
<p>根据数十万条提示词，利用前一阶段训练的奖励 模型，给出 SFT 模型对提示词回答结果的质量评估，并与语言模型建模目标综合得到更好的效果。 该阶段使用的提示词数量与有监督微调阶段类似，数量在十万个量级，并且不需要人工提前给出该提示词所对应的理想回复。</p>
<p><strong>GPT 发展历程</strong></p>
<p>2018 年 6 月，OpenAI 发布了第一个版本的 GPT （Generative Pre-Training）模型，被称为 GPT-1。GPT-1 开创了 Decoder-only 架构下，通过下一词预测解决无监督文本生成的先河，为自然语言处理领域带来了革命性的影响。GPT-1 具备原生的文本生成能力。但受限于训练数据量和模型参数数量，其生成能力还不足以用于解决实际问题。此外，由于其单向注意力机制的限制，其全面理解上下文的能力也有所欠缺。</p>
<p> 2019 年 2 月，OpenAI 发布了 GPT 系列的第二代 产品 GPT-2。相较于 GPT-1，GPT-2 在模型规模和预训练样本的质量上都进行了 显著的提升，显著增强了模型的任务泛化能力。</p>
<p>为了进一步提升任务泛化能力，OpenAI 于 2020 年 6 月推出了第三代模型 GPT-3。与前两代模型相比，GPT-3 在模型规模和预训练语料上进一步提升，并涌现出了优良的上下文学习（In-Context Learning, ICL）能力。在上下文学习能力的加持下，GPT-3 可以在不进行微调的情况下，仅通过任务描述或少量示例即可完成多 样化的下游任务。</p>
<p>在 GPT-3 的基础上，OpenAI 进一步推出了一系列衍生模型。其中，最具启发意义的是 InstructGPT，其也是 ChatGPT 的前身。它通 过引入了<strong>人类反馈强化学习</strong>（Reinforcement Learning from Human Feedback, RLHF）， 显著提升了模型对用户指令的响应能力，具体过程如下</p>
<p><img src="image-20250313135355700.png" alt="image-20250313135355700"></p>
<p>整体可以分为以下三个步骤：</p>
<ol>
<li><p><strong>有监督微调</strong>：收集大量“问题-人 类回答”对作为训练样本，对大语言模型进行微调</p>
<blockquote>
<p>所谓的微调实际上就是对一个已经训练好的模型，冻结模型部分权重，再用特定训练集重新训练并更新其余权重</p>
</blockquote>
</li>
<li><p><strong>训练奖励模型</strong>：针对每个 输入，让模型生成多个候选输出，并由人工对其进行质量评估和排名，构成偏好数 据集。用此偏好数据集训练一个奖励模型，使其可以对输出是否符合人类偏好进行打分</p>
</li>
<li><p><strong>强化学习微调</strong>：基于上一步中得到的奖励模型，使用强化学习方法优 化第一步中的语言模型，即在语言模型生成输出后，奖励模型对其进行评分，强化 学习算法根据这些评分调整模型参数，以提升高质量输出的概率</p>
</li>
</ol>
<p>OpenAI 于 2022 年 11 月推出了聊天机器人（ChatGPTChat Generative Pretrained Transformer） 。ChatGPT“一鸣惊人”，以强大的对话能力展示出令人 惊讶的智能，一度燃起了 ChatGPT 是否可以通过“图灵测试”的讨论。此外，用 户可以通过 OpenAI 提供的网页端或 API 轻松使用预训练后的 ChatGPT 模型，而 无需在本地部署，标志着一种新的服务模式 LLMaaS(LLM as a Service) 的出现。但是，从 ChatGPT 起，GPT 系列模型走向闭源。</p>
<p>四个月后，OpenAI 于 2023 年 3 月继续发布了 GPT-4 模型。相较于 ChatGPT， GPT-4 在理解复杂语境、捕捉语言细微差别、生成连贯文本等任务上进一步提升， 并且能够更有效地处理数学问题、编程挑战等高级认知任务。</p>
<p>一年后，为了进一步提升模型性能以及用户体验，OpenAI 于 2024 年 5 月提出 了 GPT-4o。GPT-4o 模型在前代 GPT-4 的基础上，大幅提升了响应速度，显著降 低了延迟，并且还增强了多模态处理能力以及多语言支持能力。</p>
<h4 id="LLAMA-系列语言模型"><a href="#LLAMA-系列语言模型" class="headerlink" title="LLAMA 系列语言模型"></a>LLAMA 系列语言模型</h4><p>LLaMA（Large Language Model Meta AI）是由 Meta AI 开发的一系列大语言模 型，其模型权重在非商业许可证下向学术界开放，推动了大语言模型的“共创”和 知识共享。</p>
<p>由于模型开源且性能优异，Llama迅速成为了开源社区中最受欢迎的大模型之一，以Llama为核心的生态圈也由此崛起。与此同时，众多研究者将其作为基座模型，进行了继续预训练或者微调，衍生出了众多变体模型（见下图），极大地推动了大模型领域的研究进展。</p>
<p><img src="image-20250318175543537.png" alt="image-20250318175543537"></p>
<p>LLaMA 与 GPT 系列的主要区别在于：GPT 系列的升级主线聚焦于模型规模与预训练语料的同步提升，而 LLaMA 则在模型规模上保持相对稳定，更<strong>专注于提升预训练数据的规模</strong>，LLaMA 系列模型参数和语料大小表如下所示</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>发布时间</th>
<th>参数量（亿）（不同比特版本的参数）</th>
<th>语料规模</th>
</tr>
</thead>
<tbody><tr>
<td>LLAMA-1</td>
<td>2023.02</td>
<td>67 / 130 / 325 / 652</td>
<td>约 5TB</td>
</tr>
<tr>
<td>LLAMA-2</td>
<td>2023.07</td>
<td>70 / 130 / 340 / 700</td>
<td>约 7TB</td>
</tr>
<tr>
<td>LLAMA-3</td>
<td>2024.04</td>
<td>80 / 700</td>
<td>约 50TB</td>
</tr>
</tbody></table>
<h3 id="混合专家12"><a href="#混合专家12" class="headerlink" title="混合专家12"></a>混合专家<a href="#refer-anchor-12"><sup>12</sup></a></h3><blockquote>
<p>想详细了解的可以看原文</p>
</blockquote>
<p>随着 GPT-4、Mixtral-8x7B、DeepSeek-V3 等模型的相继推出，混合专家模型 (Mixed Expert Models，MoEs) 日益受到关注。依据大模型缩放法则，模型规模是提升性能的关键，然而规模扩大必然使计算资源大幅增加。因此，在有限计算资源预算下，如何用更少训练步数训练更大模型成为关键问题。为解决该问题，混合专家模型基于一个简洁的思想：模型不同部分（即“专 家”）专注不同任务或数据层面。</p>
<p>混合专家（MoE）是一种利用多个不同的子模型（或称为“专家”）来提升LLM质量的技术，其示意图如下。</p>
<p><img src="image-20250319151028774.png" alt="image-20250319151028774"></p>
<p><strong>组成部分</strong></p>
<p>MoE的两个主要组成部分是：</p>
<ul>
<li><p><strong>专家</strong>：每个前馈神经网络（FFNN）层现在都有一组“专家”，可以选择其中的一部分。这些“专家”通常也是 FFNN。</p>
</li>
<li><p><strong>路由或门控网络</strong>：决定哪些词元发送到哪些专家。</p>
</li>
</ul>
<p>在每个具有MoE的模型层中，我们会找到（相对专业化的）专家</p>
<p><img src="%E6%B7%B7%E5%90%88%E4%B8%93%E5%AE%B61.png" alt="混合专家1"></p>
<p><strong>密集和稀疏</strong></p>
<p>混合专家（MoE）始于LLM的相对基本功能，即前馈神经网络（FFNN）。</p>
<p>简单来说传统 Transformer 中的 FFNN 被称为密集模型，因为所有参数（权重和偏置）都会被激活。没有任何东西被遗漏，所有东西都用于计算输出。</p>
<p>相比之下，稀疏模型仅激活其总参数的一部分，与混合专家密切相关。其基本思想是每个专家在训练过程中学习不同的信息。然后，在运行推理时，仅使用与特定任务最相关的专家。MoE 所替代的就是这种密集型的 FFNN</p>
<p><img src="%E6%B7%B7%E5%90%88%E4%B8%93%E5%AE%B62.png" alt="混合专家2"></p>
<p><strong>路由机制</strong></p>
<p>现在我们有了一组专家，那么模型如何知道使用哪些专家呢？</p>
<p>我们可以在专家层之前添加一个路由（也称为门控网络），它是专门训练用来选择针对特定词元的专家。</p>
<p>路由（或门控网络）也是一个前馈神经网络（FFNN），用于根据特定输入选择专家。它可以输出概率，用于选择最匹配的专家：</p>
<p><img src="%E6%B7%B7%E5%90%88%E4%B8%93%E5%AE%B63.png" alt="混合专家3"></p>
<p>对MoE来说也分为稀疏混合专家或密集混合专家</p>
<p>两者都使用路由器来选择专家，但稀疏MoE仅选择少数专家，而密集MoE则选择所有专家，但可能在不同的分布中。</p>
<blockquote>
<p>例如，给定一组词元，MoE会将词元分配到所有专家，而稀疏MoE仅选择少数专家。</p>
</blockquote>
<p>在当前的LLM状态下，当看到“MoE”时，通常指的是稀疏MoE，因为它允许使用一部分专家。这在计算上更为经济（消耗的资源更少），这是LLM的重要特性。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在不同的历史阶段，三种模型架构分别展现了自身的优势。随着模型规模以 及数据规模的显著增长，Decoder-only 架构的模型逐渐占据上风，以其强大的任务 泛化性能展现出成为“大一统”的架构的潜力。当前，以 GPT-3、GPT-4 等为代表 的大型 Decoder-only 语言模型，已经发展出了与人类媲美甚至超越人类的记忆、推 理以及执行复杂任务的能力。</p>
<blockquote>
<p>当下 LLM 都是 Decoder-only 架构</p>
</blockquote>
<h2 id="大语言模型微调"><a href="#大语言模型微调" class="headerlink" title="大语言模型微调"></a>大语言模型微调</h2><p>对于预训练数据涉及较少的垂直领域，大语言模型需要对这些领域及相应的 下游任务进行适配。这里简要介绍一下<strong>指令微调</strong>。</p>
<h3 id="指令微调"><a href="#指令微调" class="headerlink" title="指令微调"></a>指令微调</h3><p><strong>指令微调</strong>是指使用自然语言形式的数据对预训练后的大语言模型进行参数微调，这一术语由谷歌研究员在 2022 年的一篇 ICLR 论文中正式提出，在另外一些参考文献中，指令微调也被称为<strong>有监督微调（Supervised Fine-tuning）</strong> 或<strong>多任务提示训练（Multitask Prompted Training）</strong></p>
<p><strong>指令微调</strong>通过使用有标注的自然语言形式的数据，对模型参数进行微调，使模型具备指令遵循（Instruction Following）能力，能够完成各类预先设计的任务，并可以在零样本情况下处理诸多下游任务。</p>
<p>指令微调需首先构建指令数据集，然后在该数据集上进行监督微调。</p>
<ul>
<li><strong>指令数据构建</strong>：构造这种指令数据一般有两种方式。1）数据集成。 通过使用模板将带标签的自然语言数据集，转换为指令格式的 &lt; 输入，输出 &gt; 对。2）大语言模型生成。通过人工收集或者手写少量指令数据，再使用 GPT-3.5-Turbo 或 GPT4 等闭源大语言模型进行指令扩展。如 InstructWild  和 Self-Instruct</li>
<li><strong>监督微调</strong>：通过上述方法构建完数据集后，可以用完全监督的方式对预训 练模型进行微调，在给定指令和输入的情况下，通过顺序预测输出中的每个 token 来训练模型。经过微调的大语言模型能够显著提升指令遵循（Instruction-following）能力，这有助于增强其推理水平，泛化到新任务和新领域。</li>
</ul>
<p>其中 Self-Instruct 数据生成过程如下图所示</p>
<p><img src="image-20250314112346445.png" alt="image-20250314112346445"></p>
<h3 id="参数高效微调"><a href="#参数高效微调" class="headerlink" title="参数高效微调"></a>参数高效微调</h3><p><strong>参数高效微调</strong>（Parameter-Efficient Fine-Tuning，PEFT）旨在避免微调全部参数，减少在微调过程中需要更新的参数数量和计算开销，从而提高微调大语言模 型的效率。主流的 PEFT 方法可以分为三类：参数附加方法（Additional Parameters Methods），参数选择方法（Parameter Selection Methods）以及低秩适配方法（Low-Rank Adaptation Methods），其方法思想如图</p>
<p><img src="image-20250314112839289.png" alt="image-20250314112839289"></p>
<p><strong>1.参数附加方法</strong></p>
<p>参数附加方法（Additional Parameters Methods）在模型结构中附加新的、较小的可训练模块。在进行微调时，将原始模型参数冻结，仅微调这些新加入的模块， 从而来实现高效微调。</p>
<p>这些模块通常称为适应层（Adapter Layer）。它们被插入到模型的不同层之间，用于捕获特定任务的信息。由于这些新增的适应层参数量很小， 所以参数附加方法能够显著减少需要更新的参数量。典型方法包括：适配器微调 （Adapter-tuning）、提示微调（Prompt-tuning）、前缀微调（Prefix-tuning） 和代理微调（Proxy-tuning） 等。</p>
<p><strong>2. 参数选择方法</strong></p>
<p>参数选择方法（Parameter Selection Methods）仅选择模型的一部分参数进行微调，而冻结其余参数。选择性地微调这些关键 参数，可以在降低计算负担的同时提升模型的性能。典型的方法包括：BitFit、 Child-tuning  以及 FishMask等。</p>
<p><strong>3. 低秩适配方法</strong></p>
<p>低秩适配方法（Low-rank Adaptation Methods）通过低秩矩阵来近似原始权重更新矩阵，并冻结原始参数矩阵，仅微调低秩更新矩阵。由于低秩更新矩阵的参数 数量远小于原始的参数更新矩阵，因此大幅节省了微调时的内存开销。LoRA 是经典的低秩适配方法，后续有 AdaLoRA、DyLoRA 以及 DoRA 等变体被提出，进一步改进了 LoRA 性能。</p>
<p>对于使用 LoRA 的模型来说，由于可以将原权重与训练后权重合并，因此在推理时不存在额外的开销，LoRA 示意图如图所示</p>
<p><img src="image-20250314113649212.png" alt="image-20250314113649212"></p>
<p>具体的算法结构如图所示</p>
<p><img src="image-20250319092442475.png" alt="image-20250319092442475"></p>
<blockquote>
<p>使用时，目前有许多现成的 PEFT 框架，例如 Hugging Face 开发的 开源库 HF-PEFT</p>
</blockquote>
<h2 id="大语言模型量化"><a href="#大语言模型量化" class="headerlink" title="大语言模型量化"></a>大语言模型量化</h2><h3 id="模型压缩"><a href="#模型压缩" class="headerlink" title="模型压缩"></a>模型压缩</h3><p>大模型量化是一种模型压缩和优化技术，旨在减少深度学习模型的内存占用和提高推理速度，同时尽量保持模型的精度。量化后的模型权重占用更少的内存，从而可以在有限的硬件资源上部署更大的模型。</p>
<p>模型的压缩方法有很多，比如剪枝、量化、知识蒸馏，低秩分解等，这些方法都可以在一定程度上降低模型的参数量，从而减小模型的体积，提高模型的推理速度，降低模型的能耗。但是，这些方法在压缩模型的同时，也会带来一些问题，比如模型的精度下降、模型的推理速度不稳定等。</p>
<p>从感性上来说，这几种方法的差别如下</p>
<p><img src="%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%87%8F%E5%8C%96.png" alt="大模型量化"></p>
<ul>
<li><strong>量化</strong>，是通过降低模型中参数的精度，从而减小模型的体积，从图像来说就是把原先的高分辨率的彩图，变成了低分辨率，但整体图片的大小是没变的。这其实意味着模型的参数量是没变的，变化的只是每个参数的粒度，就像一个文件夹里面有100个txt文档，每个文档大小为10M，量化就是保持原始的文件数量还是100个，但把每个文件大小降低为1M，这样总的文件夹大小就降低了。</li>
<li><strong>剪枝</strong>，则是在保持模型精度不变的情况下，把模型中的部分参数删除，从而减小模型的体积，从图像上来说就是删掉了某些不重要的局部信息。这种情况下模型的参数量就变了，比如从100个txt文件，删掉了一些文件，变成了80个，但每个的大小都还是10M。 </li>
<li><strong>知识蒸馏</strong>，则是通过训练一个小的模型，使其学习一个大模型的特征，从而减小模型的体积。从图像上来说就是做了一个小的类似的东西。这种意味着参考之前的文件夹，再重新建了一个文件夹，然后用10个新的txt文件，每个文档大小为10M，实现了和之前一样的功能，虽然他们完全不一样 </li>
<li><strong>低秩分解</strong>，则是通过将模型的参数分解为低秩矩阵，从而减小模型的体积。（这个图像不好说，可以参考看SVD），这种意味着我把文件夹里面的100个txt文件，分解为了3个其他文件，然后每个文件和原始的不同（并且每个只有10K到20M不等），但文件组合起来能基本恢复100个txt文件（这里可能有点抽象，详细内容大家可以去看矩阵论的SVD分解，会有更为清晰的认识）</li>
</ul>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>LLM 在训练和推理过程中使用的三种不同精度格式：<strong>FP16</strong>（Half-precision floating-point，半精度浮点数）、<strong>BF16</strong>（Brain Floating-point，脑浮点数）和<strong>FP32</strong>（Single-precision floating-point，单精度浮点数）。这些精度格式在数值表示、计算效率、显存占用以及模型性能等方面各有优劣。</p>
<p><strong>1. FP32</strong></p>
<p>FP32，即float32，是单精度浮点数，使用32位二进制表示。其结构包括1位符号位、8位指数位和23位尾数位，尾数位隐含了首位的1，实际精度为24位。</p>
<p><strong>特点与应用</strong>：</p>
<ul>
<li><strong>优点</strong>：FP32提供了较高的精度和较大的数值表示范围，适合对数值精度要求较高的应用场景，如科学计算和精确求解。</li>
<li><strong>缺点</strong>：显存占用较大，计算速度相对较慢，不适合大规模并行计算。</li>
</ul>
<p><strong>显存占用与精度转换</strong>：</p>
<ul>
<li><strong>显存占用</strong>：FP32的显存占用是FP16和BF16的两倍。</li>
<li><strong>精度转换</strong>：在PyTorch中，FP32与FP16、BF16之间的转换可通过<code>.to()</code>方法指定dtype实现。</li>
</ul>
<p><strong>2. FP16</strong></p>
<p>FP16，即float16，是半精度浮点数，使用16位二进制表示。其结构包括1位符号位、5位指数位和10位尾数位。FP16的指数位通过引入偏置值15来表示范围从-14到+15的整数部分，尾数位隐含了首位的1，因此实际精度为11位。</p>
<p><strong>特点与应用</strong>：</p>
<ul>
<li><strong>优点</strong>：FP16显著减少了显存占用，加快了计算速度，适合在GPU上进行大规模并行计算。</li>
<li><strong>缺点</strong>：由于精度较低，可能导致数值溢出或下溢，影响模型训练的稳定性和准确性。</li>
</ul>
<p><strong>显存占用与精度转换</strong>：</p>
<ul>
<li><strong>显存占用</strong>：FP16相比FP32减少了一半的显存需求。</li>
<li><strong>精度转换</strong>：在PyTorch中，可以使用<code>.to(torch.float16)</code>或<code>.half()</code>方法将张量转换为FP16格式，反之使用<code>.to(torch.float32)</code>或<code>.float()</code>转换为FP32。</li>
</ul>
<p><strong>3. BF16</strong></p>
<p>BF16，即bfloat16，是一种专为深度学习设计的浮点数格式，同样使用16位二进制表示。其结构包括1位符号位、8位指数位和7位尾数位，尾数位同样隐含了首位的1，实际精度为8位。</p>
<p><strong>特点与应用</strong>：</p>
<ul>
<li><strong>优点</strong>：BF16在保持较低显存占用的同时，通过增加指数位的宽度，扩大了数值表示范围，有效减少了数值溢出问题，适合深度学习中的梯度累积和反向传播。</li>
<li><strong>缺点</strong>：相比FP16，BF16的尾数位宽度减少，导致精度有所下降。</li>
</ul>
<p><strong>显存占用与精度转换</strong>：</p>
<ul>
<li><strong>显存占用</strong>：与FP16相同，BF16也减少了一半的显存需求。</li>
<li><strong>精度转换</strong>：在PyTorch中，BF16的转换方法与FP16类似，使用<code>.to(torch.bfloat16)</code>或<code>.bfloat16()</code>进行转换。</li>
</ul>
<h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><p>量化（Quantization）是一种广泛应用的技术，将大语言模型的权重和激活值从高比特宽度转换为低比特宽度表示，从而显著降低计算成本和内存开销。具体来说，许多量化方法通过将 FP16 浮点张量转化为低比特整数张量来实现。在神经网络压缩中，量化通常是指从浮点数到整数的映射过程，目前比较常用的是 8 比特整数量化，即 <em>INT8</em>量化。</p>
<p>模型量化方法又可以根据在模型训练完成后，还是在模型训练过程中进一步细分为：<strong>量化感知训练</strong>（Quantization-Aware Training，QAT）和<strong>训练后量化</strong>（Post-Training Quantization，PTQ），其区别如下图所示。</p>
<p><img src="%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%87%8F%E5%8C%962.png" alt="大模型量化2"></p>
<ul>
<li><p>量化感知训练 QAT 是将训练过的模型量化后又再进行重训练。由于定点数值无法用于反向梯度计算，实际操作过程是在某些op前插入伪量化节点（fake quantization nodes）， 用于在训练时获取流经该op的数据的截断值，便于在部署量化模型时对节点进行量化时使用。我们需要在训练中通过不断优化精度来获取最佳的量化参数。由于它需要对模型进行训练, 对操作人员技术要求较高。</p>
<blockquote>
<p>实际就是通过在模型训练过程中适应低精度表示并减少量化后带来的损失，其主要目标是减少模型的存储和计算复杂性，而无需对模型架构进行修改或进行重新训练。然而，训练 LLMs 通常需要大量的训练数据和计算资源，这可能成为 QAT 实施的瓶颈。因此，当前的研究重点是减少数据需求或减轻 QAT 实施的计算负担。</p>
</blockquote>
</li>
<li><p>训练后量化 PTQ 是使用一批校准数据对训练好的模型进行校准, 将训练过的FP32网络直接转换为定点计算的网络，过程中无需对原始模型进行任何训练。只对几个超参数调整就可完成量化过程, 且过程简单快速, 无需训练, 因此此方法已被广泛应用于大量的端侧和云侧部署场景，我们优先推荐您尝试PTQ方法来查看是否满足您的部署精度和性能要求。</p>
<blockquote>
<p>实际就是一种对已完成训练的模型进行量化的方法， 无需重新训练原有模型，不过尽管 PTQ 方法在较小规模模型上已经广泛的研究，但直接将现有的模型量化技术应用于大语言模型仍然面临诸多挑战</p>
</blockquote>
</li>
</ul>
<h2 id="Prompt-工程"><a href="#Prompt-工程" class="headerlink" title="Prompt 工程"></a>Prompt 工程</h2><p>随着模型训练数据规模和参数数量的持续增长，大语言模型突破了泛化瓶颈， 并涌现出了强大的指令跟随能力。我们能够通过精心编写的指令输入，即 Prompt，来引导模型适应各种下游任务，从而避免了传统微调方法所带来的高昂计算成本。</p>
<p>经过良好设计的 Prompt 通常由任务说明、上下文、问题、输出格式 四个基本元素组成：</p>
<ul>
<li><strong>任务说明</strong>——向模型明确提出具体的任务要求。任务说明应当清晰、直接， 并尽可能详细地描述期望模型完成的任务。</li>
<li><strong>上下文</strong>——向模型提供的任务相关背景信息，用以增强其对任务的理解以及 提供解决任务的思路。上下文可以包括特定的知识前提、目标受众的背景、 相关任务的示例，或任何有助于模型更好地理解任务的信息。</li>
<li><strong>问题</strong>——向模型描述用户的具体问题或需要处理的信息。这部分应直接涉及 用户的查询或任务，为模型提供一个明确的起点。问题可以是显式的提问， 也可以是隐式的陈述句，用以表达用户的潜在疑问。</li>
<li><strong>输出格式</strong>——期望模型给出的回答的展示形式。这包括输出的格式，以及任 何特定的细节要求，如简洁性或详细程度。例如，可以指示模型以 JSON 格 式输出结果。</li>
</ul>
<p>在此基础上，Prompt 工程包括多种技巧和技术，如<strong>上下文学习</strong>（In-Context Learning）和<strong>思维链</strong>（Chain of Thought）。</p>
<p>上下文学习和思维链提示的比较如下</p>
<p><img src="image-20250319100157167.png" alt="image-20250319100157167"></p>
<h3 id="上下文学习"><a href="#上下文学习" class="headerlink" title="上下文学习"></a>上下文学习</h3><p>在 GPT-3 的论文中，OpenAI 研究团队首次提出上下文学习（In-context learning, ICL）这种特殊的提示形式。目前，上下文学习已经成为使用大语言模型解决下游任务的一种主流途径。</p>
<p>上下文学习使用包含包含演示示例，任务说明等元素的 Prompt 来 使得语言模型理解并学习下游任务的范式。上下文学习实现的关键在于如何设计有效的 Prompt，以引导模型理解任务的上下文和目标。通常，这些 Prompt 会包含任务说明以及一系列 的示例，模型能够从这些上下文信息中学习任务的逻辑和规则，从而在没有额外训练的情况下，生成符合任务要求的输出。</p>
<p>按照示例数量的不同，上下文学习可以呈现出多种形式：<strong>零样本</strong>（Zero-shot）上下文学习、<strong>单样本</strong>（One-shot）上下文学习和<strong>少样本</strong>（Few-shot） 上下文学习</p>
<h3 id="思维链提示"><a href="#思维链提示" class="headerlink" title="思维链提示"></a>思维链提示</h3><p>人类在解决复杂问题时，通常会逐步构建推 理路径以导出最终答案。基于这一理念，一种创新的 Prompt 范式——思维链提示 （Chain-of-Thought，CoT）被用于引导模型进行逐步推理。</p>
<p>思维链提示作为上下文学习的一种扩展形式，将原始的 ⟨ 输入，输出 ⟩ 映射 关系转换为 ⟨ 输入，思维链，输出 ⟩ 这一三元组形式。在这个结构中，思维链扮演着重要的角色，它提供了一系列语义连贯且具有逻辑性的中间推理步骤，有效地建立起输入与输出之间的桥接关系。在思维链提示的作用下，大语言模型可以根据输入生成对应的思维链及答案。然而，与简单的 ⟨ 输入，输出 ⟩ 二元组相比， 思维链的获取通常更为复杂，往往需要借助人工标注的方式。目前有一些简单的 方法可以让大模型在回答问题之前生成思考过程。例如，通过向大语言模型提供 诸如 “Let’s think step by step.” 或 “Take a deep breath and work on this problem step-by-step.” 这样的诱导性指令，能够在不提供思维链示例的情况下，仍然让大语言模型先生成思维链再回答问题来提高准确率。</p>
<h3 id="Prompt-技巧"><a href="#Prompt-技巧" class="headerlink" title="Prompt 技巧"></a>Prompt 技巧</h3><h4 id="规范-Prompt-编写"><a href="#规范-Prompt-编写" class="headerlink" title="规范 Prompt 编写"></a>规范 Prompt 编写</h4><p>编写规范的 Prompt 是我们与大语言模型进行有效沟通的基础。经典的 Prompt 通常由任务说明，上下文，问题，输出格式等部分中的一个或几个组成。以下是情感分类的一个例子</p>
<p><img src="image-20250313142852710.png" alt="image-20250313142852710"></p>
<p>通过这个例子可以看出，在编写经典 Prompt 的过程中，Prompt 各个组成部分 都很重要，它们的规范性，直接影响模型的输出质量。</p>
<p><strong>1. 任务说明要明确</strong></p>
<p>明确的任务说明是构建有效 Prompt 的关键要素之一。</p>
<ul>
<li><strong>使用明确的动词</strong>：选择能够清晰表达动作的动词，如“判断”、“分类”、“生成”等，避免使用模糊的动词如“处理”或“操作”。</li>
<li><strong>具体的名词</strong>：使用具体的名词来定义任务的输出或目标，例如“积极”和“消极”在情感分类任务中提供了明确的分类标准。</li>
<li><strong>简洁明了</strong>：任务说明应简洁且直接，避免冗长或复杂的句子结构，使模型能 够快速抓住任务的核心要求。</li>
<li><strong>结构化布局</strong>：在较长的 Prompt 中，将任务说明放置在开头和结尾，因为模型 通常更关注这些部分的信息。这种布局有助于确保模型首先和最后接触 到的是最关键的任务信息。</li>
</ul>
<p><strong>2. 上下文丰富且清晰</strong></p>
<p>上下文的清晰性则要求上下文信息必须与问题紧密相关， 避免包含冗余或不必要的信息。清晰的上下文应直接指向任务的核心，减少模型 在处理信息时的混淆和误解。例如，在问答任务中，上下文应仅包含与问题直接相 关的信息，避免引入可能误导模型的无关内容。</p>
<p><strong>3. 输出格式要规范</strong></p>
<p>规范的输出格式对于确保模型输出的可用性和准确性至关重要。通过指定明 确的输出格式，可以使模型的输出结构化，便于下游任务直接提取和使用生成内 容。常用的输出格式包括 JSON、XML、HTML、Markdown 和 CSV 等，每种格式 都有其特定的用途和优势。</p>
<ul>
<li><strong>明确指定输出格式</strong>：在 Prompt 中明确指出希望模型使用的输出格式，如“请以 JSON 格式返回结果”，并且选择广泛接受和易于处理的输出格式，如 JSON、 CSV 等，易于解析和数据交换。 </li>
<li><strong>提供输出格式的示例</strong>：在 Prompt 中提供一个输出格式的具体示例，比如在 JSON 中明确指出关键字，帮助模型理解预期的输出结构。</li>
</ul>
<p><strong>4. 排版要清晰</strong></p>
<p>一个优秀的 Prompt 还必然具备清晰的排版，这对于模型的理解 Prompt 至关重要。</p>
<ul>
<li><strong>使用一致的分隔符</strong>：选择并坚持使用一种或几种分隔符（如“#”、“###”、“—” 等），以区分不同的 Prompt 部分。</li>
<li><strong>合理使用空白和缩进</strong>：通过增加空白行和适当的缩进，增强 Prompt 的可读 性，帮助模型区分不同的内容块。</li>
<li><strong>清晰的标题和子标题</strong>：为每个部分提供清晰的标题或子标题，使模型能够快 速识别每个部分的主题。</li>
</ul>
<h4 id="合理归纳提问"><a href="#合理归纳提问" class="headerlink" title="合理归纳提问"></a>合理归纳提问</h4><p><strong>1. 复杂问题拆解</strong></p>
<p>在处理复杂问题时，我们可以将问题分解为更小、更易于理解的子问题，并逐 一解决。这一过程包括两个关键步骤：<strong>分步引导</strong>和<strong>归纳总结</strong></p>
<p><img src="image-20250313144505224.png" alt="image-20250313144505224"></p>
<p>首先，在<strong>分步引导</strong>阶段，我们需将复杂问题细化为多个子问题，并引导模型针对每个子问题进行深入分析和回答。这一步骤旨在确保每个子问题都能得到详尽 的解答，从而为后续的归纳总结奠定坚实基础。其次，在<strong>归纳总结</strong>阶段，我们将各 个子问题的答案进行汇总，并综合形成最终的全面回答。这一步骤不仅有助于我 们全面把握问题的各个方面，还能确保最终答案的准确性和完整性。</p>
<h4 id="善用心理暗示"><a href="#善用心理暗示" class="headerlink" title="善用心理暗示"></a>善用心理暗示</h4><p><strong>1. 角色扮演</strong></p>
<p>通过 Prompt 指导大语言模型扮演特定角色能够显著改善其与角色相关的技能。</p>
<p><img src="image-20250313144749891.png" alt="image-20250313144749891"></p>
<p>为了构建一个有效的角色，需要在指令中包含具体<strong>属性</strong>、<strong>职责</strong>、<strong>知识</strong>和<strong>技能</strong>。在设计角色设定提示时，选择对特定任务具有明显优势的角色至关重要。通过额外的描述来强调这一优势，通常可以带来更好的结果。</p>
<p><strong>2. 情景带入</strong></p>
<p>情景代入指的是将特定情境下所需的<strong>专业知识</strong>、<strong>历史背景</strong>等信息嵌入到模型的响应中。</p>
<p><img src="image-20250313144837470.png" alt="image-20250313144837470"></p>
<p>通过情景代入，模型能够深入理解并反映特定情境下的文化社会背景与现实 环境，从而生成更加丰富和有深度的回答。</p>
<h3 id="相关应用"><a href="#相关应用" class="headerlink" title="相关应用"></a>相关应用</h3><h4 id="基于大语言模型的-Agent"><a href="#基于大语言模型的-Agent" class="headerlink" title="基于大语言模型的 Agent"></a>基于大语言模型的 Agent</h4><p>智能体（Agent）是一种能够自主感知环境并采取行动以实现特定目标的实体。作为实现通用人工智能（AGI）的有力手段，Agent 被期望能够完成各种复杂任务，并在多样化环境中表现出类人智能。基于大语言模型的 Agent 展现出了强大的决策能力。其具备全面的通用知识，可以在缺乏、训练数据的情况下，也能进行规划、决策、工具调用等复杂的行动。</p>
<p><img src="image-20250313145342534.png" alt="image-20250313145342534"></p>
<p>Prompt 工程技术在 Agent 中起到了重要的作用。在 Agent 系统中，大语言模型 作为核心控制器，能够完成规划、决策、行动等操作，这些操作很多都依赖 Prompt 完成。该框架主要由四大部分组成：<strong>配置模块（Profile）</strong>、<strong>记忆模块（Memory）</strong>、<strong>计划模块（Planning）</strong>和<strong>行动模块（Action）</strong>。Prompt 工程技术贯穿整个 Agent 流程，为每个模块提供支持。</p>
<h4 id="数据合成"><a href="#数据合成" class="headerlink" title="数据合成"></a>数据合成</h4><p>数据合成作为一种补充或替代真实数据的有效手段，因其可控性、安全性和低成本等优势而受到广泛关注。特别是利用大语言模型生成训练数据，已成为当前研究的热点议题，其通过 Prompt 工程技术，利用大语言模型强 大的思维能力、指令跟随能力，来合成高质量数据。</p>
<h2 id="检索增强生成"><a href="#检索增强生成" class="headerlink" title="检索增强生成"></a>检索增强生成</h2><p>由于训练数据的正确性、时效性和完备性可能存在不足，大语言模型在面对某些问题时无法给出正确答案，甚至出现“幻觉”， 即生成看似合理实则逻辑混乱或违背事实的回答。为了解决这些问题并进一步提 升大语言模型的生成质量，我们可以将相关信息存储在外部数据库中，供大语言模 型进行检索和调用。这种从外部数据库中检索出相关信息来辅助改善大语言模型 生成质量的系统被称之为检索增强生成（Retrieval-Augmented Generation，RAG）。</p>
<p>检索增强生成（RAG）旨在通过检索和整合外部知识来增强大语言模型生成 文本的准确性和丰富性，其是一个集成了外部知识库、信息检索器、大语言模型等多个功能模块的系统。RAG 利用信息检索、深度学习等多种技术为大语言模型在 生成过程中引入最新的、特定领域的知识，从而克服传统大语言模型的局限性，提供更加精准和可靠的生成内容。</p>
<h3 id="检索增强生成的背景"><a href="#检索增强生成的背景" class="headerlink" title="检索增强生成的背景"></a>检索增强生成的背景</h3><p>训练数据是大语言模型知识的根本来源。训练数据在采集完成后直接用于训练模型。但是其中包含的知识可能在模型训练后又发生了更新。这将导致<strong>知识过时</strong>的问题。不仅如此，知识在训练数据采集完成后仍会新增，并且训练数据采集也 无法覆盖世间所有知识，尤其是垂域知识，这将导致<strong>知识边界</strong>的问题。此外，训练数据中还可能包含不实与偏见信息，从而导致<strong>知识偏差</strong>问题。</p>
<p>LLM 面临的主要问题如下</p>
<ul>
<li><strong>信息偏差/幻觉：</strong> LLM 有时会产生与客观事实不符的信息，导致用户接收到的信息不准确。RAG 通过检索数据源，辅助模型生成过程，确保输出内容的精确性和可信度，减少信息偏差。</li>
<li><strong>知识更新滞后性：</strong> LLM 基于静态的数据集训练，这可能导致模型的知识更新滞后，无法及时反映最新的信息动态。RAG 通过实时检索最新数据，保持内容的时效性，确保信息的持续更新和准确性。</li>
<li><strong>内容不可追溯：</strong> LLM 生成的内容往往缺乏明确的信息来源，影响内容的可信度。RAG 将生成内容与检索到的原始资料建立链接，增强了内容的可追溯性，从而提升了用户对生成内容的信任度。</li>
<li><strong>领域专业知识能力欠缺：</strong> LLM 在处理特定领域的专业知识时，效果可能不太理想，这可能会影响到其在相关领域的回答质量。RAG 通过检索特定领域的相关文档，为模型提供丰富的上下文信息，从而提升了在专业领域内的问题回答质量和深度。</li>
<li><strong>推理能力限制：</strong> 面对复杂问题时，LLM 可能缺乏必要的推理能力，这影响了其对问题的理解和回答。RAG 结合检索到的信息和模型的生成能力，通过提供额外的背景知识和数据支持，增强了模型的推理和理解能力。</li>
<li><strong>应用场景适应性受限：</strong> LLM 需在多样化的应用场景中保持高效和准确，但单一模型可能难以全面适应所有场景。RAG 使得 LLM 能够通过检索对应应用场景数据的方式，灵活适应问答系统、推荐系统等多种应用场景。</li>
<li><strong>长文本处理能力较弱：</strong> LLM 在理解和生成长篇内容时受限于有限的上下文窗口，且必须按顺序处理内容，输入越长，速度越慢。RAG 通过检索和整合长文本信息，强化了模型对长上下文的理解和生成，有效突破了输入长度的限制，同时降低了调用成本，并提升了整体的处理效率。</li>
</ul>
<p>这些问题的成因主要是大语言模型缺乏相应的知识或生成过程出现了偏差，导致其无法正确回答。借鉴人类的解决方式，当我们遇到无法回答的问题时，通常会借助搜索引擎或查阅书 籍资料来获取相关信息，进而帮助我们得出正确答案。这种思路便是检索增强生成（Retrieval-Augmented Generation，RAG) 的核心思想。</p>
<p>RAG 的概念最早出现在 Facebook AI Research 的论文 Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks 中。其通常集成了<strong>外部知识库（Corpus ）</strong>、<strong>信息检索器（Retriever）</strong>、<strong>生成器（Generator</strong>，即大语言模型）等多个功能模块。</p>
<p><img src="image-20250313153455791.png" alt="image-20250313153455791"></p>
<p>上图为 RAG 的基本工作流程。</p>
<p>用户输入一 个问题“2023 年的考拉数量有多少？”</p>
<p>首先，该问题会传递给 RAG 框架的检索器 模块，检索器从知识库中检索相关的知识文档，其中包含了与 2023 年的考拉数量 相关的信息；</p>
<p>接下来，这些信息通过 Prompt 的形式传递给大语言模型（大语言模 型利用外部知识的形式是多样的，通过 Prompt 进行上下文学习是其中最常用的形式）；</p>
<p>最终得出了正确的答案：“2023 年的考拉数量在 86,000 至 176,000 只之间。” </p>
<p>然而，同样的问题，如果让大语言模型在不使用 RAG 的情况下直接回答，则无法得到正确的答案，这说明了 RAG 系统的有效性。</p>
<p>多模态大模型检索增强过程如下图所示</p>
<p><img src="image-20250314114642346.png" alt="image-20250314114642346"></p>
<p>2024 是 RAG 井喷式发展的一年，关于 RAG 的设计、训练、优化和评估网上有非常多的内容，在这里就不展开说明了</p>
<h3 id="检索增强生成-vs-微调"><a href="#检索增强生成-vs-微调" class="headerlink" title="检索增强生成 vs 微调"></a>检索增强生成 vs 微调</h3><p>RAG 和 微调的对比可以参考下表</p>
<table>
<thead>
<tr>
<th>特征比较</th>
<th>RAG</th>
<th>微调</th>
</tr>
</thead>
<tbody><tr>
<td>知识更新</td>
<td>直接更新检索知识库，无需重新训练。信息更新成本低，适合动态变化的数据。</td>
<td>通常需要重新训练来保持知识和数据的更新。更新成本高，适合静态数据。</td>
</tr>
<tr>
<td>外部知识</td>
<td>擅长利用外部资源，特别适合处理文档或其他结构化/非结构化数据库。</td>
<td>将外部知识学习到 LLM 内部。</td>
</tr>
<tr>
<td>数据处理</td>
<td>对数据的处理和操作要求极低。</td>
<td>依赖于构建高质量的数据集，有限的数据集可能无法显著提高性能。</td>
</tr>
<tr>
<td>模型定制</td>
<td>侧重于信息检索和融合外部知识，但可能无法充分定制模型行为或写作风格。</td>
<td>可以根据特定风格或术语调整 LLM 行为、写作风格或特定领域知识。</td>
</tr>
<tr>
<td>可解释性</td>
<td>可以追溯到具体的数据来源，有较好的可解释性和可追踪性。</td>
<td>黑盒子，可解释性相对较低。</td>
</tr>
<tr>
<td>计算资源</td>
<td>需要额外的资源来支持检索机制和数据库的维护。</td>
<td>依赖高质量的训练数据集和微调目标，对计算资源的要求较高。</td>
</tr>
<tr>
<td>推理延迟</td>
<td>增加了检索步骤的耗时</td>
<td>单纯 LLM 生成的耗时</td>
</tr>
<tr>
<td>降低幻觉</td>
<td>通过检索到的真实信息生成回答，降低了产生幻觉的概率。</td>
<td>模型学习特定领域的数据有助于减少幻觉，但面对未见过的输入时仍可能出现幻觉。</td>
</tr>
<tr>
<td>伦理隐私</td>
<td>检索和使用外部数据可能引发伦理和隐私方面的问题。</td>
<td>训练数据中的敏感信息需要妥善处理，以防泄露。</td>
</tr>
</tbody></table>
<h3 id="现有检索增强生成框架"><a href="#现有检索增强生成框架" class="headerlink" title="现有检索增强生成框架"></a>现有检索增强生成框架</h3><p>当前已有诸多成熟开源框架可供选择，包括 <a href="https://www.langchain.com/">LangChain</a> 、<a href="https://www.llamaindex.ai/">LlamaIndex</a>、<a href="https://dify.ai/zh">Dify</a> 以及 GitHub 上能搜到很多其他的 RAG 框架（AnythingLLM、MaxKB、RAGFlow）</p>
<h3 id="RAG-案例"><a href="#RAG-案例" class="headerlink" title="RAG 案例"></a>RAG 案例</h3><ol>
<li><a href="https://github.com/logan-zou/Chat_with_Datawhale_langchain">Datawhale 知识库助手</a> ：个人知识库助手</li>
<li><a href="https://github.com/SocialAI-tianji/Tianji">天机</a>：人情世故大模型</li>
</ol>
<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><h3 id="LLM-API-服务平台"><a href="#LLM-API-服务平台" class="headerlink" title="LLM API 服务平台"></a>LLM API 服务平台</h3><ol>
<li>Groq</li>
<li>硅基流动</li>
<li>火山引擎</li>
<li>文心千帆</li>
<li>DashScope</li>
<li>aisuite</li>
<li>DeerAPI</li>
<li>Qwen-Chat</li>
<li>Deepseek-v3</li>
</ol>
<h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><ol>
<li>魔乐社区</li>
<li>HuggingFace</li>
<li>ModelScope</li>
<li>WiseModel</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="refer-anchor-1"></div>

<p>[1] <a href="https://medium.com/@lmpo/%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8F%B2-%E4%BB%8Etransformer-2017-%E5%88%B0deepseek-r1-2025-cc54d658fb43">大型语言模型简史</a></p>
<div id="refer-anchor-2"></div>

<p>[2] <a href="https://llmbook-zh.github.io/">LLM Book</a></p>
<div id="refer-anchor-3"></div>

<p>[3]:<a href="https://datawhalechina.github.io/llm-cookbook/#/">面向开发者的大模型手册 - LLM Cookbook</a></p>
<div id="refer-anchor-4"></div>

<p>[4]:<a href="https://datawhalechina.github.io/handy-ollama/#/">💻 动手学 Ollama 🦙 (datawhalechina.github.io)</a></p>
<div id="refer-anchor-5"></div>

<p>[5]:<a href="https://datawhalechina.github.io/llm-deploy/">LLM Deploy</a></p>
<div id="refer-anchor-6"></div>

<p>[6]:<a href="https://datawhalechina.github.io/so-large-lm/#/">大模型理论基础 </a></p>
<div id="refer-anchor-7"></div>

<p>[7]:<a href="https://datawhalechina.github.io/llm-universe/#/">动手学大模型应用开发 </a></p>
<div id="refer-anchor-8"></div>

<p>[8]:<a href="https://datawhalechina.github.io/hugging-llm/#/">HuggingLLM </a></p>
<div id="refer-anchor-9"></div>

<p>[9]:<a href="https://github.com/ZJU-LLMs/Foundations-of-LLMs">《大模型基础》 </a></p>
<div id="refer-anchor-10"></div>

<p>[10]:《大语言模型 从理论到实践》</p>
<div id="refer-anchor-11"></div>

<p>[11]:<a href="https://bbycroft.net/llm">可视化理解大语言模型前向计算过程 </a></p>
<div id="refer-anchor-12"></div>

<p>[12]: <a href="https://newsletter.maartengrootendorst.com/p/a-visual-guide-to-mixture-of-experts">A Visual Guide to Mixture of Experts</a></p>
]]></content>
      <categories>
        <category>PAPER</category>
      </categories>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
</search>
